<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清欢&#39;s Blog</title>
  
  <subtitle>一个杂乱的笔记本</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mingliangliu.com/"/>
  <updated>2019-03-03T15:26:03.616Z</updated>
  <id>https://mingliangliu.com/</id>
  
  <author>
    <name>清欢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编语言之标志寄存器</title>
    <link href="https://mingliangliu.com/2019/03/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://mingliangliu.com/2019/03/03/汇编语言之标志寄存器/</id>
    <published>2019-03-03T13:07:55.000Z</published>
    <updated>2019-03-03T15:26:03.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1></blockquote><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的机器，个数和结构都有可能不同）具有以下三个功能:</p><ul><li>用来存储某些相关指令的执行结果</li><li>用来为CPU执行相关的指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>这种特殊的寄存器在8086CPU中称为标志寄存器。8086的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。</p><p>标志寄存器与其他寄存器不一样，其他寄存器是用来放数据的，都是整个寄存器具有一个含义，而标志寄存器是按位起作用的。</p><p>8086中的标志寄存器的结构如下图所示:</p><img src="/images/标志寄存器.jpg"><p>其中1、3、4、12、13、14、15位在8086中没有使用。另外对于有确切含义的每一位，我们称为标志位</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>标志寄存器的第六位是ZF，零标志位。他是记录相关指令执行后，其结果是否位零。如果为零，那么zf=1,如果不为零，那么zf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果为0，所以zf=1</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果不为0，所以zf=0</p><div class="note success"><p>在这里，有一点需要注意：在8086的指令集中，有的指令的执行是影响标志位的，比如add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算数运算）；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大都是传送指令。</p></div><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>标志寄存器的第二位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果是偶数，pf=1，如果位奇数，pf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">add al, 10</span><br></pre></td></tr></table></figure><p>执行后，al为00001011B，其中有3个1，所以pf=0</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">or al, 2</span><br></pre></td></tr></table></figure><p>执行后结果为00000011B，其中有2个1，所以pf=1</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>标志寄存器的第七位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，sf=1，如果非负，sf=0</p><p>这里要明确一点，在计算机中，通常用补码来表示有符号的数据，计算机中的一个数据既可以看作有符号数，也可以看作无符号数。不管我们如何看待，当CPU在进行运算的时候，就已经包含了两种含义，也将的到同一种信息来记录的两种结果。关键在于我们的程序需要那一种。</p><p>SF标志，是CPU对有符号数运算结果一种记录。如果我们将数据当作无符号数来运算，SF标志位则没有意义，虽然计算过程中影响了他的值。</p><p>我个人在这里的更简单写的理解是计算后结果的最高位是否为1，为1，这sf=1，否则，sf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 100000001B</span><br><span class="line">add al, 1</span><br></pre></td></tr></table></figure><p>执行后结果为10000010B，sf=1，表示如果进行的是有符号运算的话，则结果为负</p><p>再比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 10000001B</span><br><span class="line">add al, 01111111B</span><br></pre></td></tr></table></figure><p>执行后，结果为0，sf=0，表示，如果进行的是有符号运算，这结果为非负</p><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>标志寄存器的第0为是CF，仅为标志位。一般情况下，在进行 <em>无符号</em> 运算的时候，它记录了运算结果的最高有效位向更高有效位的进位，或从更高有效位的借位。</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98H</span><br><span class="line">add al, al  ; 执行后(al)=30H, CF=1, 产生进位</span><br><span class="line">add al, al  ; 执行后(al)=60H, CF=0, 没有进位，或者说进位为0</span><br></pre></td></tr></table></figure><p>再比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 97H</span><br><span class="line">sub al, 98H  ; 执行后(al)=FFH, CF=1, 产生借位</span><br><span class="line">sub al, al   ; 执行后(al)=0, CF=0, 借位为0</span><br></pre></td></tr></table></figure></p><h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>标志寄存器的第11位是OF，溢出标志位。一般情况下，OF记录了 <em>有符号数</em> 的运算结果是否发生了溢出。如果发生了溢出，of=1，如果没有，of=0</p><div class="note success"><p>这里一定要注意的是CF和OF的区别，CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。 它们之间没有任何关系 </p></div><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98</span><br><span class="line">add al, 99</span><br></pre></td></tr></table></figure><p>执行后，of=1，发生溢出，没有进位</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0F0H</span><br><span class="line">add al, 78H</span><br></pre></td></tr></table></figure><p>执行后：of=0，没有溢出</p><h2 id="DF标志"><a href="#DF标志" class="headerlink" title="DF标志"></a>DF标志</h2><p>标志寄存器的第10位是DF，方向标志位。在串传送指令中，控制每次操作后si、di的增减。</p><p>df=0，每次操作后si、di递增</p><p>df=1，每次操作后si、di递减</p><p>例如串传送指令<code>movsb</code>：</p><ul><li><p>格式：<code>movsb</code></p></li><li><p>功能：执行下面几步操作：1、((es) x 16 + (di)) = ((ds) x 16 + (si)) 2、如果df=0，(si)=(si)+1, (di)=(di)+1。如果df=1，则(si)=(si)-1, (di)=(di)-1</p></li></ul><p>另外还有<code>movsw</code>，这时候就是一次传送一个字了，相应的si和di的+1-1也就变更成了+2-2</p><p>一般，<code>movsb</code>和<code>movsw</code>一般配合指令<code>rep</code>指令使用，如<code>rep movsb</code>， 相当于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s: movsb  ; 当然啦，在此之前要先设置cx寄存器</span><br><span class="line">   loop s</span><br></pre></td></tr></table></figure><h2 id="adc、sbb、cmp、pushf和popf指令"><a href="#adc、sbb、cmp、pushf和popf指令" class="headerlink" title="adc、sbb、cmp、pushf和popf指令"></a>adc、sbb、cmp、pushf和popf指令</h2><p>再没有标志寄存器的时候，我们进行加减运算最多只能进行16位的加减运算，这在实际的应用中显然是不够的，那么有了标志寄存器，在结合<code>adc</code>和<code>sbb</code>指令，我们就可以进行任意多位的数的加减法了</p><h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位的加法指令，它利用了CF上记录的进位值</p><ul><li>指令格式：adc 操作对象1，操作对象2</li><li>功能： 操作对象1 = 操作对象1 + 操作对象2 + CF</li></ul><p>比如：计算1EF000H + 201000H，结果放在ax（高16位）和bx（低16位）中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 001EH</span><br><span class="line">mov bx, 0F000H</span><br><span class="line">add bx, 1000H</span><br><span class="line">adc ax, 0020H</span><br></pre></td></tr></table></figure><p>更多位数的数相加和以上同理</p><h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是借位减法指令，它利用了CF位上记录的借位值</p><ul><li>指令格式：sbb 操作对象1，操作对象2</li><li>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</li></ul><p>比如：计算003E1000H - 00202000H，结果保存在ax，bx中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ax, 003EH</span><br><span class="line">sub bx, 2000H</span><br><span class="line">sbb ax, 0020H</span><br></pre></td></tr></table></figure><h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。执行后，对标志寄存器产生影响</p><ul><li>cmp指令格式：cmp 操作对象1，操作对象2</li><li>功能：计算操作对象1 - 操作对象2，但不保存结果</li></ul><p>经过<code>cmp</code>计算后，我们就可以用<code>je</code>、<code>jne</code>、<code>jb</code>、<code>jnb</code>、<code>ja</code>、<code>jna</code>指令进行跳转了。</p><p>因为比较复杂，在这里就不具体说实现的细节了，具体在更。</p><h3 id="pushf和popf指令"><a href="#pushf和popf指令" class="headerlink" title="pushf和popf指令"></a>pushf和popf指令</h3><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据送入标志寄存器</p><p>这两个指令为直接访问寄存器提供了一种方法</p><hr><p>在这里，我们讨论了六种寄存器，另外还有IF，TF，和AF没有讨论，具体再更</p><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h1 id=&quot;标志寄存器&quot;&gt;&lt;a href=&quot;#标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;标志寄存器&quot;&gt;&lt;/a&gt;标志寄存器&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;CPU内部的
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>原码反码和补码</title>
    <link href="https://mingliangliu.com/2019/02/28/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/"/>
    <id>https://mingliangliu.com/2019/02/28/原码反码和补码/</id>
    <published>2019-02-28T09:35:08.000Z</published>
    <updated>2019-02-28T09:54:15.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原码反码和补码"><a href="#原码反码和补码" class="headerlink" title="原码反码和补码"></a>原码反码和补码</h1><p>这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负，0为正，1为负</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码的表示法很简单，对于一个二进制数n,</p><ul><li>当n为正数时，n的原码是在n上增加一个符号位0</li><li>当n为负数时，n的原码是在n上增加一个符号位1</li><li>n为0时，在原码中，有两种表示0的方式：0.0000 1.0000</li></ul><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的反码和原码相同</li><li>当n为负数时，n的反码的符号位为1，数值部分是原码的数值部分按位取反</li><li>在反码表示中，有两种不同形式的0：0.0000 1.1111</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的补码和n的原码相同</li><li>当n为负数时，n的补码的符号为为1，数值部分是将原码数值按位取反加1</li><li>当n为0时，在补码表示中，0的表示是唯一的：0.0000</li></ul><blockquote><p>tip: 一个数补码的补码等于这个数</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原码反码和补码&quot;&gt;&lt;a href=&quot;#原码反码和补码&quot; class=&quot;headerlink&quot; title=&quot;原码反码和补码&quot;&gt;&lt;/a&gt;原码反码和补码&lt;/h1&gt;&lt;p&gt;这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负
      
    
    </summary>
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>汇编转移指令</title>
    <link href="https://mingliangliu.com/2019/02/09/%E6%B1%87%E7%BC%96%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/"/>
    <id>https://mingliangliu.com/2019/02/09/汇编转移指令/</id>
    <published>2019-02-09T03:46:09.000Z</published>
    <updated>2019-02-10T17:03:03.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><p>在8086CPU中，转移指令可分为如下几类  </p><ul><li>无条件转移指令，如jmp</li><li>条件转移指令，如jcxz</li><li>循环指令，如loop</li><li>过程</li><li>中断</li></ul><p>在此，只先讨论无条件转移中的jmp，其他东西以后再更</p><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>所谓依据位移呢，就是根据转移指令到要转移的目的地址之间相差的字节数来进行转移的，相差的字节数由编译器进行计算给出，在生成的机器指令中只包含相差的字节数，不包含目的地址，这样会是的程序更加的灵活</p><h3 id="jmp-short-标号"><a href="#jmp-short-标号" class="headerlink" title="jmp short 标号"></a>jmp short 标号</h3><p>这种格式的jmp指令实现的是段内短转移，他对IP的修改范围为-128~127，超过这个范围会报错</p><p>使用如下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">    start: mov ax,0</span><br><span class="line">           jmp short s</span><br><span class="line">           add ax,1</span><br><span class="line">        s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>参照书上的总结就是：jmp short 标号 的功能为：（IP）=(IP)+8位位移</p><ul><li>8位位移=标号处的地址-jmp指令后的第一个字节的地址（为什么是指令后第一个字节的地址，是因为和cpu执行指令的方式有关）</li><li>short指明此处的位移为8位位移</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul><h3 id="jmp-near-ptr-标号"><a href="#jmp-near-ptr-标号" class="headerlink" title="jmp near ptr 标号"></a>jmp near ptr 标号</h3><p>它和jmp short 标号的功能相似，不过是实现的段内近转移</p><p>它实现的功能为：（IP）=（IP）+ 16为位移，类似上面</p><ul><li>16位位移=标号处的地址-jmp指令后的第一个字节的地址</li><li>near ptr 指明此处的位移为16位位移，进行的是段内近转移</li><li>16位位移的范围为-32768~32767，用补码表示</li><li>16为位移由编译程序在编译时给出</li></ul><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>前面的jmp指令只能进行段间的转移，但是我们有时候需要转移的“更远”，这时候就需要这种类型的指令了</p><h3 id="jmp-far-ptr-标号"><a href="#jmp-far-ptr-标号" class="headerlink" title="jmp far ptr 标号"></a>jmp far ptr 标号</h3><p>此指令实现的是段间转移，又称为远转移功能如下</p><ul><li>（CS）=标号所在段的段地址，（IP）=标号在段中的偏移地址</li><li>far ptr 指明了用标号的段地址和偏移地址修改CS和IP</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line"> start: mov ax,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        jmp far ptr s</span><br><span class="line">        db 256 dup (0) ;这里用来占空</span><br><span class="line">     s: add ax,1</span><br><span class="line">        inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><h3 id="jmp-16位reg"><a href="#jmp-16位reg" class="headerlink" title="jmp 16位reg"></a>jmp 16位reg</h3><p>功能：（IP）=（16位reg）</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式：段内转移和段间转移</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放一个字，是转移的目的偏移地址</li><li>内存单元地址可用寻址方式的任一格式给出</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure></p><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放者两个字，高地址的字为转移的目的段地址，低地址处为转移的目的偏移地址</li><li>（CS）=（内存单元地址+2），（IP）= （内存单元地址）</li><li>内存单元地址可以用寻址方式的任何一种格式给出</li></ul><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure></p><hr><p>本文总结自王爽的《汇编语言》，如有错误欢迎指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;转移指令&quot;&gt;&lt;a href=&quot;#转移指令&quot; class=&quot;headerlink&quot; title=&quot;转移指令&quot;&gt;&lt;/a&gt;转移指令&lt;/h1&gt;&lt;p&gt;在8086CPU中，转移指令可分为如下几类  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令，如jmp&lt;/li&gt;
&lt;li&gt;条件转
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
