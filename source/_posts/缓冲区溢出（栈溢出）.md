---
title: 缓冲区溢出（栈溢出）
date: 2019-09-04 21:32:03
tags:
- Linux
- 信息安全
categories: 
---

## 前言

在现在的网络攻击中，缓冲区溢出方式的攻击占据了很大一部分，缓冲区溢出是一种非常普遍的漏洞，但同时，它也是非常危险的一种漏洞，轻则导致系统宕机，重则可导致攻击者获取系统权限，进而盗取数据，为所欲为。

其实缓冲区攻击说来也简单，请看下面一段代码：

```C
void main(int argc, char *argv[]) {
    char buffer[8];
    if(argc > 1) strcpy(buffer, argv[1]);
}
```

当我们在对`argv[1]`进行拷贝操作时，并没对其长度进行检查，这时候攻击者便可以通过拷贝一个长度大于8的字符串来覆盖程序的返回地址，让程序转而去执行攻击代码，进而使得系统被攻击。

本篇主要讲述缓冲区溢出攻击的基本原理，我会从程序是如何利用栈这种数据结构来进行运行的开始，试着编写一个shellcode，然后用该shellcode来溢出我们的程序来进行说明。我们所要使用的系统环境为x86_64 Linux，我们还要用到gcc（v7.4.0）、gdb（v8.1.0）等工具，另外，我们还需要一点汇编语言的基础，并且我们使用AT&T格式的汇编。

就我个人而言，作为一个新手，我还是比较怂来写这篇文章而言的，如果你发现又任何的错误或者不恰当的地方，欢迎指出，希望这篇文章对您有帮助。

## 进程

在现代的操作系统中，进程是一个程序的运行实体，当在操作系统中运行一个程序是，操作系统会为我们的程序创建一个进程，并给我们的程序在内存中分配运行所需的空间，这些空间被称为进程空间。进程空间主要有三部分组成：代码段，数据段和栈段。如下图所示：

{% img /images/缓冲区溢出1.jpg %}

## 栈

栈是一种后入先出的数据结构，在现代的大多数编程语言中，都使用栈这种数据结构来管理过程之间的调用。那什么又是过程之间的调用呢，说白了，一个函数或者一个方法便是一个过程，而在函数或方法内部调用另外的过程和方法便是过程间的调用。我们知道，程序的代码是被加载到内存中，然后一条条（这里指汇编）来执行的，而且时不时的需要调用其他的函数。当一个调用过程调用一个被调用过程时，所要执行的代码所在的内存地址是不同的，当被调用过程执行完后，又要回到调用过程继续执行。调用过程调用被调用过程时，需要使用`call`指令，并在`call`指令后指明要调用的地址，例如`call 地址`，当被调用过程返回时，使用`ret`指令来进行返回，但是并不需要指明返回的地址。那么程序是怎么知道我们要返回到什么地方呢？者主要是栈的功劳：执行`call`指令时，程序会自动的将`call`的下一条指令的地址加入到栈中，我们叫做返回地址。当程序返回时，程序从栈中取出返回地址，然后见程序跳转到返回地址处继续执行。


另外，程序在调用另一个过程时需要传递的参数，以及一个过程的局部变量（包括过程中开辟的缓冲区）都要分配在栈上。可见，栈是程序运行必不可少的一种机制。

但是，聪明的你可能一想：不对，既然程序的返回地址保存在栈上，过程的参数以及局部变量也保存在栈上，我们可以在程序中操纵参数和局部变量，那么我们是否也能操作返回地址，然后直接跳转到我们想要运行的代码处呢？答案当然是肯定的。

## 改变程序的返回地址

我们看这也一个程序。

```C
example.c
void func() {
        long *res;
        res = &res + 2;
        *res += 7;
}

void main() {
        int x = 1;
        func();
        x = 0;
        printf("%d\n", x);
}
```

我们在shell中使用如下命令编译运行一下，对于gcc编译时所用的参数，我们先卖个关子。

```bash
$ `gcc -fno-stack-protector example.c -o example`
$ ./example
```

你或许会说：“哎呀呀，不用看了，这么简单，运行结果是0嘛”。但结果真的是这样嘛。其实，这个程序的运行结果是1。“什么，这怎么可能是1嘛，不得了不得了”

还记的我们提到的我们可以在程序中改变过程的返回地址吗？在`func`中，看是是对res进行了一些无意义的操作，但是这却改变了`func`的返回地址，跳过了`x = 0`这条赋值命令。让我们从汇编的层面上看一下这个程序是如何执行的。

```bash
$ gdb gdb example
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
...
gdb-peda$ disassemble func 
Dump of assembler code for function func:
   0x000000000000064a <+0>:	push   %rbp
   0x000000000000064b <+1>:	mov    %rsp,%rbp
   0x000000000000064e <+4>:	lea    -0x8(%rbp),%rax
   0x0000000000000652 <+8>:	add    $0x10,%rax
   0x0000000000000656 <+12>:	mov    %rax,-0x8(%rbp)
   ...
   0x000000000000066e <+36>:	retq   
End of assembler dump.
```

在gdb中，我们使用`disassemble func`来查看一下`func`函数的汇编代码，在这里，程序栈上的情况是这样的，其中栈的宽度为8字节：

{% img /images/缓冲区溢出2.jpg %}

一看程序你也许会明白了，在4~12行（实际上这里的行应该是该条指令在该函数中第几个字节处，这里为了方便姑且就这样叫吧）程序取得`res`的地址,并将其地址加上0x10(即16)，这对应程序的`res = &res + 2;`，此时`res`指向的便是返回地址所在的地址了，然后使用`*res += 7`来改变返回地址。至于为什么是加7而不是其他数，是因为我们的目的是跳过执行`x = 0`，而`x = 0`这条程序所占的字节数刚好为7个。我们使用`disassemble main`来查看一下`main`函数的汇编代码。

```bash
gdb-peda$ disassemble main 
Dump of assembler code for function main:
   0x000000000000066f <+0>:	push   %rbp
   0x0000000000000670 <+1>:	mov    %rsp,%rbp
   0x0000000000000673 <+4>:	sub    $0x10,%rsp
   0x0000000000000677 <+8>:	movl   $0x1,-0x4(%rbp)
   0x000000000000067e <+15>:	mov    $0x0,%eax
   0x0000000000000683 <+20>:	callq  0x64a <func>
   0x0000000000000688 <+25>:	movl   $0x0,-0x4(%rbp)
   0x000000000000068f <+32>:	mov    -0x4(%rbp),%eax
   ...   
End of assembler dump.
```

上面的汇编代码中，第25行便是`x = 0`这条程序的汇编指令，我们的目的是跳过它，也就是说我们要直接执行第32行处的代码，现在返回地址是指向第25行的（还记得前面说的返回地址是`call`指令下一条指令的地址吗），为了跳过它，我们给返回地址加7。

## 覆盖返回地址

现在，我们大概了解了如何修改返回地址让程序跳转到我们指定的地方执行，但是要攻击的程序可不是我们编写的啊，我们只是知道程序的某个地方有个缓冲区可以让我们往里面写数据，我们可没有变法改变程序的代码啊。这个时候，我们就要说一说关于缓冲区的拷贝这件事了。

还记的我们开头的程序吗？这里我们为了调试起来方便，我们给它价格输出。

```C
test.c
void main(int argc, char *argv[]) {
    char buffer[8];
    if(argc > 1) strcpy(buffer, argv[1]);
    printf("%s\n", buffer);
}
```

我们的程序在栈上的结构大概是下面这个样子。这里将我们的栈换了个样子

{% img /images/缓冲区溢出3.jpg %}

当程序对`argv[1]`进行拷贝操作时，依次将字符从低地址写向高地址。当`argv[1]`的长度小于8时，我们的缓冲区`buffer`空间足够，拷贝没有问题可以完成，但当我们的`argv[1]`的过长的话，长到将返回地址都覆盖了的话，`main`函数的返回地址就不知道返回到哪里去了。

让我们来试一下：

```bash
$ gcc -fo-stack-protector  -o test test.c
$ ./test hello
hello
$ ./test helloworld
helloworld
$ ./test helloworld123456789
helloworld123456789
Segmentation fault
```

可以看到当我们给定的参数为`helloworld123456789`，我们的程序出现了段错误，也即是这时候，我们的返回地址被破环了，导致`main`函数返回时出错。这时候的栈看起来是下面这个样子的：

{% img /images/缓冲区溢出4.jpg %}

对照前面的栈结构，发现`main`函数的返回地址的确被破坏了。若是我们往返回地址处覆盖一个我们想要执行的程序的地址，那是不是就可以执行我们的程序了呢？

## shellcode

那么攻击时要执行什么程序呢？一般情况下，我们想通过缓冲区溢出来获取一个shell，一旦有了shell，我们就可以“为所欲为”了，因此我们也把这种程序叫做shellcode。那么这个shellcode在哪呢，可以确定的是，系统管理员是不会在系统中留一个shellcode的，也并不会告诉你：嘿，我这里有一个shellcode，地址是xxxx，你快把返回地址给覆盖了，来着里执行吧。所以，这个shellcode还需要我们自己编写，并传到要攻击的系统上。那要传递到哪呢？缓冲区不正是一个好地方嘛。

我们知道，在冯·诺伊曼架构的计算机中，数据和代码是不加以明确区分的，也就是说，内存中某个地方的东西，它既可以看作是一个程序的数据，也可以当作代码来执行。所以，我们大概有了一个攻击思路：我们将我们的shellcode放在缓冲区中，然后通过覆盖返回地址跳转到我们shellcode处，进而执行我们的shellcode

下面，我们来讨论如何编写一个shellcode

